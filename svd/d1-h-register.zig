// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 61c88e4cec8696b8eb1b39eddcd2f3c82400975e
//
// vendor: Allwinner
// device: D1-H
// cpu: XuanTie C906 RISC-V CPU

pub const registers = struct {

    /// Audio Codec
    pub const @"Audio Codec" = struct {
        pub const base_address = 0x2030000;

        /// address: 0x203004c
        /// AC_ADC_DG_REG
        pub const AC_ADC_DG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// ADC output channel swap enable (for digital filter)
            /// 0: Disabled
            /// 1: Enabled
            AD_SWP1: u1,
            /// ADC output channel swap enable (for digital filter)
            /// 0: Disabled
            /// 1: Enabled
            AD_SWP2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x4c);

        /// address: 0x20302a4
        /// AC_ADC_DRC_MNGHS
        pub const AC_ADC_DRC_MNGHS = @intToPtr(*volatile Mmio(32, packed struct {
            /// The min gain setting, which is determined by equation MXG =MXG/6.0206. The
            /// format is 8.24 and must -60 dB ≤ MNG ≤ -40 dB (The default value is -40 dB)
            ADC_DRC_MNGHS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2a4);

        /// address: 0x20300f0
        /// AC_DAC_DAP_CTR
        pub const AC_DAC_DAP_CTR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// HPF enable control
            /// 0: Disabled
            /// 1: Enabled
            DDAP_HPF_EN: u1,
            /// DRC enable control
            /// 0: Disabled
            /// 1: Enabled
            DDAP_DRC_EN: u1,
            reserved28: u1,
            /// DAP for DRC enable
            /// 0: Bypassed
            /// 1: Enabled
            DDAP_EN: u1,
        }), base_address + 0xf0);

        /// address: 0x203034c
        /// ADC_CUR_REG
        pub const ADC_CUR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC1_OUTPUT_CURRENT ADC1 OP MIC2 Output Current Select
            /// 00: 15I
            /// 01: 20I
            /// 10: 35I
            /// 11: 40I I=7 uA 9 Interfaces
            /// ................................................................................................................................................................
            /// 859 9.1 TWI
            /// ..................................................................................................................................................................
            /// 859 9.1.1 Overview
            /// .............................................................................................................................................
            /// 859 9.1.2 Block Diagram
            /// .....................................................................................................................................
            /// 859 9.1.3 Functional Description
            /// ........................................................................................................................
            /// 861 9.1.4 Programming Guidelines
            /// .....................................................................................................................
            /// 867 9.1.5 Register List
            /// .........................................................................................................................................
            /// 870 9.1.6 Register Description
            /// ............................................................................................................................
            /// 871 9.2
            /// UART................................................................................................................................................................
            /// 886 9.2.1 Overview
            /// .............................................................................................................................................
            /// 886 9.2.2 Block Diagram
            /// .....................................................................................................................................
            /// 886 9.2.3 Functional Description
            /// ........................................................................................................................
            /// 887 9.2.4 Programming Guidelines
            /// .....................................................................................................................
            /// 893 9.2.5 Register List
            /// .........................................................................................................................................
            /// 896 9.2.6 Register Description
            /// ............................................................................................................................
            /// 898 9.3 SPI
            /// ....................................................................................................................................................................
            /// 927 9.3.1 Overview
            /// .............................................................................................................................................
            /// 927 9.3.2 Block Diagram
            /// .....................................................................................................................................
            /// 927 9.3.3 Functional Description
            /// ........................................................................................................................
            /// 929 9.3.4 Programming Guidelines
            /// .....................................................................................................................
            /// 937 9.3.5 Register List
            /// .........................................................................................................................................
            /// 940 9.3.6 Register Description
            /// ............................................................................................................................
            /// 941 9.4 SPI_DBI
            /// ............................................................................................................................................................
            /// 962 9.4.1 Overview
            /// .............................................................................................................................................
            /// 962 9.4.2 Block Diagram
            /// .....................................................................................................................................
            /// 963 9.4.3 Functional Description
            /// ........................................................................................................................
            /// 964 9.4.4 Programming Guidelines
            /// .....................................................................................................................
            /// 984 9.4.5 Register List
            /// .........................................................................................................................................
            /// 992 9.4.6 Register Description
            /// ............................................................................................................................
            /// 993 9.5 USB2.0 DRD
            /// ...................................................................................................................................................
            /// 1025 9.5.1 Overview
            /// ...........................................................................................................................................
            /// 1025 9.5.2 Block Diagram
            /// ...................................................................................................................................
            /// 1026 9.5.3 Functional Description
            /// ......................................................................................................................
            /// 1026 9.6 USB2.0 HOST
            /// .................................................................................................................................................
            /// 1028 9.6.1 Overview
            /// ...........................................................................................................................................
            /// 1028 9.6.2 Block Diagram
            /// ...................................................................................................................................
            /// 1028 9.6.3 Functional Description
            /// ......................................................................................................................
            /// 1029 9.6.4 Register List
            /// .......................................................................................................................................
            /// 1029 9.6.5 EHCI Register
            /// Description..................................................................................................................
            /// 1031 9.6.6 OHCI Register Description
            /// .................................................................................................................
            /// 1048 9.7 GPIO
            /// ..............................................................................................................................................................
            /// 1070 9.7.1 Overview
            /// ...........................................................................................................................................
            /// 1070 9.7.2 Block Diagram
            /// ...................................................................................................................................
            /// 1070 9.7.3 Functional Description
            /// ......................................................................................................................
            /// 1071 9.7.4 Register List
            /// .......................................................................................................................................
            /// 1080 9.7.5 Register Description
            /// ..........................................................................................................................
            /// 1082 9.8 GPADC
            /// ...........................................................................................................................................................
            /// 1190 9.8.1 Overview
            /// ...........................................................................................................................................
            /// 1190 9.8.2 Block Diagram
            /// ...................................................................................................................................
            /// 1190 9.8.3 Functional Description
            /// ......................................................................................................................
            /// 1191 9.8.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1192 9.8.5 Register List
            /// .......................................................................................................................................
            /// 1194 9.8.6 Register Description
            /// ..........................................................................................................................
            /// 1195 9.9 TPADC
            /// ............................................................................................................................................................
            /// 1204 9.9.1 Overview
            /// ...........................................................................................................................................
            /// 1204 9.9.2 Functional Description
            /// ......................................................................................................................
            /// 1204 9.9.3 Register List
            /// .......................................................................................................................................
            /// 1210 9.9.4 Register Description
            /// ..........................................................................................................................
            /// 1211 9.10 LRADC
            /// ............................................................................................................................................................
            /// 1219 9.10.1 Overview
            /// ...........................................................................................................................................
            /// 1219 9.10.2 Block Diagram
            /// ...................................................................................................................................
            /// 1219 9.10.3 Functional Description
            /// ......................................................................................................................
            /// 1220 9.10.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1221 9.10.5 Register List
            /// .......................................................................................................................................
            /// 1223 9.10.6 Register Description
            /// ..........................................................................................................................
            /// 1223 9.11 PWM
            /// .............................................................................................................................................................
            /// 1228 9.11.1 Overview
            /// ...........................................................................................................................................
            /// 1228 9.11.2 Block Diagram
            /// ...................................................................................................................................
            /// 1228 9.11.3 Functional Description
            /// ......................................................................................................................
            /// 1229 9.11.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1239 9.11.5 Register List
            /// .......................................................................................................................................
            /// 1240 9.11.6 Register Description
            /// ..........................................................................................................................
            /// 1242 9.12 LEDC
            /// ..............................................................................................................................................................
            /// 1269 9.12.1 Overview
            /// ...........................................................................................................................................
            /// 1269 9.12.2 Block Diagram
            /// ...................................................................................................................................
            /// 1269 9.12.3 Functional Description
            /// ......................................................................................................................
            /// 1270 9.12.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1274 9.12.5 Register List
            /// .......................................................................................................................................
            /// 1279 9.12.6 Register Description
            /// ..........................................................................................................................
            /// 1279 9.13 EMAC
            /// .............................................................................................................................................................
            /// 1290 9.13.1 Overview
            /// ...........................................................................................................................................
            /// 1290 9.13.2 Block Diagram
            /// ...................................................................................................................................
            /// 1290 9.13.3 Functional Description
            /// ......................................................................................................................
            /// 1291 9.13.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1298 9.13.5 Register List
            /// .......................................................................................................................................
            /// 1299 9.13.6 Register Description
            /// ..........................................................................................................................
            /// 1300 9.14 CIR Receiver
            /// ..................................................................................................................................................
            /// 1318 9.14.1 Overview
            /// ...........................................................................................................................................
            /// 1318 9.14.2 Block Diagram
            /// ...................................................................................................................................
            /// 1318 9.14.3 Functional Description
            /// ......................................................................................................................
            /// 1319 9.14.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1323 9.14.5 Register List
            /// .......................................................................................................................................
            /// 1324 9.14.6 Register Description
            /// ..........................................................................................................................
            /// 1324 9.15 CIR Transmitter
            /// .............................................................................................................................................
            /// 1330 9.15.1 Overview
            /// ...........................................................................................................................................
            /// 1330 9.15.2 Block Diagram
            /// ...................................................................................................................................
            /// 1330 9.15.3 Functional Description
            /// ......................................................................................................................
            /// 1331 9.15.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1333 9.15.5 Register List
            /// .......................................................................................................................................
            /// 1334 9.15.6 Register Description
            /// ..........................................................................................................................
            /// 1334 Figure 9-1 TWI Block Diagram
            /// ...........................................................................................................................................
            /// 860 Figure 9-2 Write Timing in 7-bit Standard Addressing Mode
            /// ...........................................................................................
            /// 862 Figure 9-3 Read Timing in 7-bit Standard Addressing Mode
            /// ............................................................................................
            /// 862 Figure 9-4 Write Timing in 10-bit Extended Addressing Mode
            /// .........................................................................................
            /// 863 Figure 9-5 Read Timing in 10-bit Extended Addressing Mode
            /// ..........................................................................................
            /// 863 Figure 9-6 TWI Driver Write Packet Transmission
            /// ............................................................................................................
            /// 864 Figure 9-7 TWI Driver Read Packet Transmission
            /// .............................................................................................................
            /// 865 Figure 9-8 TWI Programming State Diagram
            /// ....................................................................................................................
            /// 867 Figure 9-9 UART Block Diagram
            /// ........................................................................................................................................
            /// 887 Figure 9-10 UART Serial Data Format
            /// ...............................................................................................................................
            /// 888 Figure 9-11 Application Diagram for RTS/CTS Autoflow Control
            /// ......................................................................................
            /// 889 Figure 9-12 RTS/CTS Autoflow Control Data Format
            /// ........................................................................................................
            /// 889 Figure 9-13 Application Diagram for IrDA Transceiver
            /// .....................................................................................................
            /// 889 Figure 9-14 Serial IrDA Data Format
            /// .................................................................................................................................
            /// 890 Figure 9-15 Application Diagram for RS-485 Transceiver
            /// .................................................................................................
            /// 890 Figure 9-16 RS-485 Data Format
            /// .......................................................................................................................................
            /// 890 Figure 9-17 UART Mode Baud and Error Rates
            /// .................................................................................................................
            /// 891 Figure 9-18 IrDA Mode Baud and Error Rates
            /// ...................................................................................................................
            /// 892 Figure 9-19 RS485 Mode Baud and Error Rates
            /// ................................................................................................................
            /// 892 Figure 9-20 SPI Block Diagram
            /// ..........................................................................................................................................
            /// 928 Figure 9-21 SPI Application Block Diagram
            /// .......................................................................................................................
            /// 930 Figure 9-22 SPI Phase 0 Timing Diagram
            /// ...........................................................................................................................
            /// 931 Figure 9-23 SPI Phase 1 Timing Diagram
            /// ...........................................................................................................................
            /// 931 Figure 9-24 SPI 3-Wire Mode
            /// ............................................................................................................................................
            /// 932 Figure 9-25 SPI Dual-Input/Dual-Output Mode
            /// ................................................................................................................
            /// 933 Figure 9-26 SPI Dual I/O Mode
            /// ..........................................................................................................................................
            /// 933 Figure 9-27 SPI Quad-Input/Quad-Output Mode
            /// .............................................................................................................
            /// 934 Figure 9-28 SPI Write/Read Data in CPU Mode
            /// ................................................................................................................
            /// 938 Figure 9-29 SPI Write/Read Data in DMA Mode
            /// ...............................................................................................................
            /// 939 Figure 9-30 SPI_DBI Block Diagram
            /// ...................................................................................................................................
            /// 963 Figure 9-31 SPI Application Block Diagram
            /// .......................................................................................................................
            /// 966 Figure 9-32 DBI Application Block Diagram
            /// ......................................................................................................................
            /// 966 Figure 9-33 SPI Phase 0 Timing Diagram
            /// ...........................................................................................................................
            /// 967 Figure 9-34 SPI Phase 1 Timing Diagram
            /// ...........................................................................................................................
            /// 967 Figure 9-35 SPI 3-Wire Mode
            /// ............................................................................................................................................
            /// 968 Figure 9-36 SPI Dual-Input/Dual-Output Mode
            /// ................................................................................................................
            /// 969 Figure 9-37 SPI Dual I/O Mode
            /// ..........................................................................................................................................
            /// 969 Figure 9-38 SPI Quad-Input/Quad-Output Mode
            /// .............................................................................................................
            /// 970 Figure 9-39 DBI 3-Line Display Bus Serial Interface Writing Operation Format
            /// ............................................................... 972 Figure 9-40
            /// DBI 3-Line Display Bus Serial Interface 8-bit Reading Operation Format
            /// ...................................................... 973 Figure 9-41 DBI
            /// 3-Line Display Bus Serial Interface 24-bit Reading Operation Format
            /// .................................................... 973 Figure 9-42 DBI 3-Line
            /// Display Bus Serial Interface 32-bit Reading Operation Format
            /// .................................................... 974 Figure 9-43 DBI 4-Line
            /// Display Bus Serial Interface Writing Operation Format
            /// ............................................................... 975 Figure 9-44
            /// DBI 4-Line Display Bus Serial Interface 8-bit Reading Operation Format
            /// ...................................................... 975 Figure 9-45 DBI
            /// 4-Line Display Bus Serial Interface 24-bit Reading Operation Format
            /// .................................................... 976 Figure 9-46 DBI 4-Line
            /// Display Bus Serial Interface 32-bit Reading Operation Format
            /// .................................................... 976 Figure 9-47 RGB111
            /// 3-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 977 Figure 9-48 RGB444 3-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 977 Figure 9-49 RGB565 3-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 978 Figure 9-50 RGB666 3-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 978 Figure 9-51 RGB111 4-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 979 Figure 9-52 RGB444 4-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 979 Figure 9-53 RGB565 4-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 980 Figure 9-54 RGB666 4-Line Interface Transmit Video Format
            /// ..........................................................................................
            /// 980 Figure 9-55 RGB444 2 Data Lane Interface Transmit Video Format
            /// .................................................................................
            /// 981 Figure 9-56 RGB565 2 Data Lane Interface Transmit Video Format
            /// .................................................................................
            /// 982 Figure 9-57 RGB666 2 Data Lane Interface Transmit Video Format 0
            /// ..............................................................................
            /// 983 Figure 9-58 RGB666 2 Data Lane Interface Transmit Video Format 1 (ilitek)
            /// ................................................................... 983 Figure
            /// 9-59 RGB666 2 Data Lane Interface Transmit Video Format 2 (New vision)
            /// ......................................................... 983 Figure 9-60 RGB888
            /// 2 Data Lane Interface Transmit Video Format
            /// .................................................................................
            /// 984 Figure 9-61 SPI Write/Read Data in CPU Mode
            /// ................................................................................................................
            /// 985 Figure 9-62 SPI Write/Read Data in DMA Mode
            /// ...............................................................................................................
            /// 986 Figure 9-63 USB2.0 DRD Controller Block Diagram
            /// ........................................................................................................
            /// 1026 Figure 9-64 USB2.0 DRD Controller and PHY Connection Diagram
            /// ................................................................................
            /// 1027 Figure 9-65 USB2.0 Host Controller Block Diagram
            /// ........................................................................................................
            /// 1028 Figure 9-66 USB2.0 Host Controller and PHY Connection Diagram
            /// ................................................................................
            /// 1029 Figure 9-67 GPIO Block Diagram
            /// .....................................................................................................................................
            /// 1071 Figure 9-68 Pull up/down Logic
            /// ......................................................................................................................................
            /// 1077 Figure 9-69 IO Buffer Strength Diagram
            /// .........................................................................................................................
            /// 1078 Figure 9-70 GPADC Block Diagram
            /// ..................................................................................................................................
            /// 1190 Figure 9-71 GPADC Clock and Timing Requirement
            /// .......................................................................................................
            /// 1192 Figure 9-72 GPADC Initial Process
            /// ...................................................................................................................................
            /// 1193 Figure 9-73 TPADC Single-Ended Mode for AUX ADC
            /// .....................................................................................................
            /// 1205 Figure 9-74 TPADC Differential Mode for Touch
            /// Panel...................................................................................................
            /// 1206 Figure 9-75 Single Touch X-Coordinate Measurement for Touch Panel
            /// ......................................................................... 1206
            /// Figure 9-76 Dual Touch Detection for Touch Panel
            /// ........................................................................................................
            /// 1207 Figure 9-77 Touch Pressure Measurement for Touch Panel
            /// ..........................................................................................
            /// 1208 Figure 9-78 Pen Down Detection for Touch Panel
            /// ..........................................................................................................
            /// 1209 Figure 9-79 Median and Averaging Filter Size
            /// ................................................................................................................
            /// 1209 Figure 9-80 Median and Averaging Filter Example
            /// .........................................................................................................
            /// 1210 Figure 9-81 LRADC Block Diagram
            /// ..................................................................................................................................
            /// 1219 Figure 9-82 LRADC Interrupt
            /// ...........................................................................................................................................
            /// 1221 Figure 9-83 PWM Block Diagram
            /// ....................................................................................................................................
            /// 1229 Figure 9-84 PWM01 Clock Controller Diagram
            /// ...............................................................................................................
            /// 1230 Figure 9-85 PWM01 Output Logic Module Diagram
            /// .......................................................................................................
            /// 1231 Figure 9-86 PWM0 High Level Active State
            /// .....................................................................................................................
            /// 1232 Figure 9-87 PWM0 Low Level Active State
            /// .....................................................................................................................
            /// 1233 Figure 9-88 Phase of PWM0 High Level Active State
            /// ......................................................................................................
            /// 1233 Figure 9-89 PWM0 Output Waveform in Pulse Mode and Cycle Mode
            /// ......................................................................... 1234
            /// Figure 9-90 PWM01 Complementary Pair Output
            /// ..........................................................................................................
            /// 1235 Figure 9-91 Dead-time Output Waveform
            /// ......................................................................................................................
            /// 1235 Figure 9-92 Group 0~3 PWM Signal Output
            /// ...................................................................................................................
            /// 1236 Figure 9-93 PWM01 Capture Logic Module Diagram
            /// .....................................................................................................
            /// 1237 Figure 9-94 PWM0 Channel Capture
            /// Timing...................................................................................................................
            /// 1238 Figure 9-95 LEDC Block Diagram
            /// .....................................................................................................................................
            /// 1269 Figure 9-96 LEDC Package Output Timing Diagram
            /// ........................................................................................................
            /// 1270 Figure 9-97 LEDC 1-frame Output Timing
            /// Diagram.........................................................................................................
            /// 1271 Figure 9-98 LEDC Input Data Structure
            /// ...........................................................................................................................
            /// 1271 Figure 9-99 LEDC Typical Circuit
            /// ......................................................................................................................................
            /// 1271 Figure 9-100 LEDC Data Input Code
            /// ................................................................................................................................
            /// 1272 Figure 9-101 LEDC Data Transfer Mode
            /// ..........................................................................................................................
            /// 1272 Figure 9-102 LEDC Normal Configuration Process
            /// ..........................................................................................................
            /// 1275 Figure 9-103 LEDC Timeout Abnormal Processing Flow
            /// .................................................................................................
            /// 1277 Figure 9-104 FIFO Overflow Abnormal Processing Flow
            /// .................................................................................................
            /// 1278 Figure 9-105 EMAC Block Diagram
            /// .................................................................................................................................
            /// 1291 Figure 9-106 EMAC Typical Application
            /// ..........................................................................................................................
            /// 1293 Figure 9-107 EMAC RX/TX Descriptor List
            /// .......................................................................................................................
            /// 1294 Figure 9-108 CIR_RX Block Diagram
            /// ................................................................................................................................
            /// 1318 Figure 9-109 CIR_RX Clock System
            /// ..................................................................................................................................
            /// 1319 Figure 9-110 CIR_RX Application Diagram
            /// ......................................................................................................................
            /// 1319 Figure 9-111 NEC Protocol
            /// ..............................................................................................................................................
            /// 1320 Figure 9-112 Logical ‘0’ and Logical ‘1’ of NEC Protocol
            /// .................................................................................................
            /// 1320 Figure 9-113 ATHR Definition
            /// .........................................................................................................................................
            /// 1321 Figure 9-114 ITHR Definition
            /// ...........................................................................................................................................
            /// 1321 Figure 9-115 NTHR Definition
            /// .........................................................................................................................................
            /// 1321 Figure 9-116 APAM Definition
            /// ........................................................................................................................................
            /// 1322 Figure 9-117 CIR Receiver Process
            /// ..................................................................................................................................
            /// 1323 Figure 9-118 CIR_TX Block Diagram
            /// ................................................................................................................................
            /// 1330 Figure 9-119 CIR_TX Clock Description
            /// ...........................................................................................................................
            /// 1331 Figure 9-120 Definitions of Logical “1” and Logical “0”
            /// ..................................................................................................
            /// 1332 Figure 9-121 CIR Message Timing
            /// Diagram.....................................................................................................................
            /// 1332 Figure 9-122 CIR Transmitter Process
            /// .............................................................................................................................
            /// 1333 Table 9-1 TWI Sub-blocks
            /// ..................................................................................................................................................
            /// 860 Table 9-2 TWI External Signals
            /// ..........................................................................................................................................
            /// 861 Table 9-3 TWI Clock Sources
            /// .............................................................................................................................................
            /// 861 Table 9-4 UART External Signals
            /// .......................................................................................................................................
            /// 887 Table 9-5 UART Clock
            /// Sources...........................................................................................................................................
            /// 888 Table 9-6 SPI Sub-blocks
            /// ...................................................................................................................................................
            /// 928 Table 9-7 SPI External Signals
            /// ...........................................................................................................................................
            /// 929 Table 9-8 SPI Clock Sources
            /// ...............................................................................................................................................
            /// 929 Table 9-9 SPI Transmit Format
            /// ..........................................................................................................................................
            /// 931 Table 9-10 SPI Old Sample Mode and Run Clock
            /// ..............................................................................................................
            /// 935 Table 9-11 SPI New Sample Mode
            /// ....................................................................................................................................
            /// 935 Table 9-12 SPI_DBI Sub-blocks
            /// ..........................................................................................................................................
            /// 963 Table 9-13 SPI_DBI External Signals
            /// ..................................................................................................................................
            /// 964 Table 9-14 SPI_DBI Clock Sources
            /// .....................................................................................................................................
            /// 965 Table 9-15 SPI Transmit Format
            /// ........................................................................................................................................
            /// 967 Table 9-16 SPI Old Sample Mode and Run Clock
            /// ..............................................................................................................
            /// 971 Table 9-17 SPI New Sample Mode
            /// ....................................................................................................................................
            /// 971 Table 9-18 USB2.0 DRD External Signals
            /// .........................................................................................................................
            /// 1026 Table 9-19 USB2.0 Host External Signals
            /// ........................................................................................................................
            /// 1029 Table 9-20 Multi-function Port
            /// .......................................................................................................................................
            /// 1071 Table 9-21 PB Multiplex Function
            /// ...................................................................................................................................
            /// 1073 Table 9-22 PC Multiplex Function
            /// ...................................................................................................................................
            /// 1073 Table 9-23 PD Multiplex Function
            /// ...................................................................................................................................
            /// 1074 Table 9-24 PE Multiplex Function
            /// ...................................................................................................................................
            /// 1074 Table 9-25 PF Multiplex Function
            /// ...................................................................................................................................
            /// 1075 Table 9-26 PG Multiplex Function
            /// ...................................................................................................................................
            /// 1075 Table 9-27 Port Function
            /// .................................................................................................................................................
            /// 1077 Table 9-28 GPADC External Signals
            /// .................................................................................................................................
            /// 1191 Table 9-29 GPADC Clock Sources
            /// ....................................................................................................................................
            /// 1191 Table 9-30 TPADC External
            /// Signals..................................................................................................................................
            /// 1204 Table 9-31 LRADC External Signals
            /// ..................................................................................................................................
            /// 1220 Table 9-32 LRADC Clock Sources
            /// .....................................................................................................................................
            /// 1220 Table 9-33 PWM External Signals
            /// ...................................................................................................................................
            /// 1229 Table 9-34 LEDC Sub-blocks
            /// ............................................................................................................................................
            /// 1269 Table 9-35 LEDC External Signals
            /// ....................................................................................................................................
            /// 1270 Table 9-36 LEDC Clock Sources
            /// .......................................................................................................................................
            /// 1270 Table 9-37 Time Parameters of Typical LED Specification
            /// ..............................................................................................
            /// 1272 Table 9-38 EMAC Pin
            /// Mapping........................................................................................................................................
            /// 1291 Table 9-39 EMAC RGMII Pin List
            /// .....................................................................................................................................
            /// 1292 Table 9-40 EMAC RMII Pin List
            /// ........................................................................................................................................
            /// 1292 Table 9-41 EMAC Clock Characteristics
            /// ...........................................................................................................................
            /// 1293 Table 9-42 EMAC_EPHY_CLK_REG0 Configuration Value
            /// ...............................................................................................
            /// 1298 Table 9-43 CIR_RX External Signals
            /// .................................................................................................................................
            /// 1319 Table 9-44 CIR_TX External Signals
            /// .................................................................................................................................
            /// 1331
            ADC1_OUTPUT_CURRENT_ADC1_OP_MIC2: u2,
            /// ADC1_OUTPUT_CURRENT ADC1 OP MIC1 Output Current Select
            /// 00: 15I
            /// 01: 20I
            /// 10: 35I
            /// 11: 40I I=7 uA
            ADC1_OUTPUT_CURRENT_ADC1_OP_MIC1: u2,
            /// ADC1_IOPMIC2 ADC1 OP MIC2 Bias Current Select
            /// 00: 1.50*IOPADC
            /// 01: 1.75*IOPADC
            /// 10: 2.00*IOPADC
            /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
            ADC1_IOPMIC2_ADC1_OP_MIC2: u2,
            reserved0: u1,
            reserved1: u1,
            /// ADC2_OUTPUT_CURRENT ADC2 OP MIC2 Output Current Select
            /// 00: 15I
            /// 01: 20I
            /// 10: 35I
            /// 11: 40I I=7 uA
            ADC2_OUTPUT_CURRENT_ADC2_OP_MIC2: u2,
            /// ADC2_OUTPUT_CURRENT ADC2 OP MIC1 Output Current Select
            /// 00: 15I
            /// 01: 20I
            /// 10: 35I
            /// 11: 40I I=7 uA
            ADC2_OUTPUT_CURRENT_ADC2_OP_MIC1: u2,
            /// ADC2_IOPMIC2 ADC2 OP MIC2 Bias Current Select
            /// 00: 1.50*IOPADC
            /// 01: 1.75*IOPADC
            /// 10: 2.00*IOPADC
            /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
            ADC2_IOPMIC2_ADC2_OP_MIC2: u2,
            reserved2: u1,
            reserved3: u1,
            /// ADC3_OUTPUT_CURRENT ADC3 OP MIC2 Output Current Select
            /// 00: 15I
            /// 01: 20I
            /// 10: 35I
            /// 11: 40I I=7 uA
            ADC3_OUTPUT_CURRENT_ADC3_OP_MIC2: u2,
            /// ADC3_OUTPUT_CURRENT ADC3 OP MIC1 Output Current Select
            /// 00: 15I
            /// 01: 20I
            /// 10: 35I
            /// 11: 40I I=7 uA
            ADC3_OUTPUT_CURRENT_ADC3_OP_MIC1: u2,
            /// ADC3_IOPMIC2 ADC3 OP MIC2 Bias Current Select
            /// 00: 1.50*IOPADC
            /// 01: 1.75*IOPADC
            /// 10: 2.00*IOPADC
            /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA
            ADC3_IOPMIC2_ADC3_OP_MIC2: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x34c);

        /// address: 0x2030328
        /// HMIC_CTRL
        pub const HMIC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// MIC Detect Interrupt Set
            /// 0: Disabled
            /// 1: Enabled
            MIC_DET_IRQ_EN: u1,
            /// MIC Detect Interrupt Set
            /// 0: Disabled
            /// 1: Enabled
            JACK_IN_IRQ_EN: u1,
            /// MIC Detect Interrupt Set
            /// 0: Disabled
            /// 1: Enabled
            JACK_OUT_IRQ_EN: u1,
            /// MDATA Threshold Debounce
            /// 000: 0
            /// 001: 1
            /// 010: 2
            /// 011: 3
            /// 100: 4
            /// 101: 5
            /// 110: 6
            /// 111: 7
            MDATA_THRESHOLD_DEBOUNCE: u3,
            /// Debounce when earphone plug in or pull out 125 ms to 2 s
            /// 0000: 125 ms
            /// 0001: 250 ms …
            /// 1111: 2 s
            HMIC_N: u4,
            /// Debounce when the MIC Key down or up. 0000:1 samlpe data 0001:2 samlpe data ...
            /// 1111:16 samlpe data
            HMIC_M: u4,
            /// HMIC Smooth Filter setting
            /// 00: by pass
            /// 01: (x1+x2)/2
            /// 10: (x1+x2+x3+x4)/4
            /// 11: (x1+x2+x3+x4+ x5+x6+x7+x8)/8
            HMIC_SF: u2,
            /// MIC DET EN Threshold Value
            MDATA_THRESHOLD: u5,
            /// Down Sample Setting Select
            /// 00: Down by 1, 128 Hz
            /// 01: Down by 2, 64 Hz
            /// 10: Down by 4, 32 Hz
            /// 11: Down by 8, 16 Hz
            HMIC_SAMPLE_SELECT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x328);

        /// address: 0x203032c
        /// HMIC_STS
        pub const HMIC_STS = @intToPtr(*volatile Mmio(32, packed struct {
            /// MIC detect pending interrupt
            /// 0: No pending IRQ
            /// 1: Pending IRQ Writing 1 clear pending.
            MIC_DET_ST: u1,
            reserved0: u1,
            reserved1: u1,
            /// Jack input detect pending interrupt
            /// 0: No Pending IRQ
            /// 1: Pending IRQ Writing 1 clear pending.
            JACK_DET_IIRQ: u1,
            /// Jack output detect pending interrupt
            /// 0: No Pending IRQ
            /// 1: Pending IRQ Writing 1 clear pending.
            JACK_DET_OIRQ: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// HMIC Average Data
            HMIC_DATA: u5,
            /// After MIC DATA data is received, the first N-data will be discarded. N defined
            /// as follows:
            /// 00: None discarded
            /// 01: 1-data discarded
            /// 10: 2-data discarded
            /// 11: 4-data discarded
            MDATA_DISCARD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x32c);

        /// address: 0x2030340
        /// HP2_REG
        pub const HP2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Headphone Feedback Buffer Output Current Select
            /// 00: 35I
            /// 01: 28I
            /// 10: 45I
            /// 11: 38I I=7 uA
            HPFB_BUF_OUTPUT_CURRENT: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Ramp Final State Resistor
            /// 00: 2.5k
            /// 01: 5.0k
            /// 10: 10k
            /// 11: 20k
            RAMP_FINAL_STATE_RES: u2,
            /// Ramp Output Switch Enable
            /// 0: Disable
            /// 1: Enable
            RAMP_OUT_EN: u1,
            /// Headphone Ramp Final Step Control
            /// 0: Ramp Output Select Ramp
            /// 1: Ramp Output Select HPFB buffer Output
            RAMP_FINAL_CONTROL: u1,
            /// Headphone Feedback PAD IN Switch Enable
            /// 0: Disabled
            /// 1: Enabled
            HPFB_IN_EN: u1,
            /// Ramp DAC Enable
            /// 0: Disabled
            /// 1: Enabled
            RAMPEN: u1,
            /// RSwitch
            /// 0: HPOUT OUTPUT VCM of RAMP_DAC
            /// 1: VRA1
            RSWITCH: u1,
            /// Headphone Driver Output Enable
            /// 0: Disabled
            /// 1: Enabled
            HP_DRVOUTEN: u1,
            /// Headphone Driver Enable
            /// 0: Disable
            /// 1: Enable
            HP_DRVEN: u1,
            /// Headphone L/R OP Bias Current Select
            /// 00: 6 uA
            /// 01: 7 uA
            /// 10: 8 uA
            /// 11: 9 uA
            IOPHP: u2,
            /// Headphone OP Output Stage Current Setting
            /// 00: Min
            /// 11: Max
            OPDRV_CUR: u2,
            /// Headphone Feedback Big Resistor Control
            /// 00: 0.88 MΩ
            /// 01: 1.00 MΩ
            /// 10: 1.08 MΩ
            /// 11: 1.20 MΩ
            HPFB_RES: u2,
            /// HeadPhone Gain
            /// 000: 0 dB
            /// 001: -6 dB
            /// 010: -12 dB
            /// 011: -18 dB
            /// 100: -24 dB
            /// 101: -30 dB
            /// 110: -36 dB
            /// 111: -42 dB
            HEADPHONE_GAIN: u3,
            /// Headphone Feedback Buffer OP Enable
            /// 0: Disable
            /// 1: Enable
            HPFB_BUF_EN: u1,
        }), base_address + 0x340);

        /// address: 0x2030348
        /// POWER_REG
        pub const POWER_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// BG Output Voltage Trimming Only low 6-bit is used. The BG output voltage range
            /// is from 0.7 V to 1.208 V.
            BG_TRIM: u8,
            /// HPLDO Output Voltage Control
            /// 000: 2.03 V
            /// 001: 1.95 V
            /// 010: 1.87 V
            /// 011: 1.80 V
            /// 100: 1.73 V
            /// 101: 1.67 V
            /// 110: 1.61 V
            /// 111: 1.56 V
            HPLDO_OUTPUT_VOLTAGE: u3,
            reserved0: u1,
            /// ALDO Output Voltage Control
            /// 000: 2.03 V
            /// 001: 1.95 V
            /// 010: 1.87 V
            /// 011: 1.80 V
            /// 100: 1.73 V
            /// 101: 1.67 V
            /// 110: 1.61 V
            /// 111: 1.56 V
            ALDO_OUTPUT_VOLTAGE: u3,
            reserved1: u1,
            /// Avccpor Monitor
            AVCCPOR: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// VAR1 Speedup Down Further Control In Adda Analog
            /// 0: The digital logic signal input by the digital-analog interface pin controls
            /// the var1_speedup_down function (that is, the var1 signal is rapidly pulled
            /// up/down)
            /// 1: Writing 1 can finish the var1_speedup_down function (ignore the control of
            /// the digital-analog interface pin)
            VAR1SPEEDUP_DOWN_FURTHER_CTRL: u1,
            /// HPLDO Enable
            /// 0: Disabled
            /// 1: Enabled
            HPLDO_EN: u1,
            /// ALDO Enable
            /// 0: Disabled
            /// 1: Enabled
            ALDO_EN: u1,
        }), base_address + 0x348);

        pub const @"ANALOG DOMAIN REGISTER" = struct {

            /// address: 0x2030300
            /// ADC1 Analog Control Register
            pub const ADC1_REG = @intToPtr(*volatile Mmio(32, packed struct {
                /// ADC1 OP MIC Bias Current Select
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC1_IOPMIC: u2,
                /// ADC1 OP SDM Bias Current Select 2
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC1_IOPSDM2: u2,
                /// ADC1 OP SDM Bias Current Select 1
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC1_IOPSDM1: u2,
                /// ADC1 OP AAF Bias Current Select
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA. For
                /// example: ADC1_REG<15:14> = 11, IOPADC = 4 uA
                /// 00: 1.50*4 uA = 6 uA
                /// 01: 1.75*4 uA = 7 uA
                /// 10: 2.00*4 uA = 8 uA
                /// 11: 2.25*4 uA = 9 uA
                ADC1_IOPAAF: u2,
                /// ADC1 PGA gain settings:
                /// 0x0: 0 dB 0x10: 21 dB
                /// 0x1: 6 dB 0x11: 22 dB
                /// 0x2: 6 dB 0x12: 23 dB
                /// 0x3: 6 dB 0x13: 24 dB
                /// 0x4: 9 dB 0x14: 25 dB
                /// 0x5: 10 dB 0x15: 26 dB
                /// 0x6: 11 dB 0x16: 27 dB
                /// 0x7: 12 dB 0x17: 28 dB
                /// 0x8: 13 dB 0x18: 29 dB
                /// 0x9: 14 dB 0x19: 30 dB
                /// 0xA: 15 dB 0x1A: 31 dB
                /// 0xB: 16 dB 0x1B: 32 dB
                /// 0xC: 17 dB 0x1C: 33 dB
                /// 0xD: 18 dB 0x1D: 34 dB
                /// 0xE: 19 dB 0x1E: 35 dB
                /// 0xF: 20 dB 0x1F: 36 dB
                ADC1_PGA_GAIN_CTRL: u5,
                reserved0: u1,
                /// ADC1-ADC3 Bias Current Select
                /// 00: 1 uA
                /// 01: 2 uA
                /// 10: 3 uA
                /// 11: 4 uA
                IOPADC: u2,
                /// ADC1 PGA Common-Mode Voltage Control
                /// 00: 900 mV
                /// 01: 800 mV
                /// 10: 750 mV
                /// 11: 700 mV
                ADC1_PGA_IN_VCM_CTRL: u2,
                /// ADC1 PGA Common Mode Input Impedance Control for MICIN
                /// 00: 100 kΩ
                /// 01: 75 kΩ
                /// 10: 50 kΩ
                /// 11: 25 kΩ
                ADC1_PGA_CTRL_RCM: u2,
                /// PGA Vcm Buffer OP Bias Current Select
                /// 00: 6 uA
                /// 01: 7 uA
                /// 10: 8 uA
                /// 11: 9 uA
                IOPBUFFER: u2,
                /// LINEINL Gain Control
                /// 0: 0 dB
                /// 1: 6 dB
                LINEINLG: u1,
                /// LINEINL Enable
                /// 0: Disable
                /// 1: Enable
                LINEINLEN: u1,
                /// Dither Level Control (Dither level is positive ralated to the ctrl bits)
                /// 00: No Level
                /// 01: Min Level
                /// 10: Middle Level
                /// 11: Max Level
                DSM_DITHER_LVL: u2,
                /// FMINL Gain Control
                /// 0: 0 dB
                /// 1: 6 dB
                FMINLG: u1,
                /// FMINL Enable
                /// 0: Disable
                /// 1: Enable
                FMINLEN: u1,
                /// MIC1 Single Input Enable
                /// 0: Disable
                /// 1: Enable
                MIC1_SIN_EN: u1,
                /// Dither Control
                /// 0: New Dither Off
                /// 1: New Dither On
                ADC1: u1,
                /// MIC1 PGA Enable
                /// 0: Disabled
                /// 1: Enabled
                MIC1_PGA_EN: u1,
                /// ADC1 Channel Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC1_EN: u1,
            }), base_address + 0x300);

            /// address: 0x2030304
            /// ADC2 Analog Control Register
            pub const ADC2_REG = @intToPtr(*volatile Mmio(32, packed struct {
                /// ADC2 OP MIC Bias Current Select
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC2_IOPMIC: u2,
                /// ADC2 OP SDM Bias Current Select 2
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC2_IOPSDM2: u2,
                /// ADC2 OP SDM Bias Current Select 1
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC2_IOPSDM1: u2,
                /// ADC2 OP AAF Bias Current Select
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA.
                ADC2_IOPAAF: u2,
                /// ADC2 PGA Gain Settings
                /// 0x0: 0 dB 0x10: 21 dB
                /// 0x1: 6 dB 0x11: 22 dB
                /// 0x2: 6 dB 0x12: 23 dB
                /// 0x3: 6 dB 0x13: 24 dB
                /// 0x4: 9 dB 0x14: 25 dB
                /// 0x5: 10 dB 0x15: 26 dB
                /// 0x6: 11 dB 0x16: 27 dB
                /// 0x7: 12 dB 0x17: 28 dB
                /// 0x8: 13 dB 0x18: 29 dB
                /// 0x9: 14 dB 0x19: 30 dB
                /// 0xA: 15 dB 0x1A: 31 dB
                /// 0xB: 16 dB 0x1B: 32 dB
                /// 0xC: 17 dB 0x1C: 33 dB
                /// 0xD: 18 dB 0x1D: 34 dB
                /// 0xE: 19 dB 0x1E: 35 dB
                /// 0xF: 20 dB 0x1F: 36 dB
                ADC2_PGA_GAIN_CTRL: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// ADC2 PGA Common-Mode Voltage Control
                /// 00: 900 mV
                /// 01: 800 mV
                /// 10: 750 mV
                /// 11: 700 mV
                ADC2_PGA_IN_VCM_CTRL: u2,
                /// ADC2 PGA Common Mode Input Impedance Control for MICIN
                /// 00: 100 kΩ
                /// 01: 75 kΩ
                /// 10: 50 kΩ
                /// 11: 25 kΩ
                ADC2_PGA_CTRL_RCM: u2,
                /// PGA Vcm Buffer OP Bias Current Select
                /// 00: 6 uA
                /// 01: 7 uA
                /// 10: 8 uA
                /// 11: 9 uA
                IOPBUFFER: u2,
                /// LINEINR Gain Control
                /// 0: 0 dB
                /// 1: 6 dB
                LINEINRG: u1,
                /// LINEINR Enable
                /// 0: Disable
                /// 1: Enable
                LINEINREN: u1,
                /// Dither Level Control (Dither level is positive ralated to the ctrl bits)
                /// 00: No Level
                /// 01: Min Level
                /// 10: Middle Level
                /// 11: Max Level
                DSM_DITHER_LVL: u2,
                /// FMINR Gain Control
                /// 0: 0 dB
                /// 1: 6 dB
                FMINRG: u1,
                /// FMINR Enable
                /// 0: Disable
                /// 1: Enable
                FMINREN: u1,
                /// MIC2 Single Input Enable
                /// 0: Disable
                /// 1: Enable
                MIC2_SIN_EN: u1,
                /// Dither Control
                /// 0: New Dither Off
                /// 1: New Dither On
                ADC2: u1,
                /// MIC2 PGA Enable
                /// 0: Disabled
                /// 1: Enabled
                MIC2_PGA_EN: u1,
                /// ADC2 Channel Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC2_EN: u1,
            }), base_address + 0x304);

            /// address: 0x2030308
            /// ADC3 Analog Control Register
            pub const ADC3_REG = @intToPtr(*volatile Mmio(32, packed struct {
                /// ADC3 OP MIC Bias Current Select
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA
                ADC3_IOPMIC: u2,
                /// ADC3 OP SDM Bias Current Select 2
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA
                ADC3_IOPSDM2: u2,
                /// ADC3 OP SDM Bias Current Select 1
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA
                ADC3_IOPSDM1: u2,
                /// ADC3 OP AAF Bias Current Select
                /// 00: 1.50*IOPADC
                /// 01: 1.75*IOPADC
                /// 10: 2.00*IOPADC
                /// 11: 2.25*IOPADC IOPADC is defined by ADC1_REG<15:14> from 1 uA to 4 uA
                ADC3_IOPAAF: u2,
                /// ADC3 PGA Gain Settings
                /// 0x0: 0 dB 0x10: 21 dB
                /// 0x1: 6 dB 0x11: 22 dB
                /// 0x2: 6 dB 0x12: 23 dB
                /// 0x3: 6 dB 0x13: 24 dB
                /// 0x4: 9 dB 0x14: 25 dB
                /// 0x5: 10 dB 0x15: 26 dB
                /// 0x6: 11 dB 0x16: 27 dB
                /// 0x7: 12 dB 0x17: 28 dB
                /// 0x8: 13 dB 0x18: 29 dB
                /// 0x9: 14 dB 0x19: 30 dB
                /// 0xA: 15 dB 0x1A: 31 dB
                /// 0xB: 16 dB 0x1B: 32 dB
                /// 0xC: 17 dB 0x1C: 33 dB
                /// 0xD: 18 dB 0x1D: 34 dB
                /// 0xE: 19 dB 0x1E: 35 dB
                /// 0xF: 20 dB 0x1F: 36 dB
                ADC3_PGA_GAIN_CTRL: u5,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// ADC3 PGA Common-Mode Voltage Control
                /// 00: 900 mV
                /// 01: 800 mV
                /// 10: 750 mV
                /// 11: 700 mV
                ADC3_PGA_IN_VCM_CTRL: u2,
                /// ADC3 PGA Common Mode Input Impedance Control for MICIN
                /// 00: 100 kΩ
                /// 01: 75 kΩ
                /// 10: 50 kΩ
                /// 11: 25 kΩ
                ADC3_PGA_CTRL_RCM: u2,
                /// PGA Vcm Buffer OP Bias Current Select
                /// 00: 6 uA
                /// 01: 7 uA
                /// 10: 8 uA
                /// 11: 9 uA
                IOPBUFFER: u2,
                reserved3: u1,
                reserved4: u1,
                /// Dither Level Control (Dither level is positive ralated to the ctrl bits)
                /// 00: No Level
                /// 01: Min Level
                /// 10: Middle Level
                /// 11: Max Level
                DSM_DITHER_LVL: u2,
                reserved5: u1,
                reserved6: u1,
                /// MIC3 Single Input Enable
                /// 0: Disabled
                /// 1: Enabled
                MIC3_SIN_EN: u1,
                /// Dither Control
                /// 0: New Dither Off
                /// 1: New Dither On
                ADC3: u1,
                /// MIC3 PGA Enable
                /// 0: Disabled
                /// 1: Enabled
                MIC3_PGA_EN: u1,
                /// ADC3 Channel Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC3_EN: u1,
            }), base_address + 0x308);

            /// address: 0x2030320
            /// BIAS Analog Control Register
            pub const BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
                /// Bias Current Register Setting Data
                BIASDATA: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }), base_address + 0x320);

            /// address: 0x2030310
            /// DAC Analog Control Register
            pub const DAC_REG = @intToPtr(*volatile Mmio(32, packed struct {
                /// LINEOUT Volume Control. Total 30 level from 0x1F to 0x02 with the volume 0 dB to
                /// -43.5 dB, -1.5 dB/step, mute when 00000 & 00001.
                LINEOUT_VOL_CTRL: u5,
                /// Right Channel LINEOUT Output Control
                /// 0: Single-End
                /// 1: Differential
                LINEOUTR_DIFFEN: u1,
                /// Left Channel LINEOUT Output Control
                /// 0: Single-End
                /// 1: Differential
                LINEOUTL_DIFFEN: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// DACR to Right Channel LINEOUT Mute Control
                /// 0: Mute
                /// 1: Not mute
                RMUTE: u1,
                /// Right Channel LINEOUT Enable
                /// 0: Disable
                /// 1: Enable
                LINEOUTREN: u1,
                /// DACL to Left Channel LINEOUT Mute Control
                /// 0: Mute
                /// 1: Not mute
                LMUTE: u1,
                /// Left Channel LINEOUT Enable
                /// 0: Disable
                /// 1: Enable
                LINEOUTLEN: u1,
                /// DACR Enable
                /// 0: Disabled
                /// 1: Enabled
                DACR_EN: u1,
                /// DACL Enable
                /// 0: Disabled
                /// 1: Enabled
                DACL_EN: u1,
                /// OPDACL/R Bias Current Select
                /// 00: 6 uA
                /// 01: 7 uA
                /// 10: 8 uA
                /// 11: 9 uA
                IOPDACS: u2,
                /// LINEOUTLL/R AMP Bias Current Select
                /// 00: 6 uA
                /// 01: 7 uA
                /// 10: 8 uA
                /// 11: 9 uA
                ILINEOUTAMPS: u2,
                /// VRA2 Buffer OP and Headphone Feedback Buffer OP Bias Current Select
                /// 00: 6 uA
                /// 01: 7 uA
                /// 10: 8 uA
                /// 11: 9 uA
                IOPVRS: u2,
                reserved3: u1,
                /// Internal Current Sink Test Enable (from MICIN3P pin)
                /// 0: Normal
                /// 1: For Debug
                CURRENT_TEST_SELECT: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x310);

            /// address: 0x2030318
            /// MICBIAS Analog Control Register
            pub const MICBIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// MMIC BIAS Chopper Clock Select
                /// 00: 250 kHz
                /// 01: 500 kHz
                /// 10: 1 MHz
                /// 11: 2 MHz
                MMIC_BIAS_CHOPPER_CLK_SEL: u2,
                /// MMIC BIAS Chopper Enable
                /// 0: Disabled
                /// 1: Enabled
                MMIC_BIAS_CHOPPER_EN: u1,
                /// MMICBIAS Voltage Level Select
                /// 00: 1.88 V
                /// 01: 2.09 V
                /// 10: 2.33 V
                /// 11: 2.50 V
                MBIASSEL: u2,
                /// Master Microphone Bias Enable
                /// 0: Disabled
                /// 1: Enabled
                MMICBIASEN: u1,
                reserved2: u1,
                reserved3: u1,
                /// HMIC BIAS Chopper Clock Select
                /// 00: 250 kHz
                /// 01: 500 kHz
                /// 10: 1 MHz
                /// 11: 2 MHz
                HMIC_BIAS_CHOPPER_CLK_SEL: u2,
                /// HMIC BIAS Chopper Enable
                /// 0: Disabled
                /// 1: Enabled
                HMIC_BIAS_CHOPPER_EN: u1,
                /// HMICBIAS Voltage Level Select
                /// 00: 1.88 V
                /// 01: 2.09 V
                /// 10: 2.33 V
                /// 11: 2.55 V
                HBIASSEL: u2,
                /// Headphone Microphone Bias Enable
                /// 0: Disabled
                /// 1: Enabled
                HMICBIASEN: u1,
                /// When this bit is 1and AUTOPLEN is 0, the MICDET is pulled down to GND.
                MICDETPL: u1,
                /// Enable the function to auto pull low MICDET when jack removal
                /// 0: Disabled
                /// 1: Enabled
                AUTOPLEN: u1,
                /// MIC Detect Mode
                /// 0: Jack in pull low
                /// 1: Jack in pull high
                DET_MODE: u1,
                /// When this bit is 0, HBIAS MICADC is controlled by registor
                POPFREE: u1,
                /// Microphone detect ADC enable
                /// 0: Disabled
                /// 1: Enabled
                MICADCEN: u1,
                /// Select the delay time to pull low the micdet when jack removal
                /// 00: 0.5 ms
                /// 01: 1 ms
                /// 10: 1.5 ms
                /// 11: 2 ms
                SELDETADCDY: u2,
                /// Jack detect enable
                /// 0: Disable
                /// 1: Enable
                JACKDETEN: u1,
                /// Select the time to enable HBIAS before MICADC work
                /// 00: 2 ms
                /// 01: 4 ms
                /// 10: 8 ms
                /// 11: 16 ms
                SELDETADCBF: u2,
                /// Select debounce time when jack removal
                /// 00: 128 ms
                /// 01: 256 ms
                /// 10: 512 ms
                /// 11: 1024 ms
                SELDETADCDB: u2,
                /// Select sample interval of the ADC sample
                /// 000: 2 ms …
                /// 100: 32 ms …
                /// 111: 256 ms
                SELDETADCFS: u3,
                padding0: u1,
            }), base_address + 0x318);

            /// address: 0x203031c
            /// BIAS Analog Control Register
            pub const RAMP_REG = @intToPtr(*volatile Mmio(32, packed struct {
                /// Ramp Digital Enable
                /// 0: Disabled
                /// 1: Enabled
                RD_EN: u1,
                /// Ramp Manual Control Enable
                /// 0: Disabled
                /// 1: Enabled
                RMC_EN: u1,
                /// Ramp Manual Up Enable
                /// 0: Disabled
                /// 1: Enabled
                RMU_EN: u1,
                /// Ramp Manual Down Enable
                /// 0: Disabled
                /// 1: Enabled
                RMD_EN: u1,
                /// RK Frequency Gear, Control Ramp Rise/Fall Total Time
                /// 000: 20
                /// 001: 30
                /// 010: 40
                /// 011: 60
                /// 100: 80
                /// 101: 120
                /// 110: 160
                /// 111: 240 Ramp Rise/Fall Total Time =(Ramp Step/Ramp Clk Freq)*4096 When Default
                /// Ramp Clk Freq is equal to 960 kHz, the corresponding time of each gear is:
                /// 000: (20/960kHz)*4096=85.3 ms
                /// 001: (30/960kHz)*4096=128 ms
                /// 010: (40/960kHz)*4096=170.6 ms
                /// 011: (60/960kHz)*4096=256 ms
                /// 100: (80/960kHz)*4096=341.3 ms
                /// 101: (120/960kHz)*4096=512 ms
                /// 110: (160/960kHz)*4096=682.6 ms
                /// 111: (240/960kHz)*4096=1024 ms
                RAMP_STEP: u3,
                reserved0: u1,
                /// Gap Step
                /// 00: ramp step
                /// 01: ramp step*2
                /// 10: ramp step*3
                /// 11: ramp step*4
                GAP_STEP: u2,
                reserved1: u1,
                reserved2: u1,
                /// RAMP HOLD STEP
                /// 000: 9600
                /// 001: 19200
                /// 010: 38400
                /// 011: 76800
                /// 100: 96000
                /// 101: 115200
                /// 110: 153600
                /// 111: 192000 Ramp Hold Time = Ramp Hold Step/Ramp Clk Freq When Ramp Clk Freq is
                /// equal to 960 kHz, the corresponding Ramp Hold time of each gear is:
                /// 000: 9600/960 kHz=10 ms
                /// 001: 19200/960 kHz=20 ms
                /// 010: 38400/960 kHz=40 ms
                /// 011: 76800/960 kHz=80 ms
                /// 100: 96000/960 kHz=100 ms
                /// 101: 115200/960 kHz=120 ms
                /// 110: 153600/960 kHz=160 ms
                /// 111: 192000/960 kHz=200 ms
                RAMP_HOLD_STEP: u3,
                /// Heanphone Pullout Enable
                /// 0: Disabled
                /// 1: Enabled
                HP_PULL_OUT_EN: u1,
                /// Analog Ramp Clk Div Freq Value : M (from 0 to 31, Default: 24). Ana_Ramp_Clk=
                /// 24MHz/(M+1) Default Ramp Clk Freq: 24MHz/(24+1)=960 kHz
                RAMP_CLK_DIV_M: u5,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// Ramp Soft Reset
                /// 0: Disabled
                /// 1: Enabled
                RAMP_SRST: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// RK Downward Decrease Finish and Rampen Pull Down Instruction
                /// 0: No Pending IRQ
                /// 1: Ramp Fall Finish Pending Interrupt Write ‘1’ to clear this interrupt.
                RAMP_FALL_INT: u1,
                /// RAMP Fall Int Enable
                /// 0: Enabled
                /// 1: Disabled
                RAMP_FALL_INT_EN: u1,
                /// RK Increase Upward Finish and Rampen Pull Down Instruction
                /// 0: No Pending IRQ
                /// 1: Ramp Rise Finish Pending Interrupt Write ‘1’ to clear this interrupt.
                RAMP_RISE_INT: u1,
                /// RAMP Rise Interrupt Enable
                /// 0: Enabled
                /// 1: Disabled
                RAMP_RISE_INT_EN: u1,
            }), base_address + 0x31c);
        };

        pub const @"AUDIO CODEC" = struct {

            /// address: 0x2030044
            /// ADC RX Counter Register
            pub const AC_ADC_CNT = @intToPtr(*volatile Mmio(32, packed struct {
                /// RX Sample Counter The audio sample number of writing into RXFIFO. When one
                /// sample is written by Digital Audio Engine, the RX sample counter register
                /// increases by one. The RX sample counter register can be set to any initial valve
                /// at any time. After being updated by the initial value, the counter register
                /// should count from this initial value.
                RX_CNT: u32,
            }), base_address + 0x44);

            /// address: 0x20300f8
            /// ADC DAP Control Register
            pub const AC_ADC_DAP_CTR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                /// ADC HPF1 enable control
                /// 0: Disabled
                /// 1: Enabled
                ADC_HPF1_EN: u1,
                /// ADC DRC1 enable control
                /// 0: Disabled
                /// 1: Enabled
                ADC_DRC1_EN: u1,
                reserved24: u1,
                /// (control the DAP of ADC3) ADC DAP1 enable control
                ADC_DAP1_EN: u1,
                /// ADC HPF0 enable control
                /// 0: Disabled
                /// 1: Enabled
                ADC_HPF0_EN: u1,
                /// ADC DRC0 enable control
                /// 0: Disabled
                /// 1: Enabled
                ADC_DRC0_EN: u1,
                reserved25: u1,
                /// (control the DAP of ADC1/2) DAP for ADC enable
                /// 0: Bypassed
                /// 1: Enabled
                ADC_DAP0_EN: u1,
            }), base_address + 0xf8);

            /// address: 0x2030208
            /// ADC DRC Control Register
            pub const AC_ADC_DRC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// DRC ET enable
                /// 0: Disabled
                /// 1: Enabled When the bit is disabled, Ke and OPE parameter is unused.
                ADC_DRC_ET_EN: u1,
                /// DRC LT enable
                /// 0: Disabled
                /// 1: Enabled When the bit is disabled, Kl and OPL parameter is unused.
                ADC_DRC_LT_EN: u1,
                /// Delay function enable
                /// 0: Disabled
                /// 1: Enabled When the bit is disabled, the signal delay time is unused.
                ADC_DRC_DELAY_FUNC_EN: u1,
                /// Signal function select
                /// 0: RMS filter
                /// 1: Peak filter When the signal function selects the Peak filter, the RMS
                /// parameter is unused. (AC_DRC_LRMSHAT, AC_DRC_LRMSLAT, AC_DRC_LRMSHAT, and
                /// AC_DRC_LRMSLAT) When the signal function selects the RMS filter, the Peak filter
                /// parameter is unused. (AC_DRC_LPFHAT, AC_DRC_LPFLAT, AC_DRC_RPFHAT,
                /// AC_DRC_RPFLAT, AC_DRC_LPFHRT, AC_DRC_LPFLRT, AC_DRC_RPFHRT, and AC_DRC_RPFLRT)
                ADC_DRC_SIGNAL_FUNC_SEL: u1,
                /// Control the DRC to detect noise when ET is enabled
                /// 0: Disabled
                /// 1: Enabled
                ADC_DRC_DETECT_NOISE_EN: u1,
                /// DRC gain min limit enable When this fuction is enabled, it will overwrite the
                /// noise detect function.
                /// 0: Disabled
                /// 1: Enabled
                ADC_DRC_GAIN_MIN_LIMIT_EN: u1,
                /// DRC gain max limit enable
                /// 0: Disabled
                /// 1: Enabled
                ADC_DRC_GAIN_MAX_LIMIT_EN: u1,
                /// The delay buffer use or not when the DRC is disabled and the DRC buffer data
                /// output completely.
                /// 0: Do not use the buffer
                /// 1: Use the buffer
                ADC_DRC_DELAY_BUF_EN: u1,
                /// Signal delay time setting 6'h00: (8x1) fs 6'h01: (8x2) fs 6'h02: (8x3) fs
                /// ---------------------------------------- 6'h2e: (8*47) fs 6'h2f: (8*48) fs 6'h30
                /// -- 6'h3f: (8*48) fs Delay time = 8*(n + 1) fs, n < 6'h30; When the delay
                /// function is disabled, the signal delay time is unused.
                ADC_DRC_SIGNAL_DELAY_TIME_SET: u6,
                reserved0: u1,
                /// DRC delay buffer data output state when The DRC delay function is enabled and
                /// the DRC function is disabled. After disabled DRC function and this bit goes to
                /// 0, the user should write the DRC delay function bit to 0.
                /// 0: Not completed
                /// 1: Completed
                ADC_DRC_DELAY_BUF_OUTPUT_STATE: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x208);

            /// address: 0x20302ac
            /// ADC DRC Expander Smooth Time High Coef Register
            pub const AC_ADC_DRC_EPSHC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release and attack time parameter setting in expander
                /// region, which is determined by the equation that RT = 1-exp (-2.2Ts/tr). The
                /// format is 3.24. (The default value is 30 ms)
                ADC_DRC_EPSHC: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x2ac);

            /// address: 0x20302b0
            /// ADC DRC Expander Smooth Time Low Coef Register
            pub const AC_ADC_DRC_EPSLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release and attack time parameter setting in expander
                /// region, which is determined by the equation that RT = 1-exp (-2.2Ts/tr). The
                /// format is 3.24. (The default value is 30 ms)
                ADC_DRC_EPSLC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x2b0);

            /// address: 0x203023c
            /// ADC DRC Compressor Threshold High Setting Register
            pub const AC_ADC_DRC_HCT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The compressor threshold setting, which is set by the equation that CTin =
                /// -CT/6.0206. The format is 8.24. (The default value is - 40 dB)
                ADC_DRC_HCT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x23c);

            /// address: 0x203026c
            /// ADC DRC Expander Threshold High Setting Register
            pub const AC_ADC_DRC_HET = @intToPtr(*volatile Mmio(32, packed struct {
                /// The expander threshold setting, which is set by the equation that ETin =
                /// -ET/6.0206, The format is 8.24. (The default value is -70 dB)
                ADC_DRC_HET: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x26c);

            /// address: 0x2030200
            /// ADC DRC High HPF Coef Register
            pub const AC_ADC_DRC_HHPFC = @intToPtr(*volatile Mmio(32, packed struct {
                /// HPF coefficient setting and the data is 3.24 format.
                ADC_DRC_HHPFC: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x200);

            /// address: 0x2030244
            /// ADC DRC Compressor Slope High Setting Register
            pub const AC_ADC_DRC_HKC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the compressor which is determined by the equation that Kc = 1/R. R
                /// is the ratio of the compressor, which is always an integer. The format is 8.24.
                /// (The default value is <2:1>)
                ADC_DRC_HKC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x244);

            /// address: 0x2030274
            /// ADC DRC Expander Slope High Setting Register
            pub const AC_ADC_DRC_HKE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the expander, which is determined by the equation that Ke = 1/R. R
                /// is the ratio of the expander, which is always an integer and the ke must larger
                /// than 50. The format is 8.24. (The default value is <1:5>)
                ADC_DRC_HKE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x274);

            /// address: 0x2030284
            /// ADC DRC Linear Slope High Setting Register
            pub const AC_ADC_DRC_HKN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the linear, which is determined by the equation that Kn = 1/R. R is
                /// the ratio of the linear, which is always an integer. The format is 8.24. (The
                /// default value is <1:1>)
                ADC_DRC_HKN: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x284);

            /// address: 0x203025c
            /// ADC DRC Limiter Slope High Setting Register
            pub const AC_ADC_DRC_HKl = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the limiter, which is determined by the equation that Kl = 1/R. R
                /// is the ratio of the limiter, which is always an integer. The format is 8.24.
                /// (The default value is <50:1>)
                ADC_DRC_HKL: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x25c);

            /// address: 0x2030254
            /// ADC DRC Limiter Threshold High Setting Register
            pub const AC_ADC_DRC_HLT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The limiter threshold setting, which is set by the equation that LTin =
                /// -LT/6.0206. The format is 8.24. (The default value is -10 dB)
                ADC_DRC_HLT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x254);

            /// address: 0x203024c
            /// ADC DRC Compressor High Output at Compressor Threshold Register
            pub const AC_ADC_DRC_HOPC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the compressor, which is determined by the equation -OPC/6.0206.
                /// The format is 8.24. (The default value is -40 dB)
                ADC_DRC_HOPC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x24c);

            /// address: 0x203027c
            /// ADC DRC Expander High Output at Expander Threshold
            pub const AC_ADC_DRC_HOPE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the expander, which is determined by equation OPE/6.0206. The
                /// format is 8.24. (The default value is -70 dB)
                ADC_DRC_HOPE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x27c);

            /// address: 0x2030264
            /// ADC DRC Limiter High Output at Limiter Threshold
            pub const AC_ADC_DRC_HOPL = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the limiter, which is determined by equation OPT/6.0206. The
                /// format is 8.24. (The default value is -25 dB)
                ADC_DRC_HOPL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x264);

            /// address: 0x20302b8
            /// ADC DRC HPF Gain High Coef Register
            pub const AC_ADC_DRC_HPFHGAIN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain of HPF coefficient setting, which format is 3.24. (gain = 1)
                ADC_DRC_HPFHGAIN: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x2b8);

            /// address: 0x20302bc
            /// ADC DRC HPF Gain Low Coef Register
            pub const AC_ADC_DRC_HPFLGAIN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain of HPF coefficient setting, which format is 3.24. (gain = 1)
                ADC_DRC_HPFLGAIN: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x2bc);

            /// address: 0x2030240
            /// ADC DRC Compressor Slope High Setting Register
            pub const AC_ADC_DRC_LCT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The compressor threshold setting, which is set by the equation that CTin =
                /// -CT/6.0206. The format is 8.24. (The default value is - 40 dB)
                ADC_DRC_LCT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x240);

            /// address: 0x2030270
            /// ADC DRC Expander Threshold Low Setting Register
            pub const AC_ADC_DRC_LET = @intToPtr(*volatile Mmio(32, packed struct {
                /// The expander threshold setting, which is set by the equation that ETin =
                /// -ET/6.0206, The format is 8.24. (The default value is -70 dB)
                ADC_DRC_LET: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x270);

            /// address: 0x2030204
            /// ADC DRC Low HPF Coef Register
            pub const AC_ADC_DRC_LHPFC = @intToPtr(*volatile Mmio(32, packed struct {
                /// coefficient setting and the data is 3.24 format.
                HPF: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x204);

            /// address: 0x2030248
            /// ADC DRC Compressor Slope Low Setting Register
            pub const AC_ADC_DRC_LKC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the compressor, which is determined by the equation that Kc = 1/R.
                /// R is the ratio of the compressor, which is always an integer. The format is
                /// 8.24. (The default value is <2:1>)
                ADC_DRC_LKC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x248);

            /// address: 0x2030278
            /// ADC DRC Expander Slope Low Setting Register
            pub const AC_ADC_DRC_LKE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the expander, which is determined by the equation that Ke = 1/R. R
                /// is the ratio of the expander, which is always an integer and the ke must be
                /// larger than 50. The format is 8.24. (The default value is <1:5>)
                ADC_DRC_LKE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x278);

            /// address: 0x2030288
            /// ADC DRC Linear Slope Low Setting Register
            pub const AC_ADC_DRC_LKN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the linear, which is determined by the equation that Kn = 1/R. R is
                /// the ratio of the linear, which is always an integer. The format is 8.24. (The
                /// default value is <1:1>)
                ADC_DRC_LKN: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x288);

            /// address: 0x2030260
            /// ADC DRC Limiter Slope Low Setting Register
            pub const AC_ADC_DRC_LKl = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the limiter, which is determined by the equation that Kl = 1/R. R
                /// is the ratio of the limiter, which is always an integer. The format is 8.24.
                /// (The default value is <50:1>)
                ADC_DRC_LKL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x260);

            /// address: 0x2030258
            /// ADC DRC Limiter Threshold Low Setting Register
            pub const AC_ADC_DRC_LLT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The limiter threshold setting, which is set by the equation that LTin =
                /// -LT/6.0206. The format is 8.24. (The default value is -10 dB)
                ADC_DRC_LLT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x258);

            /// address: 0x2030250
            /// ADC DRC Compressor Low Output at Compressor Threshold Register
            pub const AC_ADC_DRC_LOPC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the compressor, which is determined by the equation OPC/6.0206.
                /// The format is 8.24. (The default value is -40 dB)
                ADC_DRC_LOPC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x250);

            /// address: 0x2030280
            /// ADC DRC Expander Low Output at Expander Threshold
            pub const AC_ADC_DRC_LOPE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the expander, which is determined by equation OPE/6.0206. The
                /// format is 8.24. (The default value is -70 dB)
                ADC_DRC_LOPE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x280);

            /// address: 0x2030268
            /// ADC DRC Limiter Low Output at Limiter Threshold
            pub const AC_ADC_DRC_LOPL = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the limiter which is determined by equation OPT/6.0206. The format
                /// is 8.24. (The default value is -25 dB)
                ADC_DRC_LOPL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x268);

            /// address: 0x203020c
            /// ADC DRC Left Peak Filter High Attack Time Coef Register
            pub const AC_ADC_DRC_LPFHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                ADC_DRC_LPFHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x20c);

            /// address: 0x203021c
            /// ADC DRC Left Peak Filter High Release Time Coef Register
            pub const AC_ADC_DRC_LPFHRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                ADC_DRC_LPFHRT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x21c);

            /// address: 0x2030210
            /// ADC DRC Left Peak Filter Low Attack Time Coef Register
            pub const AC_ADC_DRC_LPFLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                ADC_DRC_LPFLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x210);

            /// address: 0x2030220
            /// ADC DRC Left Peak Filter Low Release Time Coef Register
            pub const AC_ADC_DRC_LPFLRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                ADC_DRC_LPFLRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x220);

            /// address: 0x203022c
            /// ADC DRC Left RMS Filter High Coef Register
            pub const AC_ADC_DRC_LRMSHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                ADC_DRC_LRMSHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x22c);

            /// address: 0x2030230
            /// ADC DRC Left RMS Filter Low Coef Register
            pub const AC_ADC_DRC_LRMSLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                ADC_DRC_LRMSLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x230);

            /// address: 0x20302a8
            /// ADC DRC MIN Gain High Setting Register
            pub const AC_ADC_DRC_MNGLS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The min gain setting, which is determined by equation MXG =MNG/6.0206. The
                /// format is 8.24 and must -60 dB ≤ MNG ≤ -40 dB (The default value is -40 dB)
                ADC_DRC_MNGLS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x2a8);

            /// address: 0x203029c
            /// ADC DRC MAX Gain High Setting Register
            pub const AC_ADC_DRC_MXGHS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The max gain setting, which is determined by equation MXG =MXG/6.0206. The
                /// format is 8.24 and must -20 dB < MXG < 30 dB (The default value is -10 dB)
                ADC_DRC_MXGHS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x29c);

            /// address: 0x20302a0
            /// ADC DRC MIN Gain Low Setting Register
            pub const AC_ADC_DRC_MXGLS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The max gain setting, which is determined by equation MXG =MXG/6.0206. The
                /// format is 8.24 and must -20 dB < MXG < 30 dB (The default value is -10 dB)
                ADC_DRC_MXGLS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x2a0);

            /// address: 0x2030214
            /// ADC DRC Right Peak Filter High Attack Time Coef Register
            pub const AC_ADC_DRC_RPFHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                ADC_DRC_RPFHAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x214);

            /// address: 0x2030224
            /// ADC DRC Right Peak Filter High Release Time Coef Register
            pub const AC_ADC_DRC_RPFHRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                ADC_DRC_RPFHRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x224);

            /// address: 0x2030218
            /// ADC DRC Right Peak Filter Low Attack Time Coef Register
            pub const AC_ADC_DRC_RPFLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                ADC_DRC_RPFLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x218);

            /// address: 0x2030228
            /// ADC DRC Right Peak Filter Low Release Time Coef Register
            pub const AC_ADC_DRC_RPFLRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                ADC_DRC_RPFLRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x228);

            /// address: 0x2030234
            /// ADC DRC Right RMS Filter High Coef Register
            pub const AC_ADC_DRC_RRMSHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                ADC_DRC_RRMSHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x234);

            /// address: 0x2030238
            /// ADC DRC Right RMS Filter Low Coef Register
            pub const AC_ADC_DRC_RRMSLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                ADC_DRC_RRMSLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x238);

            /// address: 0x203028c
            /// ADC DRC Smooth filter Gain High Attack Time Coef Register
            pub const AC_ADC_DRC_SFHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The smooth filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 5 ms)
                ADC_DRC_SFHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x28c);

            /// address: 0x2030294
            /// ADC DRC Smooth filter Gain High Release Time Coef Register
            pub const AC_ADC_DRC_SFHRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release time parameter setting, which is determined by
                /// the equation that RT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value
                /// is 200 ms)
                ADC_DRC_SFHRT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x294);

            /// address: 0x2030290
            /// ADC DRC Smooth filter Gain Low Attack Time Coef Register
            pub const AC_ADC_DRC_SFLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The smooth filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 5 ms)
                ADC_DRC_SFLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x290);

            /// address: 0x2030298
            /// ADC DRC Smooth filter Gain Low Release Time Coef Register
            pub const AC_ADC_DRC_SFLRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release time parameter setting, which is determined by
                /// the equation that RT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value
                /// is 200 ms)
                ADC_DRC_SFLRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x298);

            /// address: 0x2030030
            /// ADC FIFO Control Register
            pub const AC_ADC_FIFOC = @intToPtr(*volatile Mmio(32, packed struct {
                /// ADC FIFO Flush Write ‘1’ to flush TX FIFO, self clear to ‘0’.
                ADC_FIFO_FLUSH: u1,
                /// ADC FIFO Overrun IRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC_OVERRUN_IRQ_EN: u1,
                /// ADC FIFO Data Available IRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC_IRQ_EN: u1,
                /// ADC FIFO Data Available DRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC_DRQ_EN: u1,
                /// RX FIFO Trigger Level (RXTL[5:0]) Interrupt and DMA request trigger level for RX
                /// FIFO normal condition IRQ/DRQ generated when WLEVEL > RXTL[5:0]
                RX_FIFO_TRG_LEVEL: u8,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Receiving Audio Sample Resolution
                /// 0: 16 bits
                /// 1: 20 bits
                RX_SAMPLE_BITS: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                /// Audiocodec RX Synchronize Enable
                /// 0: Disabled
                /// 1: Enabled
                RX_SYNC_EN: u1,
                /// The bit takes effect only when RX_SYNC_EN is set to 1. System Domain: Audio
                /// codec/I2S0/I2S1/I2S2/DMIC/OWA RX Synchronize Enable Start.
                /// 0: Disabled
                /// 1: Enabled
                RX_SYNC_EN_START: u1,
                reserved7: u1,
                reserved8: u1,
                /// RX FIFO Output Mode (Mode 0, 1)
                /// 0: Expanding ‘0’ at LSB of TX FIFO register
                /// 1: Expanding received sample sign bit at MSB of TX FIFO register For 20-bit
                /// received audio sample: Mode 0: RXDATA[31:0] = {FIFO_O[19:0], 12’h0} Mode 1:
                /// RXDATA[31:0] = {12{FIFO_O[19]}, FIFO_O[19:0]} For 16-bit received audio sample:
                /// Mode 0: RXDATA[31:0] = {FIFO_O[19:4], 16’h0} Mode 1: RXDATA[31:0] =
                /// {16{FIFO_O[19]}, FIFO_O[19:4]}
                RX_FIFO_MODE: u1,
                /// ADC FIFO delay function for writing data after EN_AD
                /// 0: Disabled
                /// 1: Enabled
                ADCDFEN: u1,
                /// ADC FIFO delay time for writing data after EN_AD
                /// 00: 5 ms
                /// 01: 10 ms
                /// 10: 20 ms
                /// 11: 30 ms
                ADCFDT: u2,
                /// ADC Digital Part Enable
                /// 0: Disabled
                /// 1: Enabled
                EN_AD: u1,
                /// Sample Rate of ADC
                /// 000: 48 kHz
                /// 010: 24 kHz
                /// 100: 12 kHz
                /// 110: Reserved
                /// 001: 32 kHz
                /// 011: 16 kHz
                /// 101: 8 kHz
                /// 111: Reserved 44.1 kHz/22.05 kHz/11.025 kHz can be supported by Audio PLL
                /// Configure Bit.
                ADFS: u3,
            }), base_address + 0x30);

            /// address: 0x2030038
            /// ADC FIFO Status Register
            pub const AC_ADC_FIFOS = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                /// RX FIFO Overrun Pending Interrupt
                /// 0: No Pending IRQ
                /// 1: FIFO Overrun Pending IRQ Write ‘1’ to clear this interrupt.
                RXO_INT: u1,
                reserved1: u1,
                /// RX FIFO Data Available Pending Interrupt
                /// 0: No Pending IRQ
                /// 1: Data Available Pending IRQ Write ‘1’ to clear this interrupt or automatic
                /// clear if the interrupt condition fails.
                RXA_INT: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                /// RX FIFO Available Sample Word Counter
                RXA_CNT: u9,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                /// RX FIFO Available
                /// 0: No available data in RX FIFO
                /// 1: More than one sample in RX FIFO (>= 1 word)
                RXA: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x38);

            /// address: 0x2030040
            /// ADC RX Data Register
            pub const AC_ADC_RXDATA = @intToPtr(*volatile Mmio(32, packed struct {
                /// RX Sample The host can get one sample by reading this register. The left channel
                /// sample data comes first and then the right channel sample.
                RX_DATA: u32,
            }), base_address + 0x40);

            /// address: 0x2030024
            /// DAC TX FIFO Counter Register
            pub const AC_DAC_CNT = @intToPtr(*volatile Mmio(32, packed struct {
                /// TX Sample Counter The audio sample number of sending into TXFIFO. When one
                /// sample is put into TXFIFO by DMA or by host IO, the TX sample counter register
                /// increases by one. The TX sample counter register can be set to any initial valve
                /// at any time. After being updated by the initial value, the counter register
                /// should count from this initial value.
                TX_CNT: u32,
            }), base_address + 0x24);

            /// address: 0x2030028
            /// DAC Debug Register
            pub const AC_DAC_DG = @intToPtr(*volatile Mmio(32, packed struct {
                /// ADDA Loop Mode Select
                /// 000: Disabled
                /// 001: ADDA LOOP MODE DACL/DACR is connected to ADC1/ADC2
                /// 010: ADDA LOOP MODE DACL/DACR is connected to ADC3 Others: Reserved
                ADDA_LOOP_MODE: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                /// DAC Output Channel Swap Enable
                /// 0: Disabled
                /// 1: Enabled
                DA_SWP: u1,
                reserved3: u1,
                /// CODEC Clock Source Select
                /// 0: CODEC clock from PLL
                /// 1: CODEC clock from OSC (for Debug)
                CODEC_CLK_SELECT: u1,
                /// DAC Pattern Select
                /// 00: Normal (Audio sample from TX FIFO)
                /// 01: -6 dB Sin wave
                /// 10: -60 dB Sin wave
                /// 11: Silent wave
                DAC_PATTERN_SELECT: u2,
                /// DAC Modulator Debug
                /// 0: DAC Modulator Normal Mode
                /// 1: DAC Modulator Debug Mode
                DAC_MODU_SELECT: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
            }), base_address + 0x28);

            /// address: 0x2030000
            /// DAC Digital Part Control Register
            pub const AC_DAC_DPC = @intToPtr(*volatile Mmio(32, packed struct {
                /// Audio Hub Enable The bit takes effect only when the EN_DA is set to 1. System
                /// Domain: Audio Codec/I2S0/I2S1/I2S2/OWA TXFIFO Hub Enable.
                /// 0: Disabled
                /// 1: Enabled
                HUB_EN: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                /// Digital volume control: DVC, ATT = DVC[5:0]*(-1.16 dB) 64 steps, -1.16 dB/step
                DVOL: u6,
                /// High Pass Filter Enable
                /// 0: Disabled
                /// 1: Enabled
                HPF_EN: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                /// DWA Function Disable
                /// 0: Enabled
                /// 1: Disabled
                DWA: u1,
                /// Internal DAC Quantization Levels Levels = [7*(21 + MODQU[3:0])]/128 Default
                /// levels = 7*21/128 = 1.15
                MODQU: u4,
                reserved16: u1,
                reserved17: u1,
                /// DAC Digital Part Enable
                /// 0: Disabled
                /// 1: Enabled
                EN_DA: u1,
            }), base_address + 0x0);

            /// address: 0x2030108
            /// DAC DRC Control Register
            pub const AC_DAC_DRC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// DRC ET enable
                /// 0: Disabled
                /// 1: Enabled When the bit is disabled, Ke and OPE parameter is unused.
                DAC_DRC_ET_EN: u1,
                /// DRC LT enable
                /// 0: Disabled
                /// 1: Enabled When the bit is disabled, Kl and OPL parameter is unused.
                DAC_DRC_LT_EN: u1,
                /// Delay function enable
                /// 0: Disabled
                /// 1: Enabled When the bit is disabled, the signal delay time is unused.
                DAC_DRC_DELAY_FUNC_EN: u1,
                /// Signal function select
                /// 0: RMS filter
                /// 1: Peak filter When the signal function selects the Peak filter, the RMS
                /// parameter is unused. (AC_DRC_LRMSHAT, AC_DRC_LRMSLAT, AC_DRC_LRMSHAT,
                /// AC_DRC_LRMSLAT) When the signal function selects the RMS filter, the Peak filter
                /// parameter is unused. (AC_DRC_LPFHAT, AC_DRC_LPFLAT, AC_DRC_RPFHAT,
                /// AC_DRC_RPFLAT, AC_DRC_LPFHRT, AC_DRC_LPFLRT, AC_DRC_RPFHRT, and AC_DRC_RPFLRT)
                DAC_DRC_SIGNAL_FUNC_SEL: u1,
                /// Control the DRC to detect noise when ET is enabled.
                /// 0: Disabled
                /// 1: Enabled
                DAC_DRC_DETECT_NOISE_EN: u1,
                /// DRC gain min limit enable When this function is enabled, it will overwrite the
                /// noise detect function.
                /// 0: Disabled
                /// 1: Enabled
                DAC_DRC_GAIN_MIN_LIMIT_EN: u1,
                /// DRC gain max limit enable
                /// 0: Disabled
                /// 1: Enabled
                DAC_DRC_GAIN_MAX_LIMIT_EN: u1,
                /// The delay buffer use or not when the DRC is disabled and the DRC buffer data
                /// output completely.
                /// 0: Do not use the buffer.
                /// 1: Use the buffer.
                DAC_DRC_DELAY_BUF_EN: u1,
                /// Signal delay time setting 6'h00: (8x1) fs 6'h01: (8x2) fs 6'h02: (8x3) fs
                /// ---------------------------------------- 6'h2e: (8*47) fs 6'h2f: (8*48) fs 6'h30
                /// -- 6'h3f: (8*48) fs Delay time = 8*(n + 1) fs, n<6'h30; When the delay function
                /// is disabled, the signal delay time is unused.
                SIGNAL: u6,
                reserved0: u1,
                /// delay buffer data output state when The DRC delay function is enabled and the
                /// DRC function is disabled. After disabling the DRC function and this bit goes to
                /// 0, write the DRC delay function bit to 0.
                /// 0: Not completed
                /// 1: Completed
                DRC: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x108);

            /// address: 0x20301ac
            /// DAC DRC Expander Smooth Time High Coef Register
            pub const AC_DAC_DRC_EPSHC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release and attack time parameter setting in expander
                /// region, which are determined by the equation that RT = 1-exp (-2.2Ts/tr). The
                /// format is 3.24. (The default value is 30 ms)
                DAC_DRC_EPSHC: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x1ac);

            /// address: 0x20301b0
            /// DAC DRC Expander Smooth Time Low Coef Register
            pub const AC_DAC_DRC_EPSLC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release and attack time parameter setting in expander
                /// region, which are determined by the equation that RT = 1-exp (-2.2Ts/tr). The
                /// format is 3.24. (The default value is 30 ms)
                DAC_DRC_EPSLC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x1b0);

            /// address: 0x203013c
            /// DAC DRC Compressor Threshold High Setting Register
            pub const AC_DAC_DRC_HCT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The compressor threshold setting, which is set by the equation that CTin =
                /// -CT/6.0206. The format is 8.24. (The default value is - 40 dB)
                DAC_DRC_HCT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x13c);

            /// address: 0x203016c
            /// DAC DRC Expander Threshold High Setting Register
            pub const AC_DAC_DRC_HET = @intToPtr(*volatile Mmio(32, packed struct {
                /// The expander threshold setting, which is set by the equation that ETin =
                /// -ET/6.0206. The format is 8.24. (The default value is -70 dB)
                DAC_DRC_HET: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x16c);

            /// address: 0x2030100
            /// DAC DRC High HPF Coef Register
            pub const AC_DAC_DRC_HHPFC = @intToPtr(*volatile Mmio(32, packed struct {
                /// coefficient setting and the data is 3.24 format.
                HPF: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x100);

            /// address: 0x2030144
            /// DAC DRC Compressor Slope High Setting Register
            pub const AC_DAC_DRC_HKC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the compressor, which is determined by the equation that Kc = 1/R.
                /// R is the ratio of the compressor, which is always an integer. The format is
                /// 8.24. (The default value is 2:1)
                DAC_DRC_HKC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x144);

            /// address: 0x2030174
            /// DAC DRC Expander Slope High Setting Register
            pub const AC_DAC_DRC_HKE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the expander, which is determined by the equation that Ke = 1/R. R
                /// is the ratio of the expander, which is always an integer and the ke must larger
                /// than 50. The format is 8.24. (The default value is <1:5>)
                DAC_DRC_HKE: u14,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
            }), base_address + 0x174);

            /// address: 0x2030184
            /// DAC DRC Linear Slope High Setting Register
            pub const AC_DAC_DRC_HKN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the linear, which is determined by the equation that Kn = 1/R. R is
                /// the ratio of the linear, which is always an integer. The format is 8.24. (The
                /// default value is <1:1>)
                DAC_DRC_HKN: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x184);

            /// address: 0x203015c
            /// DAC DRC Limiter Slope High Setting Register
            pub const AC_DAC_DRC_HKl = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the limiter which is determined by the equation that Kl = 1/R. R is
                /// the ratio of the limiter, which is always an integer. The format is 8.24. (The
                /// default value is <50:1>)
                DAC_DRC_HKL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x15c);

            /// address: 0x2030154
            /// DAC DRC Limiter Threshold High Setting Register
            pub const AC_DAC_DRC_HLT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The limiter threshold setting, which is set by the equation that LTin =
                /// -LT/6.0206, The format is 8.24. (The default value is -10 dB)
                DAC_DRC_HLT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x154);

            /// address: 0x203014c
            /// DAC DRC Compressor High Output at Compressor Threshold Register
            pub const AC_DAC_DRC_HOPC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the compressor, which is determined by the equation -OPC/6.0206.
                /// The format is 8.24 (The default value is -40 dB)
                DAC_DRC_HOPC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x14c);

            /// address: 0x203017c
            /// DAC DRC Expander High Output at Expander Threshold
            pub const AC_DAC_DRC_HOPE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the expander, which is determined by equation OPE/6.0206. The
                /// format is 8.24. (The default value is -70 dB)
                DAC_DRC_HOPE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x17c);

            /// address: 0x2030164
            /// DAC DRC Limiter High Output at Limiter Threshold
            pub const AC_DAC_DRC_HOPL = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the limiter, which is determined by equation OPT/6.0206. The
                /// format is 8.24. (The default value is -25 dB)
                DAC_DRC_HOPL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x164);

            /// address: 0x20301b8
            /// DAC DRC HPF Gain High Coef Register
            pub const AC_DAC_DRC_HPFHGAIN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain of HPF coefficient. The format is 3.24. (gain = 1)
                DAC_DRC_HPFHGAIN: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x1b8);

            /// address: 0x20301bc
            /// DAC DRC HPF Gain Low Coef Register
            pub const AC_DAC_DRC_HPFLGAIN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain of HPF coefficient. The format is 3.24. (gain = 1)
                DAC_DRC_HPFLGAIN: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x1bc);

            /// address: 0x2030140
            /// DAC DRC Compressor Slope High Setting Register
            pub const AC_DAC_DRC_LCT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The compressor threshold setting, which is set by the equation that CTin =
                /// -CT/6.0206. The format is 8.24. (The default value is - 40 dB)
                DAC_DRC_LCT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x140);

            /// address: 0x2030170
            /// DAC DRC Expander Threshold Low Setting Register
            pub const AC_DAC_DRC_LET = @intToPtr(*volatile Mmio(32, packed struct {
                /// The expander threshold setting, which is set by the equation that ETin =
                /// -ET/6.0206. The format is 8.24. (The default value is -70 dB)
                DAC_DRC_LET: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x170);

            /// address: 0x2030104
            /// DAC DRC Low HPF Coef Register
            pub const AC_DAC_DRC_LHPFC = @intToPtr(*volatile Mmio(32, packed struct {
                /// coefficient setting and the data is 3.24 format.
                HPF: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x104);

            /// address: 0x2030148
            /// DAC DRC Compressor Slope Low Setting Register
            pub const AC_DAC_DRC_LKC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the compressor, which is determined by the equation that Kc = 1/R.
                /// R is the ratio of the compressor, which is always an integer. The format is
                /// 8.24. (The default value is 2:1)
                DAC_DRC_LKC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x148);

            /// address: 0x2030178
            /// DAC DRC Expander Slope Low Setting Register
            pub const AC_DAC_DRC_LKE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the expander, which is determined by the equation that Ke = 1/R. R
                /// is the ratio of the expander, which is always an integer and the ke must larger
                /// than 50. The format is 8.24. (The default value is <1:5>)
                DAC_DRC_LKE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x178);

            /// address: 0x2030188
            /// DAC DRC Linear Slope Low Setting Register
            pub const AC_DAC_DRC_LKN = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the linear, which is determined by the equation that Kn = 1/R. R is
                /// the ratio of the linear, which is always an integer. The format is 8.24. (The
                /// default value is <1:1>)
                DAC_DRC_LKN: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x188);

            /// address: 0x2030160
            /// DAC DRC Limiter Slope Low Setting Register
            pub const AC_DAC_DRC_LKl = @intToPtr(*volatile Mmio(32, packed struct {
                /// The slope of the limiter, which is determined by the equation that Kl = 1/R. R
                /// is the ratio of the limiter, which is always an integer. The format is 8.24.
                /// (The default value is <50:1>)
                DAC_DRC_LKL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x160);

            /// address: 0x2030158
            /// DAC DRC Limiter Threshold Low Setting Register
            pub const AC_DAC_DRC_LLT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The limiter threshold setting, which is set by the equation that LTin =
                /// -LT/6.0206. The format is 8.24. (The default value is -10 dB)
                DAC_DRC_LLT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x158);

            /// address: 0x2030150
            /// DAC DRC Compressor Low Output at Compressor Threshold Register
            pub const AC_DAC_DRC_LOPC = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the compressor, which is determined by the equation OPC/6.0206.
                /// The format is 8.24. (The default value is -40 dB)
                DAC_DRC_LOPC: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x150);

            /// address: 0x2030180
            /// DAC DRC Expander Low Output at Expander Threshold
            pub const AC_DAC_DRC_LOPE = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the expander which is determined by equation OPE/6.0206. The
                /// format is 8.24. (The default value is -70 dB)
                DAC_DRC_LOPE: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x180);

            /// address: 0x2030168
            /// DAC DRC Limiter Low Output at Limiter Threshold
            pub const AC_DAC_DRC_LOPL = @intToPtr(*volatile Mmio(32, packed struct {
                /// The output of the limiter, which is determined by equation OPT/6.0206. The
                /// format is 8.24. (The default value is -25 dB)
                DAC_DRC_LOPL: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x168);

            /// address: 0x203010c
            /// DAC DRC Left Peak Filter High Attack Time Coef Register
            pub const AC_DAC_DRC_LPFHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                DAC_DRC_LPFHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x10c);

            /// address: 0x203011c
            /// DAC DRC Left Peak Filter High Release Time Coef Register
            pub const AC_DAC_DRC_LPFHRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                DAC_DRC_LPFHRT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x11c);

            /// address: 0x2030110
            /// DAC DRC Left Peak Filter Low Attack Time Coef Register
            pub const AC_DAC_DRC_LPFLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                DAC_DRC_LPFLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x110);

            /// address: 0x2030120
            /// DAC DRC Left Peak Filter Low Release Time Coef Register
            pub const AC_DAC_DRC_LPFLRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                DAC_DRC_LPFLRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x120);

            /// address: 0x203012c
            /// DAC DRC Left RMS Filter High Coef Register
            pub const AC_DAC_DRC_LRMSHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                DAC_DRC_LRMSHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x12c);

            /// address: 0x2030130
            /// DAC DRC Left RMS Filter Low Coef Register
            pub const AC_DAC_DRC_LRMSLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                DAC_DRC_LRMSLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x130);

            /// address: 0x20301a4
            /// DAC DRC MIN Gain High Setting Register
            pub const AC_DAC_DRC_MNGHS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The min gain setting, which is determined by equation MXG =MXG/6.0206. The
                /// format is 8.24 and must -60 dB ≤ MNG ≤ -40 dB (The default value is -40 dB)
                DAC_DRC_MNGHS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x1a4);

            /// address: 0x20301a8
            /// DAC DRC MIN Gain Low Setting Register
            pub const AC_DAC_DRC_MNGLS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The min gain setting, which is determined by equation MXG =MNG/6.0206. The
                /// format is 8.24 and must -60 dB ≤ MNG ≤ -40 dB (The default value is -40 dB)
                DAC_DRC_MNGLS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x1a8);

            /// address: 0x203019c
            /// DAC DRC MAX Gain High Setting Register
            pub const AC_DAC_DRC_MXGHS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The max gain setting, which is determined by equation MXG =MXG/6.0206. The
                /// format is 8.24 and must -20 dB < MXG < 30 dB (The default value is -10 dB)
                DAC_DRC_MXGHS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x19c);

            /// address: 0x20301a0
            /// DAC DRC MAX Gain Low Setting Register
            pub const AC_DAC_DRC_MXGLS = @intToPtr(*volatile Mmio(32, packed struct {
                /// The max gain setting, which is determined by equation MXG =MXG/6.0206. The
                /// format is 8.24 and must -20 dB < MXG < 30 dB (The default value is -10 dB)
                DAC_DRC_MXGLS: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x1a0);

            /// address: 0x2030114
            /// DAC DRC Right Peak Filter High Attack Time Coef Register
            pub const AC_DAC_DRC_RPFHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                DAC_DRC_RPFHAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x114);

            /// address: 0x2030124
            /// DAC DRC Right Peak filter High Release Time Coef Register
            pub const AC_DAC_DRC_RPFHRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter release time parameter setting, which is determined by the
                /// equation that RT = exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 100 ms)
                DAC_DRC_RPFHRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x124);

            /// address: 0x2030118
            /// DAC DRC Peak Filter Low Attack Time Coef Register
            pub const AC_DAC_DRC_RPFLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The left peak filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/ta). The format is 3.24. (The default value is
                /// 1 ms)
                DAC_DRC_RPFLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x118);

            /// address: 0x2030128
            /// DAC DRC Right Peak filter Low Release Time Coef Register
            pub const AC_DAC_DRC_RPFLRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right peak filter release time parameter setting, which is determined by the
                /// equation that AT = exp(-2.2Ts/tr). The format is 3.24. (The default value is 100
                /// ms)
                DAC_DRC_RPFLRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x128);

            /// address: 0x2030134
            /// DAC DRC Right RMS Filter High Coef Register
            pub const AC_DAC_DRC_RRMSHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                DAC_DRC_RRMSHAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x134);

            /// address: 0x2030138
            /// DAC DRC Right RMS Filter Low Coef Register
            pub const AC_DAC_DRC_RRMSLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The right RMS filter average time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tav). The format is 3.24. (The default value is
                /// 10 ms)
                DAC_DRC_RRMSLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x138);

            /// address: 0x203018c
            /// DAC DRC Smooth filter Gain High Attack Time Coef Register
            pub const AC_DAC_DRC_SFHAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The smooth filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 5 ms)
                DAC_DRC_SFHAT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x18c);

            /// address: 0x2030194
            /// DAC DRC Smooth filter Gain High Release Time Coef Register
            pub const AC_DAC_DRC_SFHRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release time parameter setting, which is determined by
                /// the equation that RT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value
                /// is 200 ms)
                DAC_DRC_SFHRT: u11,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
            }), base_address + 0x194);

            /// address: 0x2030190
            /// DAC DRC Smooth filter Gain Low Attack Time Coef Register
            pub const AC_DAC_DRC_SFLAT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The smooth filter attack time parameter setting, which is determined by the
                /// equation that AT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value is
                /// 5 ms)
                DAC_DRC_SFLAT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x190);

            /// address: 0x2030198
            /// DAC DRC Smooth filter Gain Low Release Time Coef Register
            pub const AC_DAC_DRC_SFLRT = @intToPtr(*volatile Mmio(32, packed struct {
                /// The gain smooth filter release time parameter setting, which is determined by
                /// the equation that RT = 1-exp (-2.2Ts/tr). The format is 3.24. (The default value
                /// is 200 ms)
                DAC_DRC_SFLRT: u16,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0x198);

            /// address: 0x2030010
            /// DAC FIFO Control Register
            pub const AC_DAC_FIFOC = @intToPtr(*volatile Mmio(32, packed struct {
                /// DAC FIFO Flush Write ‘1’ to flush TX FIFO, self clear to ‘0’
                FIFO_FLUSH: u1,
                /// DAC FIFO Overrun IRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                FIFO_OVERRUN_IRQ_EN: u1,
                /// DAC FIFO Underrun IRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                FIFO_UNDERRUN_IRQ_EN: u1,
                /// DAC FIFO Empty IRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                DAC_IRQ_EN: u1,
                /// DAC FIFO Empty DRQ Enable
                /// 0: Disabled
                /// 1: Enabled
                DAC_DRQ_EN: u1,
                /// Transmitting Audio Sample Resolution
                /// 0: 16 bits
                /// 1: 20 bits
                TX_SAMPLE_BITS: u1,
                /// DAC Mono Enable
                /// 0: Stereo, 64 levels FIFO
                /// 1: Mono, 128 levels FIFO When enabled, L & R channel send the same data.
                DAC_MONO_EN: u1,
                reserved0: u1,
                /// TX FIFO Empty Trigger Level (TXTL[12:0]) Interrupt and DMA request trigger level
                /// for TX FIFO normal condition. IRQ/DRQ generated when WLEVEL ≤ TXTL
                TX_TRIG_LEVEL: u7,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                /// When TX FIFO available room is less than or equal N, the DRQ request will be
                /// de-asserted. N is defined here:
                /// 00: IRQ/DRQ de-asserted when WLEVEL > TXTL
                /// 01: 4
                /// 10: 8
                /// 11: 16
                DAC_DRQ_CLR_CNT: u2,
                reserved7: u1,
                /// For 20-bit transmitted audio sample: 00/10: FIFO_I[19:0] = {TXDATA[31:12]}
                /// 01/11: FIFO_I[19:0] = {TXDATA[19:0]} For 16-bit transmitted audio sample: 00/10:
                /// FIFO_I[19:0] = {TXDATA[31:16], 4’b0} 01/11: FIFO_I[19:0] = {TXDATA[15:0],
                /// 4’b0}
                FIFO_MODE: u2,
                /// Audio sample select when TX FIFO underrun
                /// 0: Sending zero
                /// 1: Sending the last audio sample
                SEND_LASAT: u1,
                reserved8: u1,
                /// FIR Version
                /// 0: 64-Tap FIR
                /// 1: 32-Tap FIR
                FIR_VER: u1,
                /// Sample Rate of DAC
                /// 000: 48 kHz
                /// 010: 24 kHz
                /// 100: 12 kHz
                /// 110: 192 kHz
                /// 001: 32 kHz
                /// 011: 16 kHz
                /// 101: 8 kHz
                /// 111: 96 kHz 44.1 kHz/22.05 kHz/11.025 kHz can be supported by Audio PLL
                /// Configure Bit
                DAC_FS: u3,
            }), base_address + 0x10);

            /// address: 0x2030014
            /// DAC FIFO Status Register
            pub const AC_DAC_FIFOS = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                /// TX FIFO Overrun Pending Interrupt
                /// 0: No Pending Interrupt
                /// 1: FIFO Overrun Pending Interrupt Write ‘1’ to clear this interrupt
                TXO_INT: u1,
                /// TX FIFO Underrun Pending Interrupt
                /// 0: No Pending Interrupt
                /// 1: FIFO Underrun Pending Interrupt Write ‘1’ to clear this interrupt
                TXU_INT: u1,
                /// TX FIFO Empty Pending Interrupt
                /// 0: No Pending IRQ
                /// 1: FIFO Empty Pending Interrupt Write ‘1’ to clear this interrupt or
                /// automatically clear if the interrupt condition fails.
                TXE_INT: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// TX FIFO Empty Space Word Counter
                TXE_CNT: u15,
                /// TX FIFO Empty
                /// 0: No room for new sample in TX FIFO
                /// 1: More than one room for new sample in TX FIFO (>= 1 word)
                TX_EMPTY: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0x2030020
            /// DAC TX DATA Register
            pub const AC_DAC_TXDATA = @intToPtr(*volatile Mmio(32, packed struct {
                /// Write the transmitting left and right channel sample data to this register one
                /// by one. Write the left channel sample data first and then the right channel
                /// sample.
                TX_DATA: u32,
            }), base_address + 0x20);

            /// address: 0x2030050
            /// ADC Digtial Control Register
            pub const ADC_DIG_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// Bit 3: ADC4 enabled Bit 2: ADC3 enabled Bit 1: ADC2 enabled Bit 0: ADC1 enabled
                ADC_CHANNEL_EN: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                /// ADC1/2 Volume Control Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC1_2_VOL_EN: u1,
                /// ADC3 Volume Control Enable
                /// 0: Disabled
                /// 1: Enabled
                ADC3_VOL_EN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }), base_address + 0x50);

            /// address: 0x2030034
            /// ADC Volume Control1 Register
            pub const ADC_VOL_CTRL1 = @intToPtr(*volatile Mmio(32, packed struct {
                /// ADC1 channel volume (-119.25 dB To 71.25 dB, 0.75 dB/Step)
                /// 0x00: Mute
                /// 0x01: -119.25 dB ...
                /// 0x9F: -0.75 dB
                /// 0xA0: 0 dB
                /// 0xA1: 0.75 dB ...
                /// 0xFF: 71.25 dB
                ADC1_VOL: u8,
                /// ADC2 channel volume (-119.25 dB To 71.25 dB, 0.75 dB/Step)
                /// 0x00: Mute
                /// 0x01: -119.25 dB ...
                /// 0x9F: -0.75 dB
                /// 0xA0: 0 dB
                /// 0xA1: 0.75 dB ...
                /// 0xFF: 71.25 dB
                ADC2_VOL: u8,
                /// ADC3 channel volume (-119.25 dB To 71.25 dB, 0.75 dB/Step)
                /// 0x00: Mute
                /// 0x01: -119.25 dB ...
                /// 0x9F: -0.75 dB
                /// 0xA0: 0 dB
                /// 0xA1: 0.75 dB ...
                /// 0xFF: 71.25 dB
                ADC3_VOL: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x34);

            /// address: 0x2030004
            /// DAC Volume Control Register
            pub const DAC_VOL_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// DAC right channel volume (-119.25 dB To 71.25 dB, 0.75 dB/Step)
                /// 0x00: Mute
                /// 0x01: -119.25 dB ... 0x9F = -0.75 dB 0xA0 = 0 dB 0xA1 = 0.75 dB ... 0xFF = 71.25
                /// dB
                DAC_VOL_R: u8,
                /// DAC left channel volume (-119.25 dB to 71.25 dB, 0.75 dB/Step)
                /// 0x00: Mute
                /// 0x01: -119.25 dB ... 0x9F = -0.75 dB 0xA0 = 0 dB 0xA1 = 0.75 dB ... 0xFF = 71.25
                /// dB
                DAC_VOL_L: u8,
                /// DAC Volume Control Selection Enable
                /// 0: Disabled
                /// 1: Enabled
                DAC_VOL_SEL: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x4);

            /// address: 0x2030054
            /// VRA1SPEEDUP_DOWN_CTRL
            pub const VRA1SPEEDUP_DOWN_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                /// VAR1Speedup Down RST Manual Control Enable
                /// 0: Disabled. VAR1Speedup Down converts to 1 after the bus rst releases 32 ms.
                /// 1: Enabled. VAR1Speedup Down reset 0 immediately.
                VRA1SPEEDUP_DOWN_RST_CTRL: u1,
                /// VAR1Speedup Down Manual Control Enable
                /// 0: Disabled. VAR1Speedup Down converts to 1 after the bus rst releases 32 ms.
                /// 1: Enabled. VAR1Speedup Down converts to 1 immediately.
                VRA1SPEEDUP_DOWN_CTRL: u1,
                reserved0: u1,
                reserved1: u1,
                /// Only if VAR1SPEEDUP_DOWN_Further_CTRL (0x310[22]) is set 0, VAR1Speedup Down
                /// State is valid.
                /// 0: VAR1Speedup_Down does not work.
                /// 1: VAR1Speedup_Down works.
                VRA1SPEEDUP_DOWN_STATE: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0x54);
        };
    };

    /// RTC
    pub const RTC = struct {
        pub const base_address = 0x7090000;

        /// address: 0x7090024
        /// Alarm 0 Counter Current Value Register
        pub const ALARM0_CUR_VLU_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current second Range from 0 to 59.
            SECOND: u6,
            reserved0: u1,
            reserved1: u1,
            /// Current minute Range from 0 to 59.
            MINUTE: u6,
            reserved2: u1,
            reserved3: u1,
            /// Current hour Range from 0 to 23.
            HOUR: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x24);

        /// address: 0x7090020
        /// Alarm 0 Day Setting Register
        pub const ALARM0_DAY_SET_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm 0 Counter is based on Day.
            ALARM0_COUNTER: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x7090028
        /// Alarm 0 Enable Register
        pub const ALARM0_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm 0 Enable
            /// 0: Disable
            /// 1: Enable
            ALM_0_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x28);

        /// address: 0x709002c
        /// Alarm 0 IRQ Enable Register
        pub const ALARM0_IRQ_EN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x2c);

        /// address: 0x7090030
        /// Alarm 0 IRQ Status Register
        pub const ALARM0_IRQ_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm 0 IRQ Pending bit
            /// 0: No effect
            /// 1: Pending, alarm 0 counter value is reached If alarm 0 irq enable is set to 1,
            /// the pending bit will be sent to the interrupt controller.
            ALARM0_IRQ_PEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x30);

        /// address: 0x7090050
        /// Alarm Configuration Register
        pub const ALARM_CONFIG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configuration of alarm wake up output.
            /// 0: Disable alarm wake up output
            /// 1: Enable alarm wake up output
            ALARM_WAKEUP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x7090160
        /// DCXO Control Register
        pub const DCXO_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Enable
            /// 0: Disable The related register configuration is necessary to ensure the reset
            /// debounce circuit has a stable clock source. The first time SoC starts up, by
            /// default, the reset debounce circuit of SoC uses 32K divided by RC16M. In
            /// power-off, software reads the related bit to ensure whether EXT32K is working
            /// normally, if it is normal, first switch the clock source of debounce circuit to
            /// EXT32K, then close RC16M. Without EXT32K scenario or external RTC scenario,
            /// software confirms firstly whether EXT32K is working normally before switching,
            /// or software does not close RC16M.
            CLK16M_RC_EN: u1,
            /// DCXO enable
            /// 1: Enable
            /// 0: Disable
            DCXO_EN: u1,
            /// For Debug Use Only. It cannot configure to 0 in normal state.
            RSTO_DLY_SEL: u1,
            reserved0: u1,
            /// DCXO rfclk enhance Enhance driving capacity of output OUT_RF_REFCLK, 0x0 for 5
            /// pF, 0x1 for 10 pF, 0x2 for 15 pF, 0x3 for 20 pF.
            DCXO_RFCLK_ENHANCE: u2,
            /// Xtal mode enable signal, active high
            /// 0: For external clk input mode
            /// 1: For normal mode
            XTAL_MODE: u1,
            /// DCXO LDO driving capacity signal, active high
            DCXO_LDO_INRUSHB: u1,
            /// DCXO bandgap output voltage
            DCXO_BG: u5,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DCXO cap array value The capacity cell is 55 fF.
            DCXO_TRIM: u7,
            reserved4: u1,
            /// DCXO current control value
            DCXO_ICTRL: u4,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Clock REQ enable
            /// 0: Enable DCXO wake up function
            /// 1: Disable DCXO wake up function
            CLK_REQ_ENB: u1,
        }), base_address + 0x160);

        /// address: 0x7090204
        /// EFUSE_HV_PWRSWT_CTRL_REG
        pub const EFUSE_HV_PWRSWT_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Open power switch
            /// 0: Close power switch
            EFUSE_1_8V_POWER_SWITCH_CONTROL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x204);

        /// address: 0x7090120
        /// Fast Boot Information Register0
        pub const FBOOT_INFO_REG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast Boot info Fast Boot Information 0, refer to BROM spec.
            FBOOT_INFO0: u32,
        }), base_address + 0x120);

        /// address: 0x7090124
        /// Fast Boot Information Register1
        pub const FBOOT_INFO_REG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fast Boot info Fast Boot Information 1, refer to BROM spec.
            FBOOT_INFO1: u32,
        }), base_address + 0x124);

        /// address: 0x7090100
        /// GP_DATA_REGN[%s]
        pub const GP_DATA_REGN = @intToPtr(*volatile [8]Mmio(32, packed struct {
            /// Data [31:0] General purpose register 0 to 7 value can be stored if the RTC-VIO
            /// is larger than 0.7 V.
            GP_DATA: u32,
        }), base_address + 0x100);

        /// address: 0x70901f0
        /// IC Characteristic Register
        pub const IC_CHARA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Return 0x16AA only if the KEY_FIELD is set as 0x16AA when read those bits,
            /// otherwise return 0x0.
            ID_DATA: u16,
            /// Key Field The field should be written as 0x16AA. Writing any other value in this
            /// field aborts the write-operation.
            KEY_FIELD: u16,
        }), base_address + 0x1f0);

        /// address: 0x7090008
        /// Internal OSC Clock Pre-scalar Register
        pub const INTOSC_CLK_PRESCAL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal OSC 32K Clock Prescalar value N. The clock output = Internal RC/32/N.
            /// 00000: 1
            /// 00001: 2
            /// 00002: 3 ............
            /// 11111: 32
            INTOSC_32K_CLK_PRESCAL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x8);

        /// address: 0x7090004
        /// LOSC Auto Switch Status Register
        pub const LOSC_AUTO_SWT_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Checking LOSC clock source status
            /// 0: Low frequency clock from 16M RC
            /// 1: External 32.768 kHz OSC
            LOSC_SRC_SEL_STA: u1,
            /// LOSC auto switch pending
            /// 0: No effect
            /// 1: Auto switch pending, it means LOSC_SRC_SEL is changed from 1 to 0. Setting 1
            /// to this bit will clear it.
            LOSC_AUTO_SWT_PEND: u1,
            /// Work only when the auto switch function is enabled.
            /// 0: External 32.768 kHz OSC work normally
            /// 1: External 32.768 kHz OSC work abnormally
            EXT_LOSC_STA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x7090000
        /// Low Oscillator Control Register
        pub const LOSC_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LOSC Clock Source Select
            /// 0: Low frequency clock from 16M RC
            /// 1: External 32.768 kHz OSC If the bit[8:7] of LOSC_CTRL_REG is set, the RTC
            /// HH-MM-SS, DD and ALARM DD-HH-MM-SS register cannot be written.
            LOSC_SRC_SEL: u1,
            /// RTC_TIMER Clock Source Select
            /// 0: LOSC_SRC
            /// 1: 24MDIV32K Before switching the bit, make sure that the 24MDIV32K function is
            /// enabled, that is, the bit16 of the 32K Fanout Control Register is 1.
            RTC_SRC_SEL: u1,
            /// External 32.768 kHz Crystal GSM
            /// 00: Low
            /// 01: /
            /// 10: /
            /// 11: High When GSM is changed, the 32K oscillation circuit will arise transient
            /// instability. If the autoswitch function (bit 15) is enabled, 32K changes to
            /// RC16M with certain probability. The GSM can influence the time of 32K starting
            /// oscillation, the more the GSM, the shorter the time of starting oscillation. So
            /// modifying GSM is not recommended. If you need to modify the GSM, firstly disable
            /// the auto switch function (bit 15), with a delay of 50 us, then change the GSM,
            /// the 32K clock source is changed to external clock.
            EXT_LOSC_GSM: u2,
            /// External 32.768 kHz Crystal Enable
            /// 0: Disable
            /// 1: Enable
            EXT_LOSC_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// RTC DAY access After writing the RTC DAY register, this bit is set and it will
            /// be cleared until the real writing operation is finished. After writing the RTC
            /// DAY register, the DAY register will be refreshed for at most one second. Note:
            /// Make sure that the bit is 0 for time configuration.
            RTC_DAY_ACCE: u1,
            /// RTC Hour Minute Second access After writing the RTC HH-MM-SS Register, this bit
            /// is set and it will be cleared until the real writing operation is finished.
            /// After writing the RTC HH-MM-SS Register, the RTC HH-MM-SS Register will be
            /// refreshed for at most one second. Note: Make sure that the bit is 0 for time
            /// configuration.
            RTC_HHMMSS_ACCE: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// LOSC auto switch 32K clk source select enable
            /// 0: Disable. When the losc losts, the 32k clk source will not change to RC
            /// 1: Enable. When the losc losts, the 32k clk source will change to RC
            /// (LOSC_SRC_SEL will be changed from 1 to 0)
            LOSC_AUTO_SWT_32K_SEL_EN: u1,
            /// LOSC auto switch function disable
            /// 0: Enable
            /// 1: Disable
            LOSC_AUTO_SWT_FUNCTION: u1,
            /// Key Field This field should be filled with 0x16AA, and then the bit0 and bit1
            /// can be written with the new value.
            KEY_FIELD: u16,
        }), base_address + 0x0);

        /// address: 0x7090010
        /// RTC Year-Month-Day Register
        pub const RTC_DAY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set Day Range from 0 to 65535.
            DAY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x7090014
        /// RTC Hour-Minute-Second Register
        pub const RTC_HH_MM_SS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set second Range from 0 to 59.
            SECOND: u6,
            reserved0: u1,
            reserved1: u1,
            /// Set minute Range from 0 to 59.
            MINUTE: u6,
            reserved2: u1,
            reserved3: u1,
            /// Set hour Range from 0 to 23.
            HOUR: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x14);

        /// address: 0x7090310
        /// RTC SPI Clock Control Register The offset addresses less than 0x0300 are in
        /// VDD_RTC power domain, and the offset addresses large than or equal to 0x300 are
        /// in VDD_SYS power domain.
        pub const RTC_SPI_CLK_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reg CFG SPI Clock Divider: M Actual SPI Clock = AHBS1/(M+1), (0 to 15) The
            /// default frequency of AHBS1 is 200 MHz, and the default frequency of SPI Clock is
            /// 20 MHz. Note: The SPI clock can not exceed 50 MHz, or else the RTC register may
            /// be abnormal. 4 Video and Graphics
            /// .................................................................................................................................................
            /// 386 4.1 DE
            /// ....................................................................................................................................................................
            /// 386 4.2 DI
            /// .....................................................................................................................................................................
            /// 387 4.3
            /// G2D..................................................................................................................................................................
            /// 388 4.4 Video Decoding
            /// ...............................................................................................................................................
            /// 389 4.4.1 Overview
            /// .............................................................................................................................................
            /// 389 4.4.2 Block Diagram
            /// .....................................................................................................................................
            /// 390 4.5 Video Encoding
            /// ...............................................................................................................................................
            /// 391 4.5.1 Overview
            /// .............................................................................................................................................
            /// 391 4.5.2 Block Diagram
            /// .....................................................................................................................................
            /// 391 Figure 4-1 DE Block Diagram
            /// .............................................................................................................................................
            /// 386 Figure 4-2 Video Decoding Block Diagram
            /// ........................................................................................................................
            /// 390 Figure 4-3 JPGE Block Diagram
            /// .........................................................................................................................................
            /// 392
            RTC: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// Reg CFG SPI Clock Gating
            /// 0: Gating
            /// 1: Not Gating Before configurating RTC register, the clock divider of SPI needs
            /// be configured firstly, then clock gating needs be enabled. Note: Frequency
            /// division and clock gating can not be set at the same time.
            RTC: u1,
        }), base_address + 0x310);

        /// address: 0x7090190
        /// RTC_VIO Regulation Register
        pub const RTC_VIO_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC_VIO Voltage Select The RTC-VIO is provided power for RTC digital part. These
            /// bits are useful for regulating the RTC_VIO from 0.65 V to 1.3 V.
            /// 000: 1.0 V
            /// 001: 0.65 V (the configuration can cause RTC reset)
            /// 010: 0.7 V
            /// 011: 0.8 V
            /// 100: 0.9 V
            /// 101: 1.1 V
            /// 110: 1.2 V
            /// 111: 1.3 V
            RTC_VIO_REGU: u3,
            reserved0: u1,
            /// VDD Select
            /// 0: Resistance divider
            /// 1: Band gap
            V_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x190);

        /// address: 0x70901f4
        /// VDD Off Gating Control Register
        pub const VDD_OFF_GATING_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: not bypass
            /// 1: bypass
            VCCIO_DET_BYPASS_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Bit[7:5]: Reserved, default=0 Bit[4]: Bypass debounce circuit, defaule=0 Bit[3]:
            /// Enable control, defaule=0
            /// 0: Disable VCC-IO detection
            /// 1: Force the detection output Bit[2:0]: Gear adjustment
            /// 000: Detection threshold is 2.5 V
            /// 001: Detection threshold is 2.6 V
            /// 010: Detection threshold is 2.7 V (default)
            /// 011: Detection threshold is 2.8 V
            /// 100: Detection threshold is 2.9 V
            /// 101: Detection threshold is 3 V
            /// 110: N/A
            /// 111: N/A
            VCCIO_DET_SPARE: u8,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// (For Debug Use Only) Power off gating control signal When use vdd_sys to RTC
            /// isolation software control, write this bit to 1. It will only be cleared by
            /// resetb release.
            PWROFF_GAT_RTC_CFG: u1,
            /// Key Field This field should be filled with 0x16AA, and then the bit 15 can be
            /// configured.
            KEY_FIELD: u16,
        }), base_address + 0x1f4);

        /// address: 0x7090060
        /// _32K_FOUT_CTRL_GATING_REG
        pub const _32K_FOUT_CTRL_GATING_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// LOSC output source select
            /// 00: RTC_32K (select by RC_CLK_SRC_SEL & LOSC_SRC_SEL)
            /// 01: LOSC
            /// 10: HOSC divided 32K
            LOSC_OUT_SRC_SEL: u2,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// HOSC to 32k divider enable
            /// 0: Disable the hosc 24M to 32K divider circuit
            /// 1: Enable the hosc 24M to 32K divider circuit
            HOSC_TO_32K_DIVIDER_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60);
    };

    /// CCU
    pub const CCU = struct {
        pub const base_address = 0x2001000;

        /// address: 0x2001520
        /// APB0 Clock Register
        pub const APB0_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M = FACTOR_M+1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: HOSC
            /// 01: CLK32K
            /// 10: PSI_CLK
            /// 11: PLL_PERI(1X) APB0_CLK = Clock Source/M/N.
            CLK_SRC_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x520);

        /// address: 0x2001524
        /// APB1 Clock Register
        pub const APB1_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M = FACTOR_M+1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: HOSC
            /// 01: CLK32K
            /// 10: PSI_CLK
            /// 11: PLL_PERI(1X) APB1_CLK = Clock Source/M/N.
            CLK_SRC_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x524);

        /// address: 0x2001a54
        /// AUDIO_CODEC_ADC Clock Register
        pub const AUDIO_CODEC_ADC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO1(DIV2)
            /// 10: PLL_AUDIO1(DIV5)
            CLK_SRC_SE: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON AUDIO_CODEC_ADC_CLK = Clock Source/M/N.
            AUDIO_CODEC_ADC_CLK_GATING: u1,
        }), base_address + 0xa54);

        /// address: 0x2001a5c
        /// AUDIO_CODEC Bus Gating Reset Register
        pub const AUDIO_CODEC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For AUDIO_CODEC
            /// 0: Mask
            /// 1: Pass
            AUDIO_CODEC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// AUDIO_CODEC Reset
            /// 0: Assert
            /// 1: De-assert
            AUDIO_CODEC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xa5c);

        /// address: 0x2001a50
        /// AUDIO_CODEC_DAC Clock Register
        pub const AUDIO_CODEC_DAC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO1(DIV2)
            /// 10: PLL_AUDIO1(DIV5)
            CLK_SRC_SE: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON AUDIO_CODEC_DAC_CLK = Clock Source/M/N.
            AUDIO_CODEC_DAC_CLK_GATING: u1,
        }), base_address + 0xa50);

        /// address: 0x2001740
        /// AVS Clock Register
        pub const AVS_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// Gating Clock The AVS_CLK is from HOSC.
            /// 0: Clock is OFF
            /// 1: Clock is ON
            AVS_CLK_GATING: u1,
        }), base_address + 0x740);

        /// address: 0x2001f30
        /// CCU FANOUT CLOCK GATE Register
        pub const CCU_FAN_GATE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating for CLK24M
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK24M_EN: u1,
            /// Gating for CLK12M
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK12M_EN: u1,
            /// Gating for CLK16M
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK16M_EN: u1,
            /// Gating for CLK25M
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK25M_EN: u1,
            /// Gating for CLK32K
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK32K_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xf30);

        /// address: 0x2001f3c
        /// CCU FANOUT Register
        pub const CCU_FAN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 000:CLK32K (From PLL_PERI(2X)) 001:CLK12M (From DCXO) 010:CLK16M (From
            /// PLL_PERI(2X)) 011:CLK24M (From DCXO) 100:CLK25M (From PLL_PERI(1X)) 101:CLK27M
            /// 110:PCLK CLK_FANOUT0 can be selected to output from the above seven sources.
            CLK_FANOUT0_SEL: u3,
            /// 000:CLK32K (From PLL_PERI(2X)) 001:CLK12M (From DCXO/2) 010:CLK16M (From
            /// PLL_PERI(2X)) 011:CLK24M (From DCXO) 100:CLK25M (From PLL_PERI(1X)) 101:CLK27M
            /// 110:PCLK CLK_FANOUT1 can be selected to output from the above seven sources.
            CLK_FANOUT1_SEL: u3,
            /// 000:CLK32K (From PLL_PERI(2X)) 001:CLK12M (From DCXO/2) 010:CLK16M (From
            /// PLL_PERI(2X)) 011:CLK24M (From DCXO) 100:CLK25M (From PLL_PERI(1X)) 101:CLK27M
            /// 110:PCLK CLK_FANOUT2 can be selected to output from the above seven sources.
            CLK_FANOUT2_SEL: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Gating for CLK_FANOUT0
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK_FANOUT0_EN: u1,
            /// Gating for CLK_FANOUT1
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK_FANOUT1_EN: u1,
            /// Gating for CLK_FANOUT2
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CLK_FANOUT2_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xf3c);

        /// address: 0x200168c
        /// CE Bus Gating Reset Register
        pub const CE_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// CE Gating Clock
            /// 0: Mask
            /// 1: Pass
            CE_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// CE Reset
            /// 0: Assert
            /// 1: De-assert
            CE_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x68c);

        /// address: 0x2001680
        /// CE Clock Register
        pub const CE_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 00: HOSC
            /// 01: PLL_PERI(2X)
            /// 10: PLL_PERI(1X)
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON CE_CLK = Clock Source/M/N.
            CE_CLK_GATING: u1,
        }), base_address + 0x680);

        /// address: 0x2001f34
        /// CLK27M FANOUT Register
        pub const CLK27M_FAN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1. FACTOR_M is from 0 to 31.
            CLK27M_DIV0: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N N= FACTOR_N +1. FACTOR_N is from 0 to 3.
            CLK27M_DIV1: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 000: PLL_VIDEO0(1X)
            /// 001: PLL_VIDEO1(1X)
            /// 010: /
            /// 011: /
            CLK27M_SCR_SEL: u2,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating for CLK27M
            /// 0: Clock is OFF
            /// 1: Clock is ON SCLK = Clock Source/M/N.
            CLK27M_EN: u1,
        }), base_address + 0xf34);

        /// address: 0x2001500
        /// CPU_AXI Configuration Register
        pub const CPU_AXI_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M (M= FACTOR_M +1) FACTOR_M is from 1 to 3.
            CPU_DIV1: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Factor N (N = FACTOR_N +1) FACTOR_N is from 1 to 3.
            CPU_DIV2: u2,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// PLL Output External Divider P
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: / When the output clock is less than 288 MHz, the clock frequency can be get
            /// by dividing P.
            PLL_CPU_OUT_EXT_DIVP: u2,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: CLK32K
            /// 010: CLK16M_RC
            /// 011: PLL_CPU/P
            /// 100: PLL_PERI(1X)
            /// 101: PLL_PERI(2X)
            /// 110: PLL_PERI(800M) CPU Clock = Clock Source CPU_AXI Clock = Clock Source/M
            CPU_CLK_SEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x500);

        /// address: 0x2001504
        /// CPU_GATING Configuration Register
        pub const CPU_GATING_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// CPU Gating Field If CPU_GATING_FIELD==16’h16AA, the bit31 can be configured.
            CPU_GATING_FIELD: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Gating Special Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON
            CPU_GATING: u1,
        }), base_address + 0x504);

        /// address: 0x2001c1c
        /// CSI Bus Gating Reset Register
        pub const CSI_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For CSI
            /// 0: Mask
            /// 1: Pass
            CSI_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// CSI Reset
            /// 0: Assert
            /// 1: De-assert
            CSI_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc1c);

        /// address: 0x2001c04
        /// CSI Clock Register
        pub const CSI_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Clock Source Select
            /// 000: PLL_PERI(2X)
            /// 001: PLL_VIDEO0(2X)
            /// 010: PLL_VIDEO1(2X)
            CLK_SRC_SEL: u3,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON CSI_CLK = Clock Source/M.
            CSI_CLK_GATING: u1,
        }), base_address + 0xc04);

        /// address: 0x2001c08
        /// CSI Master Clock Register
        pub const CSI_MASTER_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_VIDEO0(1X)
            /// 011: PLL_VIDEO1(1X)
            /// 100: PLL_AUDIO1(DIV2)
            /// 101: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON CSI_MASTER_CLK = Clock Source/M.
            CSI_MASTER_CLK_GATING: u1,
        }), base_address + 0xc08);

        /// address: 0x200178c
        /// DBGSYS Bus Gating Reset Register
        pub const DBGSYS_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for DBGSYS The clock of DBGSYS is from HOSC.
            /// 0: Mask
            /// 1: Pass
            DBGSYS_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DBGSYS Reset
            /// 0: Assert
            /// 1: De-assert
            DBGSYS_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x78c);

        /// address: 0x200160c
        /// DE Bus Gating Reset Register
        pub const DE_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DE Gating Clock
            /// 0: Mask
            /// 1: Pass
            DE_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DE Reset
            /// 0: Assert
            /// 1: De-assert
            DE_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60c);

        /// address: 0x2001600
        /// DE Clock Register
        pub const DE_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 000: PLL_PERI(2X)
            /// 001: PLL_VIDEO0(4X)
            /// 010: PLL_VIDEO1(4X)
            /// 011: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON DE_CLK = Clock Source/M.
            DE_CLK_GATING: u1,
        }), base_address + 0x600);

        /// address: 0x200162c
        /// DI Bus Gating Reset Register
        pub const DI_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DI Gating Clock
            /// 0: Mask
            /// 1: Pass
            DI_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DI Reset
            /// 0: Assert
            /// 1: De-assert
            DI_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x62c);

        /// address: 0x2001620
        /// DI Clock Register
        pub const DI_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M = FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 000: PLL_PERI(2X)
            /// 001: PLL_VIDEO0(4X)
            /// 010: PLL_VIDEO1(4X)
            /// 011: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON DI_CLK = Clock Source/M.
            DI_CLK_GATING: u1,
        }), base_address + 0x620);

        /// address: 0x200170c
        /// DMA Bus Gating Reset Register
        pub const DMA_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Gating Clock
            /// 0: Mask
            /// 1: Pass
            DMA_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DMA Reset
            /// 0: Assert
            /// 1: De-assert
            DMA_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x70c);

        /// address: 0x2001a4c
        /// DMIC Bus Gating Reset Register
        pub const DMIC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for DMIC
            /// 0: Mask
            /// 1: Pass
            DMIC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DMIC Reset
            /// 0: Assert
            /// 1: De-assert
            DMIC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xa4c);

        /// address: 0x2001a40
        /// DMIC Clock Register
        pub const DMIC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO1(DIV2)
            /// 10: PLL_AUDIO1(DIV5)
            /// 11: Reserved
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON DMIC_CLK = Clock Source/M/N.
            DMIC_CLK_GATING: u1,
        }), base_address + 0xa40);

        /// address: 0x2001abc
        /// DPSS_TOP Bus Gating Reset Register
        pub const DPSS_TOP_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For DPSS_TOP
            /// 0: Mask
            /// 1: Pass
            DPSS_TOP_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DPSS_TOP Reset
            /// 0: Assert
            /// 1: De-assert
            DPSS_TOP_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xabc);

        /// address: 0x200180c
        /// DRAM Bus Gating Reset Register
        pub const DRAM_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for DRAM
            /// 0: Mask
            /// 1: Pass
            DRAM_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DRAM Reset
            /// 0: Assert
            /// 1: De-assert
            DRAM_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x80c);

        /// address: 0x2001800
        /// DRAM Clock Register
        pub const DRAM_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 3.
            DRAM_DIV1: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            DRAM_DIV2: u2,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Clock Source Select
            /// 00: PLL_DDR
            /// 01: PLL_AUDIO1(DIV2)
            /// 10: PLL_PERI(2X)
            /// 11: PLL_PERI(800M)
            DRAM_CLK_SEL: u3,
            /// SDRCLK Configuration 0 Update
            /// 0: Invalid
            /// 1: Valid Setting 1 will validate the bit. It will be automatically cleared after
            /// the bit is valid. Here supports dram req/ack signal. When dram_update is set to
            /// 1, dram_clk_sel/dram_div2/dram_clk1 will be updated.
            SDRCLK_UPD: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Clock DRAM_CLK = Clock Source/M/N.
            /// 0: Clock is OFF
            /// 1: Clock is ON
            DRAM_CLK_GATING: u1,
        }), base_address + 0x800);

        /// address: 0x2001b4c
        /// DSI Bus Gating Reset Register
        pub const DSI_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For DSI
            /// 0: Mask
            /// 1: Pass
            DSI_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DSI Reset
            /// 0: Assert
            /// 1: De-assert
            DSI_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xb4c);

        /// address: 0x2001b24
        /// DSI Clock Register
        pub const DSI_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_VIDEO0(2X)
            /// 011: PLL_VIDEO1(2X)
            /// 100: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON DSI_CLK = Clock Source/M.
            DSI_CLK_GATING: u1,
        }), base_address + 0xb24);

        /// address: 0x2001c7c
        /// DSP Bus Gating Reset Register
        pub const DSP_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Gating Clock For DSP_CFG
            /// 0: Mask
            /// 1: Pass
            DSP_CFG_GATING: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DSP Reset
            /// 0: Assert
            /// 1: De-assert
            DSP_RST: u1,
            /// DSP_CFG Reset
            /// 0: Assert
            /// 1: De-assert
            DSP_CFG_RST: u1,
            /// DSP_DBG Reset
            /// 0: Assert
            /// 1: De-assert
            DSP_DBG_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc7c);

        /// address: 0x2001c70
        /// DSP Clock Register
        pub const DSP_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: CLK32K
            /// 010: CLK16M_RC
            /// 011: PLL_PERI(2X)
            /// 100: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON DSP_CLK = Clock Source/M.
            DSP_CLK_GATING: u1,
        }), base_address + 0xc70);

        /// address: 0x2001970
        /// EMAC_25M Clock Register
        pub const EMAC_25M_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// Gating the Source Clock of Special Clock It is for low power design.
            /// 0: Clock is OFF
            /// 1: Clock is ON
            EMAC_25M_CLK_SRC_GATING: u1,
            /// Gating Special Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON CLK = PLL_PERI(1X)/24 = 25 MHz
            EMAC_25M_CLK_GATING: u1,
        }), base_address + 0x970);

        /// address: 0x200197c
        /// EMAC Bus Gating Reset Register
        pub const EMAC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for EMAC
            /// 0: Mask
            /// 1: Pass
            EMAC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// EMAC Reset
            /// 0: Assert
            /// 1: De-assert
            EMAC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x97c);

        /// address: 0x2001f08
        /// Frequency Detect Control Register
        pub const FRE_DET_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequence Detect Function Enable
            /// 0: Disable
            /// 1: Enable
            FRE_DET_FUN_EN: u1,
            /// Frequence Detect IRQ Enable
            /// 0: Disable
            /// 1: Enable
            FRE_DET_IRQ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Detect Time Time=1/32k*(2^RegValue) RegValue is from 0 to 16.
            DET_TIME: u5,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Error Flag
            /// 0: Write 0 to clear
            /// 1: Error
            ERROR_FLAG: u1,
        }), base_address + 0xf08);

        /// address: 0x2001f10
        /// Frequency Down Limit Register
        pub const FRE_DOWN_LIM_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequence Down Limit
            FRE_DOWN_LIM: u32,
        }), base_address + 0xf10);

        /// address: 0x2001f0c
        /// Frequency Up Limit Register
        pub const FRE_UP_LIM_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequence Up Limit
            FRE_UP_LIM: u32,
        }), base_address + 0xf0c);

        /// address: 0x200163c
        /// G2D Bus Gating Reset Register
        pub const G2D_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// G2D Gating Clock
            /// 0: Mask
            /// 1: Pass
            G2D_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// G2D Reset
            /// 0: Assert
            /// 1: De-assert
            G2D_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x63c);

        /// address: 0x2001630
        /// G2D Clock Register
        pub const G2D_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 000: PLL_PERI(2X)
            /// 001: PLL_VIDEO0(4X)
            /// 010: PLL_VIDEO1(4X)
            /// 011: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON G2D_CLK = Clock Source/M.
            G2D_CLK_GATING: u1,
        }), base_address + 0x630);

        /// address: 0x20019ec
        /// GPADC Bus Gating Reset Register
        pub const GPADC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For GPADC
            /// 0: Mask
            /// 1: Pass
            GPADC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// GPADC Reset
            /// 0: Assert
            /// 1: De-assert
            GPADC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x9ec);

        /// address: 0x2001b04
        /// HDMI_24M Clock Register
        pub const HDMI_24M_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON HDMI_24M_CLK = HOSC
            HDMI_24M_CLK_GATING: u1,
        }), base_address + 0xb04);

        /// address: 0x2001b1c
        /// HDMI Bus Gating Reset Register
        pub const HDMI_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For HDMI
            /// 0: Mask
            /// 1: Pass
            HDMI_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// HDMI_MAIN Reset
            /// 0: Assert
            /// 1: De-assert
            HDMI_MAIN_RST: u1,
            /// HDMI_SUB Reset
            /// 0: Assert
            /// 1: De-assert
            HDMI_SUB_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xb1c);

        /// address: 0x2001b10
        /// HDMI CEC Clock Register
        pub const HDMI_CEC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Clock Source Select
            /// 0: CLK32K
            /// 1: HDMI_CEC_CLK32K, PLL_PERI(2X)/36621 = 32.768 kHz 1X:/
            CLK_SRC_SEL: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// Gating PERIPLL Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON
            PERI_GATING: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON HDMI_CEC_CLK = Clock Source.
            HDMI_CEC_CLK_GATING: u1,
        }), base_address + 0xb10);

        /// address: 0x200173c
        /// HSTIMER Bus Gating Reset Register
        pub const HSTIMER_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for HSTIMER
            /// 0: Mask
            /// 1: Pass
            HSTIMER_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// HSTIMER Reset
            /// 0: Assert
            /// 1: De-assert
            HSTIMER_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x73c);

        /// address: 0x2001a10
        /// I2S_PCM0_CLK_REG
        pub const I2S_PCM0_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 The value of FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO0(4X)
            /// 10: PLL_AUDIO1(DIV2)
            /// 11: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON I2S/PCM0_CLK = Clock Source/M/N.
            @"I2S/PCM0_CLK_GATING": u1,
        }), base_address + 0xa10);

        /// address: 0x2001a14
        /// I2S_PCM1_CLK_REG
        pub const I2S_PCM1_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO0(4X)
            /// 10: PLL_AUDIO1(DIV2)
            /// 11: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON I2S/PCM1_CLK = Clock Source/M/N.
            @"I2S/PCM1_CLK_GATING": u1,
        }), base_address + 0xa14);

        /// address: 0x2001a1c
        /// I2S_PCM2_ASRC_CLK_REG
        pub const I2S_PCM2_ASRC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M = FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(4X)
            /// 01: PLL_PERI(1X)
            /// 10: PLL_AUDIO1(DIV2)
            /// 11: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON I2S/PCM2_ASRC_CLK = Clock Source/M/N.
            @"I2S/PCM2_ASRC_CLK_GATING": u1,
        }), base_address + 0xa1c);

        /// address: 0x2001a18
        /// I2S_PCM2_CLK_REG
        pub const I2S_PCM2_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO0(4X)
            /// 10: PLL_AUDIO1(DIV2)
            /// 11: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON I2S/PCM2_CLK = Clock Source/M/N.
            @"I2S/PCM2_CLK_GATING": u1,
        }), base_address + 0xa18);

        /// address: 0x2001a20
        /// I2S_PCM_BGR_REG
        pub const I2S_PCM_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for I2S/PCM0
            /// 0: Mask
            /// 1: Pass
            @"I2S/PCM0_GATING": u1,
            /// Gating Clock for I2S/PCM1
            /// 0: Mask
            /// 1: Pass
            @"I2S/PCM1_GATING": u1,
            /// Gating Clock for I2S/PCM2
            /// 0: Mask
            /// 1: Pass
            @"I2S/PCM2_GATING": u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// I2S/PCM0 Reset
            /// 0: Assert
            /// 1: De-assert
            @"I2S/PCM0_RST": u1,
            /// I2S/PCM1 Reset
            /// 0: Assert
            /// 1: De-assert
            @"I2S/PCM1_RST": u1,
            /// I2S/PCM2 Reset
            /// 0: Assert
            /// 1: De-assert
            @"I2S/PCM2_RST": u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa20);

        /// address: 0x20017bc
        /// IOMMU Bus Gating Reset Register
        pub const IOMMU_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for IOMMU
            /// 0: Mask
            /// 1: Pass
            IOMMU_GATING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x7bc);

        /// address: 0x20019cc
        /// IRTX Bus Gating Reset Register
        pub const IRTX_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for IRTX
            /// 0: Mask
            /// 1: Pass
            IRTX_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// IRTX Reset
            /// 0: Assert
            /// 1: De-assert
            IRTX_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x9cc);

        /// address: 0x20019c0
        /// IRTX Clock Register
        pub const IRTX_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 0: HOSC
            /// 1: PLL_PERI(1X)
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON IRTX_CLK = Clock Source/M/N.
            IRTX_CLK_GATING: u1,
        }), base_address + 0x9c0);

        /// address: 0x2001bfc
        /// LEDC Bus Gating Reset Register
        pub const LEDC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For LEDC
            /// 0: Mask
            /// 1: Pass
            LEDC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// LEDC Reset
            /// 0: Assert
            /// 1: De-assert
            LEDC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xbfc);

        /// address: 0x2001bf0
        /// LEDC Clock Register
        pub const LEDC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 0: HOSC
            /// 1: PLL_PERI(1X)
            CLK_SRC_SEL: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON LEDC_CLK = Clock Source/M/N.
            LDEC_CLK_GATING: u1,
        }), base_address + 0xbf0);

        /// address: 0x2001a9c
        /// LRADC_BGR_REG
        pub const LRADC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For LRADC
            /// 0: Mask
            /// 1: Pass
            LRADC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// LRADC Reset
            /// 0: Assert
            /// 1: De-assert
            LRADC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xa9c);

        /// address: 0x2001bac
        /// LVDS Bus Gating Reset Register
        pub const LVDS_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// LVDS0 Reset
            /// 0: Assert
            /// 1: De-assert
            LVDS0_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xbac);

        /// address: 0x2001540
        /// MBUS Clock Register
        pub const MBUS_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// MBUS Reset
            /// 0: Assert
            /// 1: De-assert
            MBUS_RST: u1,
            padding0: u1,
        }), base_address + 0x540);

        /// address: 0x2001804
        /// MBUS Master Clock Gating Register
        pub const MBUS_MAT_CLK_GATING_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating MBUS Clock For DMA
            /// 0: Mask
            /// 1: Pass
            DMA_MCLK_EN: u1,
            /// Gating MBUS Clock For VE
            /// 0: Mask
            /// 1: Pass
            VE_MCLK_EN: u1,
            /// Gating MBUS Clock For CE
            /// 0: Mask
            /// 1: Pass
            CE_MCLK_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Gating MBUS Clock For TVIN
            /// 0: Mask
            /// 1: Pass
            TVIN_MCLK_EN: u1,
            /// Gating MBUS Clock For CSI
            /// 0: Mask
            /// 1: Pass
            CSI_MCLK_EN: u1,
            reserved4: u1,
            /// Gating MBUS Clock For G2D
            /// 0: Mask
            /// 1: Pass
            G2D_MCLK_EN: u1,
            /// Gating MBUS Clock For RISC-V
            /// 0: Mask
            /// 1: Pass
            @"RISC-V_MCLK_EN": u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x804);

        /// address: 0x200171c
        /// MSGBOX Bus Gating Reset Register
        pub const MSGBOX_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Gating Clock for DSP MSGBOX
            /// 0: Mask
            /// 1: Pass
            MSGBOX1_GATING: u1,
            /// Gating Clock for RISC-V MSGBOX
            /// 0: Mask
            /// 1: Pass
            MSGBOX2_GATING: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DSP MSGBOX Reset
            /// 0: Assert
            /// 1: De-assert
            MSGBOX1_RST: u1,
            /// RISC-V MSGBOX Reset
            /// 0: Assert
            /// 1: De-assert
            MSGBOX2_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x71c);

        /// address: 0x2001a2c
        /// OWA Bus Gating Reset Register
        pub const OWA_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for OWA
            /// 0: Mask
            /// 1: Pass
            OWA_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// OWA Reset
            /// 0: Assert
            /// 1: De-assert
            OWA_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xa2c);

        /// address: 0x2001a28
        /// OWA_RX Clock Register
        pub const OWA_RX_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 000: PLL_PERI(1X)
            /// 001: PLL_AUDIO1(DIV2)
            /// 010: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON OWA_RX_CLK = Clock Source/M/N.
            OWA_RX_CLK_GATING: u1,
        }), base_address + 0xa28);

        /// address: 0x2001a24
        /// OWA_TX Clock Register
        pub const OWA_TX_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N
            /// 00: /1
            /// 01: /2
            /// 10: /4
            /// 11: /8
            FACTOR_N: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 00: PLL_AUDIO0(1X)
            /// 01: PLL_AUDIO0(4X)
            /// 10: PLL_AUDIO1(DIV2)
            /// 11: PLL_AUDIO1(DIV5)
            CLK_SRC_SEL: u3,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON OWA_TX_CLK = Clock Source/M/N.
            OWA_TX_CLK_GATING: u1,
        }), base_address + 0xa24);

        /// address: 0x2001f38
        /// PCLK FANOUT Register
        pub const PCLK_FAN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            PCLK_DIV: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// Gating for PCLK
            /// 0: Clock is OFF
            /// 1: Clock is ON PCLK = APB0_CLK/M.
            PCLK_DIV_EN: u1,
        }), base_address + 0xf38);

        /// address: 0x2001378
        /// PLL_AUDIO0 Bias Register
        pub const PLL_AUDIO0_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x378);

        /// address: 0x2001078
        /// PLL_AUDIO0 Control Register
        pub const PLL_AUDIO0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL Output Div M0 M0=PLL_OUTPUT_DIV2 + 1 PLL_OUTPUT_DIV2 is from 0 to 1.
            PLL_OUTPUT_DIV2: u1,
            /// PLL Input Div M1 M1=PLL_INPUT_DIV2 + 1 PLL_INPUT_DIV2 is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            /// PLL Post-div P P= PLL_POST_DIV_P +1 PLL_POST_DIV_P is from 0 to 63.
            PLL_P: u6,
            reserved3: u1,
            reserved4: u1,
            /// PLL SDM Enable
            /// 0: Disable
            /// 1: Enable Enable spread spectrum and decimal division.
            PLL_SDM_EN: u1,
            reserved5: u1,
            reserved6: u1,
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable PLL_AUDIO0(4X) = 24MHz*N/M1/M0/P PLL_AUDIO0(2X) = (24MHz*N/M1/M0)/P/2
            /// PLL_AUDIO0(1X) = (24MHz*N/M1/M0)/P/4 The working frequency range of
            /// 24MHz*N/M0/M1 is from 180 MHz to 3.0 GHz. The default frequency of
            /// PLL_AUDIO0(1X) is 24.5714 MHz.
            PLL_EN: u1,
        }), base_address + 0x78);

        /// address: 0x2001178
        /// PLL_AUDIO0 Pattern0 Control Register
        pub const PLL_AUDIO0_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x178);

        /// address: 0x200117c
        /// PLL_AUDIO0 Pattern1 Control Register
        pub const PLL_AUDIO0_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x17c);

        /// address: 0x2001380
        /// PLL_AUDIO1 Bias Register
        pub const PLL_AUDIO1_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x380);

        /// address: 0x2001080
        /// PLL_AUDIO1 Control Register
        pub const PLL_AUDIO1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PLL Input Div M M=PLL_INPUT_DIV_M + 1 PLL_INPUT_DIV_M is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            /// PLL Output Div P0 P0=PLL_OUTPUT_DIV_P0 + 1 PLL_OUTPUT_DIV_P0 is from 0 to 7.
            PLL_P0: u3,
            reserved4: u1,
            /// PLL Output Div P1 P1=PLL_OUTPUT_DIV_P1 + 1 PLL_OUTPUT_DIV_P1 is from 0 to 7.
            PLL_P1: u3,
            reserved5: u1,
            /// 0: Disable
            /// 1: Enable Enable spread spectrum and decimal division.
            PLL_SDM_EN: u1,
            reserved6: u1,
            reserved7: u1,
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of PLL.
            PLL_OUTPUT_GATE: u1,
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable PLL_AUDIO1 = 24MHz*N/M PLL_AUDIO1(DIV2) = 24MHz*N/M/P0
            /// PLL_AUDIO1(DIV5) = 24MHz*N/M/P1 The working frequency range of 24 MHz/M*N is
            /// from 180 MHz to 3.5 GHz. The default frequency of PLL_AUDIO1 is 3072 MHz. The
            /// default frequency of PLL_AUDIO1(DIV2) is 1536 MHz. The default frequency of
            /// PLL_AUDIO1(DIV5) is 614.4 MHz (24.576 MHz*25).
            PLL_EN: u1,
        }), base_address + 0x80);

        /// address: 0x2001180
        /// PLL_AUDIO1 Pattern0 Control Register
        pub const PLL_AUDIO1_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x180);

        /// address: 0x2001184
        /// PLL_AUDIO1 Pattern1 Control Register
        pub const PLL_AUDIO1_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x184);

        /// address: 0x2001300
        /// PLL_CPU Bias Register
        pub const PLL_CPU_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL current bias control
            PLL_CP: u5,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// VCO reset in
            PLL_VCO_RST_IN: u1,
        }), base_address + 0x300);

        /// address: 0x2001000
        /// PLL_CPU Control Register
        pub const PLL_CPU_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL_M M = PLL_FACTOR_M + 1 PLL_FACTOR_M is from 0 to 3.
            PLL_M: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PLL Lock Time The bit indicates the step amplitude from one frequency to
            /// another.
            PLL_LOCK_TIME: u3,
            /// PLL Output Gating Enable
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of the PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock Status
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable PLL_CPU= InputFreq*N.
            PLL_EN: u1,
        }), base_address + 0x0);

        /// address: 0x2001400
        /// PLL_CPU Tuning Register
        pub const PLL_CPU_TUN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL-B-OUT [6:0] for verify
            PLL_B_OUT: u7,
            /// PLL-REG-OD1 for verify
            PLL_REG_OD1: u1,
            /// PLL-B-IN [6:0] for verify
            PLL_B_IN: u7,
            /// PLL-REG-OD0 for verify
            PLL_REG_OD: u1,
            /// Counter initial control
            PLL_CNT_INT: u7,
            reserved0: u1,
            /// KVCO gain control
            PLL_VCO_GAIN: u3,
            reserved1: u1,
            /// VCO range control
            PLL_VCO: u3,
            padding0: u1,
        }), base_address + 0x400);

        /// address: 0x2001310
        /// PLL_DDR Bias Register
        pub const PLL_DDR_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x310);

        /// address: 0x2001010
        /// PLL_DDR Control Register
        pub const PLL_DDR_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL Output Div M0 M0=PLL_OUTPUT_DIV2 + 1 PLL_OUTPUT_DIV2 is from 0 to 1.
            PLL_OUTPUT_DIV2: u1,
            /// PLL Input Div M1 M1=PLL_INPUT_DIV2 + 1 PLL_INPUT_DIV2 is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PLL SDM Enable
            /// 0: Disable
            /// 1: Enable
            PLL_SDM_EN: u1,
            reserved11: u1,
            reserved12: u1,
            /// PLL Output Gating Enable
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of the PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO ENABLE
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// 0: Disable
            /// 1: Enable PLL_DDR = InputFreq*N/M1/M0.
            PLL_EN: u1,
        }), base_address + 0x10);

        /// address: 0x2001110
        /// PLL_DDR Pattern0 Control Register
        pub const PLL_DDR_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x110);

        /// address: 0x2001114
        /// PLL_DDR Pattern1 Control Register
        pub const PLL_DDR_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x114);

        /// address: 0x2001f04
        /// PLL Lock Debug Control Register
        pub const PLL_LOCK_DBG_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Debug Select
            /// 000: PLL_CPUX
            /// 001: PLL_DDR
            /// 010: PLL_PERI(2X)
            /// 011: PLL_VIDEO0(4X)
            /// 100: PLL_VIDEO1(4X)
            /// 101: PLL_VE
            /// 110: PLL_AUDIO0
            /// 111: PLL_AUDIO1 Others: /
            PLL_LOCK_FLAG_SEL: u3,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// Debug Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LOCK_FLAG_EN: u1,
        }), base_address + 0xf04);

        /// address: 0x2001320
        /// PLL_PERI Bias Register
        pub const PLL_PERI_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x320);

        /// address: 0x2001020
        /// PLL_PERI Control Register
        pub const PLL_PERI_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// PLL Input Div M M1=PLL_INPUT_DIV2 + 1 PLL_INPUT_DIV2 is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            /// PLL Output Div P0 P0=PLL_OUTPUT_DIV_P0 + 1 PLL_OUTPUT_DIV_P0 is from 0 to 7.
            PLL_P0: u3,
            reserved4: u1,
            /// PLL Output Div P1 P1=PLL_OUTPUT_DIV_P1 + 1 PLL_OUTPUT_DIV_P1 is from 0 to 7.
            PLL_P1: u3,
            reserved5: u1,
            /// PLL SDM Enable
            /// 0: Disable
            /// 1: Enable Enable spread spectrum and decimal division.
            PLL_SDM_EN: u1,
            reserved6: u1,
            reserved7: u1,
            /// PLL Output Gating Enable
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable PLL_PERI(2X) = 24 MHz*N/M/P0 PLL_PERI(1X) = 24 MHz*N/M/P0/2
            /// PLL_PERI(800M) = 24 MHz*N/M/P1. When the crystal oscillator is 24 MHz, the
            /// default frequency of PLL_PERI(2X) is 1.2 GHz, the default frequency of
            /// PLL_PERI(1X) is 600 MHz, and the default frequency of PLL_PERI(800M) is 800 MHz.
            PLL_EN: u1,
        }), base_address + 0x20);

        /// address: 0x2001120
        /// PLL_PERI Pattern0 Control Register
        pub const PLL_PERI_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x120);

        /// address: 0x2001124
        /// PLL_PERI Pattern1 Control Register
        pub const PLL_PERI_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x124);

        /// address: 0x2001358
        /// PLL_VE Bias Register
        pub const PLL_VE_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x358);

        /// address: 0x2001058
        /// PLL_VE Control Register
        pub const PLL_VE_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL Output Div M0 M0=PLL_OUTPUT_DIV2 + 1 PLL_OUTPUT_DIV2 is from 0 to 1.
            PLL_OUTPUT_DIV2: u1,
            /// PLL Input Div M1 M1=PLL_INPUT_DIV2 + 1 PLL_INPUT_DIV2 is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PLL SDM Enable
            /// 0: Disable
            /// 1: Enable
            PLL_SDM_EN: u1,
            reserved11: u1,
            reserved12: u1,
            /// PLL Output Gating Enable
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable PLL_VE = InputFreq*N/M1/M0. When the HOSC is 24 MHz, the default
            /// frequency of PLL_VE is 432 MHz.
            PLL_EN: u1,
        }), base_address + 0x58);

        /// address: 0x2001158
        /// PLL_VE Pattern0 Control Register
        pub const PLL_VE_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x158);

        /// address: 0x200115c
        /// PLL_VE Pattern1 Control Register
        pub const PLL_VE_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x15c);

        /// address: 0x2001340
        /// PLL_VIDEO0 Bias Register
        pub const PLL_VIDEO0_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x340);

        /// address: 0x2001040
        /// PLL_VIDEO0 Control Register
        pub const PLL_VIDEO0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL Output Div D (The factor is only for testing) M0=PLL_OUTPUT_DIV_D + 1
            /// PLL_OUTPUT_DIV_D is from 0 to 1. For test, PLL_VIDEO0(4X) =24MHz*N/M/D
            PLL_OUTPUT_DIV2: u1,
            /// PLL Input Div M M1=PLL_INPUT_DIV_M + 1 PLL_INPUT_DIV_M is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL N N= PLL_N +1 PLL_N is from 0 to 254. In application, PLL_N shall be more
            /// than or equal to 12.
            PLL_N: u8,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PLL SDM Enable
            /// 0: Disable
            /// 1: Enable
            PLL_SDM_EN: u1,
            reserved11: u1,
            reserved12: u1,
            /// PLL Output Gating Enable
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable For application, PLL_VIDEO0(4X)=InputFreq *N/M. PLL_VIDEO0(2X)=
            /// InputFreq *N/M/2. PLL_VIDEO0(1X)= InputFreq *N/M/4. When the HOSC is 24 MHz, the
            /// default frequency of PLL_VIDEO0(4X) is 1188 MHz.
            PLL_EN: u1,
        }), base_address + 0x40);

        /// address: 0x2001140
        /// PLL_VIDEO0 Pattern0 Control Register
        pub const PLL_VIDEO0_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x140);

        /// address: 0x2001144
        /// PLL_VIDEO0 Pattern1 Control Register
        pub const PLL_VIDEO0_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x144);

        /// address: 0x2001348
        /// PLL_VIDEO1 Bias Register
        pub const PLL_VIDEO1_BIAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// PLL bias control
            PLL_CP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x348);

        /// address: 0x2001048
        /// PLL_VIDEO1 Control Register
        pub const PLL_VIDEO1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL Output Div D.(The factor is only for testing) M0=PLL_OUTPUT_DIV_D + 1
            /// PLL_OUTPUT_DIV_D is from 0 to 1. For test, PLL_VIDEO1(4X) =24MHz*N/M/D
            PLL_OUTPUT_DIV2: u1,
            /// PLL Input Div M M1=PLL_INPUT_DIV_M + 1 PLL_INPUT_DIV_M is from 0 to 1.
            PLL_INPUT_DIV2: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// PLL Lock Level
            /// 0: 24-26 Clock Cycles
            /// 1: 23-27 Clock Cycles
            PLL_LOCK_MDSEL: u1,
            /// PLL Unlock Level
            /// 00: 21-29 Clock Cycles
            /// 01: 22-28 Clock Cycles 1X: 20-30 Clock Cycles
            PLL_UNLOCK_MDSEL: u2,
            /// PLL FACTOR N N= PLL_FACTOR_N +1 PLL_FACTOR_N is from 0 to 254. In application,
            /// PLL_FACTOR_N shall be more than or equal to 12.
            PLL_FACTOR_N: u8,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PLL SDM Enable
            /// 0: Disable
            /// 1: Enable
            PLL_SDM_EN: u1,
            reserved11: u1,
            reserved12: u1,
            /// PLL Output Gating Enable
            /// 0: Disable
            /// 1: Enable The bit is used to control the output enable of PLL.
            PLL_OUTPUT_GATE: u1,
            /// PLL Lock
            /// 0: Unlocked
            /// 1: Locked (It indicates that the PLL has been stable.)
            LOCK: u1,
            /// Lock Enable
            /// 0: Disable
            /// 1: Enable
            LOCK_ENABLE: u1,
            /// LDO Enable
            /// 0: Disable
            /// 1: Enable
            PLL_LDO_EN: u1,
            /// PLL Enable
            /// 0: Disable
            /// 1: Enable For application, PLL_VIDEO1(4X)=InputFreq *N/M. PLL_VIDEO1(2X)=
            /// InputFreq *N/M/2. PLL_VIDEO1(1X)= InputFreq *N/M/4. When the HOSC is 24 MHz, the
            /// default frequency of PLL_VIDEO1(4X) is 1188 MHz.
            PLL_EN: u1,
        }), base_address + 0x48);

        /// address: 0x2001148
        /// PLL_VIDEO1 Pattern0 Control Register
        pub const PLL_VIDEO1_PAT0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wave Bottom
            WAVE_BOT: u17,
            /// Frequency
            /// 00: 31.5 kHz
            /// 01: 32 kHz
            /// 10: 32.5 kHz
            /// 11: 33 kHz
            FREQ: u2,
            /// SDM Clock Select
            /// 0: 24 MHz
            /// 1: 12 MHz
            SDM_CLK_SEL: u1,
            /// Wave Step
            WAVE_STEP: u9,
            /// Spread Frequency Mode
            /// 00: DC=0
            /// 01: DC=1
            /// 10: Triangular(1-bit)
            /// 11: Triangular(n-bit)
            SPR_FREQ_MODE: u2,
            /// Sigma-Delta Pattern Enable
            SIG_DELT_PAT_EN: u1,
        }), base_address + 0x148);

        /// address: 0x200114c
        /// PLL_VIDEO1 Pattern1 Control Register
        pub const PLL_VIDEO1_PAT1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fraction In
            FRAC_IN: u17,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fraction Enable
            FRAC_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Dither Enable
            DITHER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x14c);

        /// address: 0x2001510
        /// PSI Clock Register
        pub const PSI_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M. M= FACTOR_M +1 FACTOR_M is from 0 to 3.
            FACTOR_M: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: CLK32K
            /// 010: CLK16M_RC
            /// 011: PLL_PERI(1X) PSI_CLK = Clock Source/M/N.
            CLK_SRC_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x510);

        /// address: 0x20017ac
        /// PWM Bus Gating Reset Register
        pub const PWM_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for PWM
            /// 0: Mask
            /// 1: Pass
            PWM_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// PWM Reset
            /// 0: Assert
            /// 1: De-assert
            PWM_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x7ac);

        /// address: 0x2001d0c
        /// RISC_V_CFG_BGR_REG
        pub const RISC_V_CFG_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For RISC-V
            /// 0: Mask
            /// 1: Pass
            @"RISC-V_CFG_GATING": u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// RISC-V Reset
            /// 0: Assert
            /// 1: De-assert
            @"RISC-V_CFG_RST": u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xd0c);

        /// address: 0x2001d00
        /// RISC_V_CLK_REG
        pub const RISC_V_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M = FACTOR_M +1 FACTOR_M is from 0 to 31.
            @"RISC-V_DIV_CFG": u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Factor N N = FACTOR_N +1 FACTOR_N is from 1 to 3.
            @"RISC-V_AXI_DIV_CFG": u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: CLK32K
            /// 010: CLK16M_RC
            /// 011: PLL_PERI(800M)
            /// 100: PLL_PERI(1X)
            /// 101: PLL_CPU
            /// 110: PLL_AUDIO1(DIV2) RISC-V Clock = Clock Source/M. RISC-V_AXI Clock = RISC-V
            /// Clock/N.
            @"RISC-V_CLK_SEL": u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xd00);

        /// address: 0x2001d04
        /// RISC_V_GATING_REG
        pub const RISC_V_GATING_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// If RISC-V_gating_field == 16’h16AA, the bit 31 can be configured.
            @"RISC-V_GATING_FIELD": u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Gating Special Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON
            @"RISC-V_GATING": u1,
        }), base_address + 0xd04);

        /// address: 0x2001830
        /// SMHC0 Clock Register
        pub const SMHC0_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M = FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_PERI(2X)
            /// 011: PLL_AUDIO1(DIV2) Others: Reserved
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON SMHC0_CLK = Clock Source/M/N.
            SMHC0_CLK_GATING: u1,
        }), base_address + 0x830);

        /// address: 0x2001834
        /// SMHC1 Clock Register
        pub const SMHC1_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_PERI(2X)
            /// 011: PLL_AUDIO1(DIV2) Others: Reserved
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON SCLK = Clock Source/M/N.
            SMHC1_CLK_GATING: u1,
        }), base_address + 0x834);

        /// address: 0x2001838
        /// SMHC2 Clock Register
        pub const SMHC2_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_PERI(2X)
            /// 011: PLL_PERI(800M)
            /// 100: PLL_AUDIO1(DIV2) Others: Reserved
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON SCLK = Clock Source/M/N.
            SMHC2_CLK_GATING: u1,
        }), base_address + 0x838);

        /// address: 0x200184c
        /// SMHC Bus Gating Reset Register
        pub const SMHC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for SMHC0
            /// 0: Mask
            /// 1: Pass
            SMHC0_GATING: u1,
            /// Gating Clock for SMHC1
            /// 0: Mask
            /// 1: Pass
            SMHC1_GATING: u1,
            /// Gating Clock for SMHC2
            /// 0: Mask
            /// 1: Pass
            SMHC2_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// SMHC0 Reset
            /// 0: Assert
            /// 1: De-assert
            SMHC0_RST: u1,
            /// SMHC1 Reset
            /// 0: Assert
            /// 1: De-assert
            SMHC1_RST: u1,
            /// SMHC2 Reset
            /// 0: Assert
            /// 1: De-assert
            SMHC2_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x84c);

        /// address: 0x2001940
        /// SPI0 Clock Register
        pub const SPI0_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_PERI(2X)
            /// 011: PLL_AUDIO1(DIV2)
            /// 100: PLL_AUDIO1(DIV5) Others: Reserved
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON SCLK = Clock Source/M/N.
            SPI0_CLK_GATING: u1,
        }), base_address + 0x940);

        /// address: 0x2001944
        /// SPI1 Clock Register
        pub const SPI1_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_PERI(1X)
            /// 010: PLL_PERI(2X)
            /// 011: PLL_AUDIO1(DIV2)
            /// 100: PLL_AUDIO1(DIV5) Others: /
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Special Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON SCLK = Clock Source/M/N.
            SCLK_GATING: u1,
        }), base_address + 0x944);

        /// address: 0x200172c
        /// SPINLOCK Bus Gating Reset Register
        pub const SPINLOCK_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For SPINLOCK
            /// 0: Mask
            /// 1: Pass
            SPINLOCK_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// SPINLOCK Reset
            /// 0: Assert
            /// 1: De-assert
            SPINLOCK_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x72c);

        /// address: 0x200196c
        /// SPI Bus Gating Reset Register
        pub const SPI_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for SPI0
            /// 0: Mask
            /// 1: Pass
            SPI0_GATING: u1,
            /// Gating Clock for SPI1
            /// 0: Mask
            /// 1: Pass
            SPI1_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// SPI0 Reset
            /// 0: Assert
            /// 1: De-assert
            SPI0_RST: u1,
            /// SPI1 Reset
            /// 0: Assert
            /// 1: De-assert
            SPI1_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x96c);

        /// address: 0x2001b7c
        /// TCONLCD Bus Gating Reset Register
        pub const TCONLCD_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For TCON LCD
            /// 0: Mask
            /// 1: Pass
            TCONLCD_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TCON LCD Reset
            /// 0: Assert
            /// 1: DE-assert
            TCONLCD_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xb7c);

        /// address: 0x2001b60
        /// TCONLCD Clock Register
        pub const TCONLCD_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1. FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: PLL_VIDEO0(1X)
            /// 001: PLL_VIDEO0(4X)
            /// 010: PLL_VIDEO1(1X)
            /// 011: PLL_VIDEO1(4X)
            /// 100: PLL_PERI(2X)
            /// 101: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON TCONLCD_CLK = Clock Source/M/N.
            TCONLCD_CLK_GATING: u1,
        }), base_address + 0xb60);

        /// address: 0x2001b9c
        /// TCONTV Bus Gating Reset Register
        pub const TCONTV_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For TCONTV
            /// 0: Mask
            /// 1: Pass
            TCONTV_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TCONTV Reset
            /// 0: Assert
            /// 1: De-assert
            TCONTV_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xb9c);

        /// address: 0x2001b80
        /// TCONTV Clock Register
        pub const TCONTV_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: PLL_VIDEO0(1X)
            /// 001: PLL_VIDEO0(4X)
            /// 010: PLL_VIDEO1(1X)
            /// 011: PLL_VIDEO1(4X)
            /// 100: PLL_PERI(2X)
            /// 101: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON TCONTV_CLK = Clock Source/M/N.
            TCONTV_CLK_GATING: u1,
        }), base_address + 0xb80);

        /// address: 0x20019fc
        /// THS Bus Gating Reset Register
        pub const THS_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For THS
            /// 0: Mask
            /// 1: Pass
            THS_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// THS Reset
            /// 0: Assert
            /// 1: De-assert
            THS_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x9fc);

        /// address: 0x2001c5c
        /// TPADC Bus Gating Reset Register
        pub const TPADC_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For TPADC
            /// 0: Mask
            /// 1: Pass
            TPADC_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TPADC Reset
            /// 0: Assert
            /// 1: De-assert
            TPADC_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc5c);

        /// address: 0x2001c50
        /// TPADC Clock Register
        pub const TPADC_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_AUDIO0(1X)
            CLK_SRC_SEL: u3,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON TPADC_CLK = Clock Source.
            TPADC_CLK_GATING: u1,
        }), base_address + 0xc50);

        /// address: 0x2001bdc
        /// TVD Bus Gating Reset Register
        pub const TVD_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For TVD_TOP
            /// 0: Mask
            /// 1: Pass
            TVD_TOP_GATING: u1,
            /// Gating Clock For TVD
            /// 0: Mask
            /// 1: Pass
            TVD_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// TVD_TOP Reset
            /// 0: Assert
            /// 1: De-assert
            TVD_TOP_RST: u1,
            /// TVD Reset
            /// 0: Assert
            /// 1: De-assert
            TVD_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xbdc);

        /// address: 0x2001bc0
        /// TVD Clock Register
        pub const TVD_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 000: HOSC
            /// 001: PLL_VIDEO0(1X)
            /// 010: PLL_VIDEO1(1X)
            /// 011: PLL_PERI(1X)
            CLK_SRC_SEL: u3,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Gating Special Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON TVD_CLK = Clock Source/M.
            TVD_CLK_GATING: u1,
        }), base_address + 0xbc0);

        /// address: 0x2001bbc
        /// TVE Bus Gating Reset Register
        pub const TVE_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For TVE_TOP
            /// 0: Mask
            /// 1: Pass
            TVE_TOP_GATING: u1,
            /// Gating Clock For TVE
            /// 0: Mask
            /// 1: Pass
            TVE_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// TVE_TOP Reset
            /// 0: Assert
            /// 1: De-assert
            TVE_TOP_RST: u1,
            /// TVE Reset
            /// 0: Assert
            /// 1: De-assert
            TVE_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xbbc);

        /// address: 0x2001bb0
        /// TVE Clock Register
        pub const TVE_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 15.
            FACTOR_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Factor N
            /// 00: 1
            /// 01: 2
            /// 10: 4
            /// 11: 8
            FACTOR_N: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Clock Source Select
            /// 000: PLL_VIDEO0(1X)
            /// 001: PLL_VIDEO0(4X)
            /// 010: PLL_VIDEO1(1X)
            /// 011: PLL_VIDEO1(4X)
            /// 100: PLL_PERI(2X)
            /// 101: PLL_AUDIO1(DIV2)
            CLK_SRC_SEL: u3,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON TVE_CLK = Clock Source/M/N.
            TVE_CLK_GATING: u1,
        }), base_address + 0xbb0);

        /// address: 0x200191c
        /// TWI Bus Gating Reset Register
        pub const TWI_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for TWI0
            /// 0: Mask
            /// 1: Pass
            TWI0_GATING: u1,
            /// Gating Clock for TWI1
            /// 0: Mask
            /// 1: Pass
            TWI1_GATING: u1,
            /// Gating Clock for TWI2
            /// 0: Mask
            /// 1: Pass
            TWI2_GATING: u1,
            /// Gating Clock for TWI3
            /// 0: Mask
            /// 1: Pass
            TWI3_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// TWI0 Reset
            /// 0: Assert
            /// 1: De-assert
            TWI0_RST: u1,
            /// TWI1 Reset
            /// 0: Assert
            /// 1: De-assert
            TWI1_RST: u1,
            /// TWI2 Reset
            /// 0: Assert
            /// 1: De-assert
            TWI2_RST: u1,
            /// TWI3 Reset
            /// 0: Assert
            /// 1: De-assert
            TWI3_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x91c);

        /// address: 0x200190c
        /// UART Bus Gating Reset Register
        pub const UART_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock for UART0
            /// 0: Mask
            /// 1: Pass
            UART0_GATING: u1,
            /// Gating Clock for UART1
            /// 0: Mask
            /// 1: Pass
            UART1_GATING: u1,
            /// Gating Clock for UART2
            /// 0: Mask
            /// 1: Pass
            UART2_GATING: u1,
            /// Gating Clock for UART3
            /// 0: Mask
            /// 1: Pass
            UART3_GATING: u1,
            /// Gating Clock for UART4
            /// 0: Mask
            /// 1: Pass
            UART4_GATING: u1,
            /// Gating Clock for UART5
            /// 0: Mask
            /// 1: Pass
            UART5_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// UART0 Reset
            /// 0: Assert
            /// 1: De-assert
            UART0_RST: u1,
            /// UART1 Reset
            /// 0: Assert
            /// 1: De-assert
            UART1_RST: u1,
            /// UART2 Reset
            /// 0: Assert
            /// 1: De-assert
            UART2_RST: u1,
            /// UART3 Reset
            /// 0: Assert
            /// 1: De-assert
            UART3_RST: u1,
            /// UART4 Reset
            /// 0: Assert
            /// 1: De-assert
            UART4_RST: u1,
            /// UART5 Reset
            /// 0: Assert
            /// 1: De-assert
            UART5_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x90c);

        /// address: 0x2001a70
        /// USB0 Clock Register
        pub const USB0_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// OHCI0 12M Source Select
            /// 00: 12M divided from 48 MHz
            /// 01: 12M divided from 24 MHz
            /// 10: RTC_32K
            /// 11: /
            USB0_CLK12M_SEL: u2,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// USB PHY0 Reset
            /// 0: Assert
            /// 1: De-assert
            USBPHY0_RSTN: u1,
            /// Gating Special Clock For OHCI0
            /// 0: Clock is OFF
            /// 1: Clock is ON
            USB0_CLKEN: u1,
        }), base_address + 0xa70);

        /// address: 0x2001a74
        /// USB1 Clock Register
        pub const USB1_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// OHCI0 12M Source Select
            /// 00: 12M divided from 48 MHz
            /// 01: 12M divided from 24 MHz
            /// 10: RTC_32K
            /// 11: /
            USB1_CLK12M_SEL: u2,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// USB PHY1 Reset
            /// 0: Assert
            /// 1: De-assert
            USBPHY1_RSTN: u1,
            /// Gating Special Clock For OHCI1
            /// 0: Clock is OFF
            /// 1: Clock is ON
            USB1_CLKEN: u1,
        }), base_address + 0xa74);

        /// address: 0x2001a8c
        /// USB Bus Gating Reset Register
        pub const USB_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For USBOHCI0
            /// 0: Mask
            /// 1: Pass
            USBOHCI0_GATING: u1,
            /// Gating Clock For USBOHCI1
            /// 0: Mask
            /// 1: Pass
            USBOHCI1_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            /// Gating Clock For USBEHCI0
            /// 0: Mask
            /// 1: Pass
            USBEHCI0_GATING: u1,
            /// Gating Clock For USBEHCI1
            /// 0: Mask
            /// 1: Pass
            USBEHCI1_GATING: u1,
            reserved2: u1,
            reserved3: u1,
            /// Gating Clock For USBDRD0
            /// 0: Mask
            /// 1: Pass
            USBDRD0_GATING: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// USBOHCI0 Reset
            /// 0: Assert
            /// 1: De-assert
            USBOHCI0_RST: u1,
            /// USBOHCI1 Reset
            /// 0: Assert
            /// 1: De-assert
            USBOHCI1_RST: u1,
            reserved11: u1,
            reserved12: u1,
            /// USBEHCI0 Reset
            /// 0: Assert
            /// 1: De-assert
            USBEHCI0_RST: u1,
            /// USBEHCI1 Reset
            /// 0: Assert
            /// 1: De-assert
            USBEHCI1_RST: u1,
            reserved13: u1,
            reserved14: u1,
            /// USBDRD0 Reset
            /// 0: Assert
            /// 1: De-assert
            USBDRD0_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xa8c);

        /// address: 0x200169c
        /// VE Bus Gating Reset Register
        pub const VE_BGR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating Clock For VE_PROT
            /// 0: Mask
            /// 1: Pass
            VE_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// VE Reset For VE_PROT
            /// 0: Assert
            /// 1: DE-assert
            VE_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x69c);

        /// address: 0x2001690
        /// VE Clock Register
        pub const VE_CLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Factor M M= FACTOR_M +1 FACTOR_M is from 0 to 31.
            FACTOR_M: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Clock Source Select
            /// 0: PLL_VE
            /// 1: PLL_PERI(2X)
            CLK_SRC_SEL: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// Gating Clock
            /// 0: Clock is OFF
            /// 1: Clock is ON VE_CLK = Clock Source/M.
            VE_CLK_GATING: u1,
        }), base_address + 0x690);
    };

    /// I2S/PCM0
    pub const @"I2S/PCM0" = struct {
        pub const base_address = 0x2032000;

        /// address: 0x203208c
        /// ASRCEN
        pub const ASRCEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Function Enable
            /// 0: Disabled
            /// 1: Enabled
            ASRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8c);

        /// address: 0x2032098
        /// ASRC FIFO Level Status Register
        pub const ASRCFIFOSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC RXFIFO Full Level The manually-configured FIFO fill level for the ratio
            /// value of the received data.
            ASRC_RX_FIFO_FULL_LEVAL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x98);

        /// address: 0x2032090
        /// ASRC Manual Ratio Configuration Register
        pub const ASRCMANCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC Ratio Value Manual Configure The ratio value is an unsigned 26-bit number
            /// and uses 4.22 data format, which means there are 4 bits to the left of the
            /// decimal point and 22 bits to the right of the decimal point.
            ASRC_RATIO_VALUE_MANUAL_CFG: u26,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Manual Configuration of ASRC Ratio Enable
            /// 0: Disabled
            /// 1: Enabled
            ASRC_RATIO_MANUAL_EN: u1,
        }), base_address + 0x90);

        /// address: 0x203209c
        /// ASRC MBIST Test Configuration Register
        pub const ASRCMBISTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC ROM BIST Enable Enable the ROM BIST.
            ASRC_ROM_BIST_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ASRC RAM BIST Enable Enable the RAM BIST.
            ASRC_RAM_BIST_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x9c);

        /// address: 0x20320a0
        /// ASRCMBISTSTA
        pub const ASRCMBISTSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RAM busy status
            /// 1: RAM busy
            /// 0: RAM idle
            RAM_BUSY_STATUS: u1,
            /// RAM stop status
            /// 1: Stop
            /// 0: Running
            RAM_STOP_STATUS: u1,
            /// RAM BIST error cycle
            RAM_BIST_ERROR_CYCLE: u2,
            /// RAM BIST error pattern
            RAM_BIST_ERROR_PATTERN: u3,
            /// RAM BIST error status
            /// 1: Error
            /// 0: No effect
            RAM_BIST_ERR_STATUS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// ROM BUSY STATUS
            /// 1: ROM busy
            /// 0: ROM idle
            ROM_BUSY_STATUS: u1,
            /// ROM BIST error sum
            ROM_BIST_ERROR_SUM: u1,
            /// ROM BIST error xor
            ROM_BIST_ERROR_XOR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x2032094
        /// ASRC Status Register
        pub const ASRCRATIOSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Adaptive Ratio Computational Value
            ADAPT_COMPUT_VALUE: u26,
            reserved0: u1,
            reserved1: u1,
            /// Adaptive Ratio Computational Lock
            /// 0: Unlocked
            /// 1: Locked
            ADAPT_COMPUT_LOCK: u1,
            /// ASRC Receive Data Buffer Overflow State It can control the mute with lock.
            /// 0: No overflow
            /// 1: Overflow
            ASRC_BUF_OVERFLOW_STA: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x94);

        /// address: 0x2032088
        /// ASRC Input Sample Pulse Extend Configuration Register
        pub const FsinEXTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Extend Enable
            /// 0: Disabled
            /// 1: Enabled Enable the bit when using ASRC.
            EXTEND_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x88);

        /// address: 0x2032030
        /// I2S_PCM_CHCFG
        pub const I2S_PCM_CHCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Channel/Slot number between CPU/DMA and TXFIFO
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ... 1111:16 channels or slots
            TX_SLOT_NUM: u4,
            /// RX Channel/Slot number between CPU/DMA and RXFIFO
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            RX_SLOT_NUM: u4,
            /// 0: Transfer level 0 in non-transferring slot
            /// 1: Turn to Hi-Z State (TDM) in non-transferring slot
            TX_STATE: u1,
            /// 0: Normal mode for the last half-cycle of BCLK in the slot
            /// 1: Turn to Hi-Z state for the last half-cycle of BCLK in the slot
            TX_SLOT_HIZ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x30);

        /// address: 0x2032024
        /// I2S_PCM_CLKD
        pub const I2S_PCM_CLKD = @intToPtr(*volatile Mmio(32, packed struct {
            /// MCLK Divide Ratio from PLL_AUDIO
            /// 0000: Reserved
            /// 0001: Divide by 1
            /// 0010: Divide by 2
            /// 0011: Divide by 4
            /// 0100: Divide by 6
            /// 0101: Divide by 8
            /// 0110: Divide by 12
            /// 0111: Divide by 16
            /// 1000: Divide by 24
            /// 1001: Divide by 32
            /// 1010: Divide by 48
            /// 1011: Divide by 64
            /// 1100: Divide by 96
            /// 1101: Divide by 128
            /// 1110: Divide by 176
            /// 1111: Divide by 192
            MCLKDIV: u4,
            /// BCLK Divide Ratio from PLL_AUDIO
            /// 0000: Reserved
            /// 0001: Divide by 1
            /// 0010: Divide by 2
            /// 0011: Divide by 4
            /// 0100: Divide by 6
            /// 0101: Divide by 8
            /// 0110: Divide by 12
            /// 0111: Divide by 16
            /// 1000: Divide by 24
            /// 1001: Divide by 32
            /// 1010: Divide by 48
            /// 1011: Divide by 64
            /// 1100: Divide by 96
            /// 1101: Divide by 128
            /// 1110: Divide by 176
            /// 1111: Divide by 192
            BCLKDIV: u4,
            /// 0: Disable MCLK Output
            /// 1: Enable MCLK Output Note: Whether in slave or master mode, when this bit is
            /// set to ‘1’, MCLK should be output.
            MCLKO_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x24);

        /// address: 0x2032000
        /// I2S_PCM_CTL
        pub const I2S_PCM_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Globe Enable
            /// 0: Disabled
            /// 1: Enabled
            GEN: u1,
            /// Receiver Block Enable
            /// 0: Disabled
            /// 1: Enabled
            RXEN: u1,
            /// Transmitter Block Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEN: u1,
            /// Loopback Test
            /// 0: Normal Mode
            /// 1: Loopback Test When set to ‘1’, the bit indicates that the DOUT is
            /// connected to the DIN.
            LOOP: u1,
            /// Mode Selection
            /// 00: PCM Mode (offset 0: Long Frame; offset 1: Short Frame)
            /// 01: Left Mode (offset 0: LJ Mode; offset 1: I2S Mode)
            /// 10: Right-Justified Mode
            /// 11: Reserved
            MODE_SEL: u2,
            /// Data Output Mute Enable
            /// 0: Normal Transfer
            /// 1: Force DOUT to output 0
            OUT_MUTE: u1,
            reserved0: u1,
            /// Data0 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT0_EN: u1,
            /// Data1 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT1_EN: u1,
            /// Data2 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT2_EN: u1,
            /// Data3 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT3_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LRCK Direction Select
            /// 0: Input
            /// 1: Output
            LRCK_OUT: u1,
            /// Bit Clock Direction Select
            /// 0: Input
            /// 1: Output
            BCLK_OUT: u1,
            reserved6: u1,
            /// I2S RX Synchronize Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN: u1,
            /// The bit takes effect only when RX_SYNC_EN is set to 1. I2S0/I2S1/I2S2/OWA RX
            /// Synchronize Enable Start.
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x0);

        /// address: 0x2032014
        /// I2S_PCM_FCTL
        pub const I2S_PCM_FCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Output Mode (Mode 0, 1, 2, 3)
            /// 00: Expanding ‘0’ at LSB of RXFIFO register
            /// 01: Expanding received sample sign bit at MSB of RXFIFO register
            /// 10: Truncating received samples at high half-word of RXFIFO register and low
            /// half-word of RXFIFO register is filled by ‘0’
            /// 11: Truncating received samples at low half-word of RXFIFO register and high
            /// half-word of RXFIFO register is expanded by its sign bit Example for 20-bit
            /// received audio sample: Mode 0: APB_RDATA[31:0] = {RXFIFO[31:12], 12’h0} Mode
            /// 1: APB_RDATA[31:0] = {12{RXFIFO[31]}, RXFIFO[31:12]} Mode 2: APB_RDATA [31:0] =
            /// {RXFIFO[31:16], 16’h0} Mode 3: APB_RDATA[31:0] = {16{RXFIFO[31],
            /// RXFIFO[31:16]}
            RXOM: u2,
            /// TXFIFO Input Mode (Mode 0, 1)
            /// 0: Valid data at the MSB of TXFIFO register
            /// 1: Valid data at the LSB of TXFIFO register Example for 20-bit transmitted audio
            /// sample: Mode 0: TXFIFO[31:0] = {APB_WDATA[31:12], 12’h0} Mode 1: TXFIFO[31:0]
            /// = {APB_WDATA[19:0], 12’h0}
            TXIM: u1,
            reserved0: u1,
            /// RXFIFO Trigger Level Interrupt and DMA request trigger level for RXFIFO normal
            /// condition. Trigger Level = RXTL + 1
            RXTL: u6,
            reserved1: u1,
            reserved2: u1,
            /// TXFIFO Empty Trigger Level Interrupt and DMA request trigger level for TXFIFO
            /// normal condition. Trigger Level = TXTL
            TXTL: u7,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write ‘1’ to flush RXFIFO, self clear to ‘0’.
            FRX: u1,
            /// Write ‘1’ to flush TXFIFO, self clear to ‘0’.
            FTX: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Audio Hub Enable The bit takes effect only when TXEN is set to 1.
            /// I2S0/I2S1/I2S2/OWA TXFIFO Hub Enable.
            /// 0: Disabled
            /// 1: Enabled
            HUB_EN: u1,
        }), base_address + 0x14);

        /// address: 0x2032004
        /// I2S_PCM_FMT0
        pub const I2S_PCM_FMT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slot Width Select
            /// 000: Reserved
            /// 001: 8-bit
            /// 010: 12-bit
            /// 011: 16-bit
            /// 100: 20-bit
            /// 101: 24-bit
            /// 110: 28-bit
            /// 111: 32-bit
            SW: u3,
            /// Edge Transfer
            /// 0: DOUT drives data and DIN sample data at the different BCLK edge
            /// 1: DOUT drives data and DIN sample data at the same BCLK edge BCLK_POLARITY = 0,
            /// EDGE_TRANSFER = 0, DIN sample data at positive edge; BCLK_POLARITY = 0,
            /// EDGE_TRANSFER = 1, DIN sample data at negative edge; BCLK_POLARITY = 1,
            /// EDGE_TRANSFER = 0, DIN sample data at negative edge; BCLK_POLARITY = 1,
            /// EDGE_TRANSFER = 1, DIN sample data at positive edge.
            EDGE_TRANSFER: u1,
            /// Sample Resolution
            /// 000: Reserved
            /// 001: 8-bit
            /// 010: 12-bit
            /// 011: 16-bit
            /// 100: 20-bit
            /// 101: 24-bit
            /// 110: 28-bit
            /// 111: 32-bit
            SR: u3,
            /// 0: Normal mode, DOUT drives data at negative edge
            /// 1: Invert mode, DOUT drives data at positive edge
            BCLK_POLARITY: u1,
            /// It is used to program the number of BCLKs per channel of the sample frame. This
            /// value is interpreted as follows. PCM mode: Number of BCLKs within (Left + Right)
            /// channel width. I2S/Left-Justified/Right-Justified mode: Number of BCLKs within
            /// each channel width (Left or Right). For example: N = 7: 8 BCLKs width … N =
            /// 1023: 1024 BCLKs width
            LRCK_PERIOD: u10,
            reserved0: u1,
            /// In I2S/Left-Justified/Right-Justified mode:
            /// 0: Left Channel when LRCK is low.
            /// 1: Left channel when LRCK is high. In PCM mode:
            /// 0: PCM LRCK asserted at the negative edge.
            /// 1: PCM LRCK asserted at the positive edge.
            LRCK_POLARITY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LRCK Width (only applies to the PCM mode)
            /// 0: LRCK = 1 BCLK Width (Short Frame)
            /// 1: LRCK = 2 BCLK Width (Long Frame)
            LRCK_WIDTH: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x2032008
        /// I2S_PCM_FMT1
        pub const I2S_PCM_FMT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCM Data Mode
            /// 00: Linear PCM
            /// 01: Reserved
            /// 10: 8-bit u-law
            /// 11: 8-bit A-law
            TX_PDM: u2,
            /// PCM Data Mode
            /// 00: Linear PCM
            /// 01: Reserved
            /// 10: 8-bit u-law
            /// 11: 8-bit A-law
            RX_PDM: u2,
            /// Sign Extend in Slot [Sample Resolution < Slot Width]
            /// 00: Zeros or audio gain padding at LSB position
            /// 01: Sign extension at MSB position
            /// 10: Reserved
            /// 11: Transfer 0 after each sample in each Slot
            SEXT: u2,
            /// MLS MSB/LSB First Select
            /// 0: MSB First
            /// 1: LSB First
            TX: u1,
            /// MLS MSB/LSB First Select
            /// 0: MSB First
            /// 1: LSB First
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x2032018
        /// I2S_PCM_FSTA
        pub const I2S_PCM_FSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO available sample word counter
            RXA_CNT: u7,
            /// NO Meaning
            PLACE_HOLDER: u1,
            /// RXFIFO Available
            /// 0: No available data in RXFIFO
            /// 1: More than one sample in RXFIFO (>= 1 Word)
            RXA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// TXFIFO Empty Space Word Counter
            TXE_CNT: u8,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TXFIFO Empty
            /// 0: No room for new sample in TXFIFO
            /// 1: More than one room for new sample in TXFIFO (>= 1 Word)
            TXE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x18);

        /// address: 0x203201c
        /// I2S_PCM_INT
        pub const I2S_PCM_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXAI_EN: u1,
            /// RXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXOI_EN: u1,
            /// RXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXUI_EN: u1,
            /// RXFIFO Data Available DRQ Enable
            /// 0: Disabled
            /// 1: Enabled When set to ‘1’, RXFIFO DMA request line is asserted if data is
            /// available in RXFIFO.
            RX_DRQ: u1,
            /// TXFIFO Empty Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEI_EN: u1,
            /// TXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled When set to ‘1’, an interrupt happens when writing new audio data
            /// if TXFIFO is full.
            TXOI_EN: u1,
            /// TXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXUI_EN: u1,
            /// TXFIFO Empty DRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            TX_DRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x203200c
        /// I2S_PCM_ISTA
        pub const I2S_PCM_ISTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Pending Interrupt
            /// 0: No pending IRQ
            /// 1: Data available pending IRQ when data in RXFIFO are more than RX trigger level
            RXA_INT: u1,
            /// RXFIFO Overrun Pending Interrupt
            /// 0: No pending IRQ
            /// 1: RXFIFO overrun pending IRQ Write ‘1’ to clear this interrupt.
            RXO_INT: u1,
            /// RXFIFO Underrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: RXFIFO underrun pending interrupt Write ‘1’ to clear this interrupt.
            RXU_INT: u1,
            reserved0: u1,
            /// TXFIFO Empty Pending Interrupt
            /// 0: No pending IRQ
            /// 1: TXFIFO empty pending interrupt when data in TXFIFO are less than TX trigger
            /// level
            TXE_INT: u1,
            /// TXFIFO Overrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: TXFIFO overrun pending interrupt Write ‘1’ to clear this interrupt.
            TXO_INT: u1,
            /// TXFIFO Underrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: TXFIFO underrun pending interrupt Write ‘1’ to clear this interrupt.
            TXU_INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x2032068
        /// I2S_PCM_RXCHMAP0
        pub const I2S_PCM_RXCHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH12_MAP: u4,
            /// RX Channel 12 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH12_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH13_MAP: u4,
            /// RX Channel 13 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH13_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH14_MAP: u4,
            /// RX Channel 14 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH14_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH15_MAP: u4,
            /// RX Channel 15 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH15_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x68);

        /// address: 0x203206c
        /// I2S_PCM_RXCHMAP1
        pub const I2S_PCM_RXCHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH8_MAP: u4,
            /// RX Channel 8 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH8_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH9_MAP: u4,
            /// RX Channel 9 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH9_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH10_MAP: u4,
            /// RX Channel 10 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH10_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH11_MAP: u4,
            /// RX Channel 11 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH11_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x6c);

        /// address: 0x2032070
        /// I2S_PCM_RXCHMAP2
        pub const I2S_PCM_RXCHMAP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH4_MAP: u4,
            /// RX Channel 4 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH4_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH5_MAP: u4,
            /// RX Channel 5 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH5_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH6_MAP: u4,
            /// RX Channel 6 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH6_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH7_MAP: u4,
            /// RX Channel 7 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH7_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x70);

        /// address: 0x2032074
        /// I2S_PCM_RXCHMAP3
        pub const I2S_PCM_RXCHMAP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH0_MAP: u4,
            /// RX Channel 0 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH0_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH1_MAP: u4,
            /// RX Channel 1 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH1_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH2_MAP: u4,
            /// RX Channel 2 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH2_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH3_MAP: u4,
            /// RX Channel 3 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH3_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x74);

        /// address: 0x2032064
        /// I2S_PCM_RXCHSEL
        pub const I2S_PCM_RXCHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// RX Channel (Slot) Number Select for Input
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            RX_CHSEL: u4,
            /// RX Offset Tune (RX Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            RX_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x64);

        /// address: 0x203202c
        /// I2S_PCM_RXCNT
        pub const I2S_PCM_RXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample Counter The audio sample number of writing into RXFIFO. When one
            /// sample is written by Digital Audio Engine, the RX sample counter register
            /// increases by one. The RX sample counter register can be set to any initial value
            /// at any time. After being updated by the initial value, the counter register
            /// should count on the base of this initial value.
            RX_CNT: u32,
        }), base_address + 0x2c);

        /// address: 0x2032010
        /// I2S_PCM_RXFIFO
        pub const I2S_PCM_RXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample The host can get one sample by reading this register. The left channel
            /// sample data is first and then the right channel sample.
            RX_DATA: u32,
        }), base_address + 0x10);

        /// address: 0x2032044
        /// I2S_PCM_TX0CHMAP0
        pub const I2S_PCM_TX0CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH8_MAP: u4,
            /// TX0 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH9_MAP: u4,
            /// TX0 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH10_MAP: u4,
            /// TX0 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH11_MAP: u4,
            /// TX0 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH12_MAP: u4,
            /// TX0 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH13_MAP: u4,
            /// TX0 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH14_MAP: u4,
            /// TX0 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH15_MAP: u4,
        }), base_address + 0x44);

        /// address: 0x2032048
        /// I2S_PCM_TX0CHMAP1
        pub const I2S_PCM_TX0CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH0_MAP: u4,
            /// TX0 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH1_MAP: u4,
            /// TX0 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH2_MAP: u4,
            /// TX0 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH3_MAP: u4,
            /// TX0 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH4_MAP: u4,
            /// TX0 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH5_MAP: u4,
            /// TX0 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH6_MAP: u4,
            /// TX0 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH7_MAP: u4,
        }), base_address + 0x48);

        /// address: 0x2032034
        /// I2S_PCM_TX0CHSEL
        pub const I2S_PCM_TX0CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel (Slot) Enable The bit[15:0] refer to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX0_CHEN: u16,
            /// TX0 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX0_CHSEL: u4,
            /// TX0 Offset Tune (TX0 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX0_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x34);

        /// address: 0x203204c
        /// I2S_PCM_TX1CHMAP0
        pub const I2S_PCM_TX1CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH8_MAP: u4,
            /// TX1 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH9_MAP: u4,
            /// TX1 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH10_MAP: u4,
            /// TX1 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH11_MAP: u4,
            /// TX1 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH12_MAP: u4,
            /// TX1 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH13_MAP: u4,
            /// TX1 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH14_MAP: u4,
            /// TX1 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH15_MAP: u4,
        }), base_address + 0x4c);

        /// address: 0x2032050
        /// I2S_PCM_TX1CHMAP1
        pub const I2S_PCM_TX1CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH0_MAP: u4,
            /// TX1 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH1_MAP: u4,
            /// TX1 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH2_MAP: u4,
            /// TX1 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH3_MAP: u4,
            /// TX1 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH4_MAP: u4,
            /// TX1 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH5_MAP: u4,
            /// TX1 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH6_MAP: u4,
            /// TX1 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH7_MAP: u4,
        }), base_address + 0x50);

        /// address: 0x2032038
        /// I2S_PCM_TX1CHSEL
        pub const I2S_PCM_TX1CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX1_CHEN: u16,
            /// TX1 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX1_CHSEL: u4,
            /// TX1 Offset Tune (TX1 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX1_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x2032054
        /// I2S_PCM_TX2CHMAP0
        pub const I2S_PCM_TX2CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH8_MAP: u4,
            /// TX2 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH9_MAP: u4,
            /// TX2 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH10_MAP: u4,
            /// TX2 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH11_MAP: u4,
            /// TX2 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH12_MAP: u4,
            /// TX2 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH13_MAP: u4,
            /// TX2 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH14_MAP: u4,
            /// TX2 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH15_MAP: u4,
        }), base_address + 0x54);

        /// address: 0x2032058
        /// I2S_PCM_TX2CHMAP1
        pub const I2S_PCM_TX2CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH0_MAP: u4,
            /// TX2 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH1_MAP: u4,
            /// TX2 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH2_MAP: u4,
            /// TX2 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH3_MAP: u4,
            /// TX2 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH4_MAP: u4,
            /// TX2 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH5_MAP: u4,
            /// TX2 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH6_MAP: u4,
            /// TX2 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH7_MAP: u4,
        }), base_address + 0x58);

        /// address: 0x203203c
        /// I2S_PCM_TX2CHSEL
        pub const I2S_PCM_TX2CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX2_CHEN: u16,
            /// TX2 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX2_CHSEL: u4,
            /// TX2 Offset Tune (TX2 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX2_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x3c);

        /// address: 0x203205c
        /// I2S_PCM_TX3CHMAP0
        pub const I2S_PCM_TX3CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH8_MAP: u4,
            /// TX3 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH9_MAP: u4,
            /// TX3 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH10_MAP: u4,
            /// TX3 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH11_MAP: u4,
            /// TX3 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH12_MAP: u4,
            /// TX3 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH13_MAP: u4,
            /// TX3 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH14_MAP: u4,
            /// TX3 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH15_MAP: u4,
        }), base_address + 0x5c);

        /// address: 0x2032060
        /// I2S_PCM_TX3CHMAP1
        pub const I2S_PCM_TX3CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH0_MAP: u4,
            /// TX3 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH1_MAP: u4,
            /// TX3 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH2_MAP: u4,
            /// TX3 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH3_MAP: u4,
            /// TX3 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH4_MAP: u4,
            /// TX3 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH5_MAP: u4,
            /// TX3 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH6_MAP: u4,
            /// TX3 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH7_MAP: u4,
        }), base_address + 0x60);

        /// address: 0x2032040
        /// I2S_PCM_TX3CHSEL
        pub const I2S_PCM_TX3CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX3_CHEN: u16,
            /// TX3 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX3_CHSEL: u4,
            /// TX3 Offset Tune (TX3 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX3_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x40);

        /// address: 0x2032028
        /// I2S_PCM_TXCNT
        pub const I2S_PCM_TXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Counter The audio sample number of sending into TXFIFO. When one
            /// sample is put into TXFIFO by DMA or by host IO, the TX sample counter register
            /// increases by one. The TX sample counter register can be set to any initial value
            /// at any time. After being updated by the initial value, the counter register
            /// should count on the base of this initial value.
            TX_CNT: u32,
        }), base_address + 0x28);

        /// address: 0x2032020
        /// I2S_PCM_TXFIFO
        pub const I2S_PCM_TXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Transmitting left, right channel sample data should be written to this
            /// register one by one. The left channel sample data is first and then the right
            /// channel sample.
            TX_DATA: u32,
        }), base_address + 0x20);

        /// address: 0x2032080
        /// ASRC MCLK Configuration Register
        pub const MCLKCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequency Division Coefficient 4’d0 = Res (no output), 4’d1 = 1x, 4’d2 =
            /// 1/2x, 4’d3 = 1/4x, 4’d4 = 1/6x, 4’d5 = 1/8x, 4’d6 = 1/12x, 4’d7 =
            /// 1/16x, 4’d8 = 1/24x, 4’d9 = 1/32x, 4’d10 = 1/48, 4’d11 = 1/64x, 4’d12
            /// = 1/96x, 4’d13 = 1/128x, 4’d14 = 1/176x, 4’d15 = 1/192x, others = Res
            ASRC_MCLK_FREQ_DIV_COE: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// ASRC Clock Gate Enable Control
            /// 0: Gated
            /// 1: Not gated
            ASRC_MCLK_GATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x80);
    };

    /// I2S/PCM1
    pub const @"I2S/PCM1" = struct {
        pub const base_address = 0x2033000;

        /// address: 0x203308c
        /// ASRCEN
        pub const ASRCEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Function Enable
            /// 0: Disabled
            /// 1: Enabled
            ASRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8c);

        /// address: 0x2033098
        /// ASRC FIFO Level Status Register
        pub const ASRCFIFOSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC RXFIFO Full Level The manually-configured FIFO fill level for the ratio
            /// value of the received data.
            ASRC_RX_FIFO_FULL_LEVAL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x98);

        /// address: 0x2033090
        /// ASRC Manual Ratio Configuration Register
        pub const ASRCMANCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC Ratio Value Manual Configure The ratio value is an unsigned 26-bit number
            /// and uses 4.22 data format, which means there are 4 bits to the left of the
            /// decimal point and 22 bits to the right of the decimal point.
            ASRC_RATIO_VALUE_MANUAL_CFG: u26,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Manual Configuration of ASRC Ratio Enable
            /// 0: Disabled
            /// 1: Enabled
            ASRC_RATIO_MANUAL_EN: u1,
        }), base_address + 0x90);

        /// address: 0x203309c
        /// ASRC MBIST Test Configuration Register
        pub const ASRCMBISTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC ROM BIST Enable Enable the ROM BIST.
            ASRC_ROM_BIST_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ASRC RAM BIST Enable Enable the RAM BIST.
            ASRC_RAM_BIST_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x9c);

        /// address: 0x20330a0
        /// ASRCMBISTSTA
        pub const ASRCMBISTSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RAM busy status
            /// 1: RAM busy
            /// 0: RAM idle
            RAM_BUSY_STATUS: u1,
            /// RAM stop status
            /// 1: Stop
            /// 0: Running
            RAM_STOP_STATUS: u1,
            /// RAM BIST error cycle
            RAM_BIST_ERROR_CYCLE: u2,
            /// RAM BIST error pattern
            RAM_BIST_ERROR_PATTERN: u3,
            /// RAM BIST error status
            /// 1: Error
            /// 0: No effect
            RAM_BIST_ERR_STATUS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// ROM BUSY STATUS
            /// 1: ROM busy
            /// 0: ROM idle
            ROM_BUSY_STATUS: u1,
            /// ROM BIST error sum
            ROM_BIST_ERROR_SUM: u1,
            /// ROM BIST error xor
            ROM_BIST_ERROR_XOR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x2033094
        /// ASRC Status Register
        pub const ASRCRATIOSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Adaptive Ratio Computational Value
            ADAPT_COMPUT_VALUE: u26,
            reserved0: u1,
            reserved1: u1,
            /// Adaptive Ratio Computational Lock
            /// 0: Unlocked
            /// 1: Locked
            ADAPT_COMPUT_LOCK: u1,
            /// ASRC Receive Data Buffer Overflow State It can control the mute with lock.
            /// 0: No overflow
            /// 1: Overflow
            ASRC_BUF_OVERFLOW_STA: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x94);

        /// address: 0x2033088
        /// ASRC Input Sample Pulse Extend Configuration Register
        pub const FsinEXTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Extend Enable
            /// 0: Disabled
            /// 1: Enabled Enable the bit when using ASRC.
            EXTEND_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x88);

        /// address: 0x2033030
        /// I2S_PCM_CHCFG
        pub const I2S_PCM_CHCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Channel/Slot number between CPU/DMA and TXFIFO
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ... 1111:16 channels or slots
            TX_SLOT_NUM: u4,
            /// RX Channel/Slot number between CPU/DMA and RXFIFO
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            RX_SLOT_NUM: u4,
            /// 0: Transfer level 0 in non-transferring slot
            /// 1: Turn to Hi-Z State (TDM) in non-transferring slot
            TX_STATE: u1,
            /// 0: Normal mode for the last half-cycle of BCLK in the slot
            /// 1: Turn to Hi-Z state for the last half-cycle of BCLK in the slot
            TX_SLOT_HIZ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x30);

        /// address: 0x2033024
        /// I2S_PCM_CLKD
        pub const I2S_PCM_CLKD = @intToPtr(*volatile Mmio(32, packed struct {
            /// MCLK Divide Ratio from PLL_AUDIO
            /// 0000: Reserved
            /// 0001: Divide by 1
            /// 0010: Divide by 2
            /// 0011: Divide by 4
            /// 0100: Divide by 6
            /// 0101: Divide by 8
            /// 0110: Divide by 12
            /// 0111: Divide by 16
            /// 1000: Divide by 24
            /// 1001: Divide by 32
            /// 1010: Divide by 48
            /// 1011: Divide by 64
            /// 1100: Divide by 96
            /// 1101: Divide by 128
            /// 1110: Divide by 176
            /// 1111: Divide by 192
            MCLKDIV: u4,
            /// BCLK Divide Ratio from PLL_AUDIO
            /// 0000: Reserved
            /// 0001: Divide by 1
            /// 0010: Divide by 2
            /// 0011: Divide by 4
            /// 0100: Divide by 6
            /// 0101: Divide by 8
            /// 0110: Divide by 12
            /// 0111: Divide by 16
            /// 1000: Divide by 24
            /// 1001: Divide by 32
            /// 1010: Divide by 48
            /// 1011: Divide by 64
            /// 1100: Divide by 96
            /// 1101: Divide by 128
            /// 1110: Divide by 176
            /// 1111: Divide by 192
            BCLKDIV: u4,
            /// 0: Disable MCLK Output
            /// 1: Enable MCLK Output Note: Whether in slave or master mode, when this bit is
            /// set to ‘1’, MCLK should be output.
            MCLKO_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x24);

        /// address: 0x2033000
        /// I2S_PCM_CTL
        pub const I2S_PCM_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Globe Enable
            /// 0: Disabled
            /// 1: Enabled
            GEN: u1,
            /// Receiver Block Enable
            /// 0: Disabled
            /// 1: Enabled
            RXEN: u1,
            /// Transmitter Block Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEN: u1,
            /// Loopback Test
            /// 0: Normal Mode
            /// 1: Loopback Test When set to ‘1’, the bit indicates that the DOUT is
            /// connected to the DIN.
            LOOP: u1,
            /// Mode Selection
            /// 00: PCM Mode (offset 0: Long Frame; offset 1: Short Frame)
            /// 01: Left Mode (offset 0: LJ Mode; offset 1: I2S Mode)
            /// 10: Right-Justified Mode
            /// 11: Reserved
            MODE_SEL: u2,
            /// Data Output Mute Enable
            /// 0: Normal Transfer
            /// 1: Force DOUT to output 0
            OUT_MUTE: u1,
            reserved0: u1,
            /// Data0 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT0_EN: u1,
            /// Data1 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT1_EN: u1,
            /// Data2 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT2_EN: u1,
            /// Data3 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT3_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LRCK Direction Select
            /// 0: Input
            /// 1: Output
            LRCK_OUT: u1,
            /// Bit Clock Direction Select
            /// 0: Input
            /// 1: Output
            BCLK_OUT: u1,
            reserved6: u1,
            /// I2S RX Synchronize Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN: u1,
            /// The bit takes effect only when RX_SYNC_EN is set to 1. I2S0/I2S1/I2S2/OWA RX
            /// Synchronize Enable Start.
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x0);

        /// address: 0x2033014
        /// I2S_PCM_FCTL
        pub const I2S_PCM_FCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Output Mode (Mode 0, 1, 2, 3)
            /// 00: Expanding ‘0’ at LSB of RXFIFO register
            /// 01: Expanding received sample sign bit at MSB of RXFIFO register
            /// 10: Truncating received samples at high half-word of RXFIFO register and low
            /// half-word of RXFIFO register is filled by ‘0’
            /// 11: Truncating received samples at low half-word of RXFIFO register and high
            /// half-word of RXFIFO register is expanded by its sign bit Example for 20-bit
            /// received audio sample: Mode 0: APB_RDATA[31:0] = {RXFIFO[31:12], 12’h0} Mode
            /// 1: APB_RDATA[31:0] = {12{RXFIFO[31]}, RXFIFO[31:12]} Mode 2: APB_RDATA [31:0] =
            /// {RXFIFO[31:16], 16’h0} Mode 3: APB_RDATA[31:0] = {16{RXFIFO[31],
            /// RXFIFO[31:16]}
            RXOM: u2,
            /// TXFIFO Input Mode (Mode 0, 1)
            /// 0: Valid data at the MSB of TXFIFO register
            /// 1: Valid data at the LSB of TXFIFO register Example for 20-bit transmitted audio
            /// sample: Mode 0: TXFIFO[31:0] = {APB_WDATA[31:12], 12’h0} Mode 1: TXFIFO[31:0]
            /// = {APB_WDATA[19:0], 12’h0}
            TXIM: u1,
            reserved0: u1,
            /// RXFIFO Trigger Level Interrupt and DMA request trigger level for RXFIFO normal
            /// condition. Trigger Level = RXTL + 1
            RXTL: u6,
            reserved1: u1,
            reserved2: u1,
            /// TXFIFO Empty Trigger Level Interrupt and DMA request trigger level for TXFIFO
            /// normal condition. Trigger Level = TXTL
            TXTL: u7,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write ‘1’ to flush RXFIFO, self clear to ‘0’.
            FRX: u1,
            /// Write ‘1’ to flush TXFIFO, self clear to ‘0’.
            FTX: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Audio Hub Enable The bit takes effect only when TXEN is set to 1.
            /// I2S0/I2S1/I2S2/OWA TXFIFO Hub Enable.
            /// 0: Disabled
            /// 1: Enabled
            HUB_EN: u1,
        }), base_address + 0x14);

        /// address: 0x2033004
        /// I2S_PCM_FMT0
        pub const I2S_PCM_FMT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slot Width Select
            /// 000: Reserved
            /// 001: 8-bit
            /// 010: 12-bit
            /// 011: 16-bit
            /// 100: 20-bit
            /// 101: 24-bit
            /// 110: 28-bit
            /// 111: 32-bit
            SW: u3,
            /// Edge Transfer
            /// 0: DOUT drives data and DIN sample data at the different BCLK edge
            /// 1: DOUT drives data and DIN sample data at the same BCLK edge BCLK_POLARITY = 0,
            /// EDGE_TRANSFER = 0, DIN sample data at positive edge; BCLK_POLARITY = 0,
            /// EDGE_TRANSFER = 1, DIN sample data at negative edge; BCLK_POLARITY = 1,
            /// EDGE_TRANSFER = 0, DIN sample data at negative edge; BCLK_POLARITY = 1,
            /// EDGE_TRANSFER = 1, DIN sample data at positive edge.
            EDGE_TRANSFER: u1,
            /// Sample Resolution
            /// 000: Reserved
            /// 001: 8-bit
            /// 010: 12-bit
            /// 011: 16-bit
            /// 100: 20-bit
            /// 101: 24-bit
            /// 110: 28-bit
            /// 111: 32-bit
            SR: u3,
            /// 0: Normal mode, DOUT drives data at negative edge
            /// 1: Invert mode, DOUT drives data at positive edge
            BCLK_POLARITY: u1,
            /// It is used to program the number of BCLKs per channel of the sample frame. This
            /// value is interpreted as follows. PCM mode: Number of BCLKs within (Left + Right)
            /// channel width. I2S/Left-Justified/Right-Justified mode: Number of BCLKs within
            /// each channel width (Left or Right). For example: N = 7: 8 BCLKs width … N =
            /// 1023: 1024 BCLKs width
            LRCK_PERIOD: u10,
            reserved0: u1,
            /// In I2S/Left-Justified/Right-Justified mode:
            /// 0: Left Channel when LRCK is low.
            /// 1: Left channel when LRCK is high. In PCM mode:
            /// 0: PCM LRCK asserted at the negative edge.
            /// 1: PCM LRCK asserted at the positive edge.
            LRCK_POLARITY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LRCK Width (only applies to the PCM mode)
            /// 0: LRCK = 1 BCLK Width (Short Frame)
            /// 1: LRCK = 2 BCLK Width (Long Frame)
            LRCK_WIDTH: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x2033008
        /// I2S_PCM_FMT1
        pub const I2S_PCM_FMT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCM Data Mode
            /// 00: Linear PCM
            /// 01: Reserved
            /// 10: 8-bit u-law
            /// 11: 8-bit A-law
            TX_PDM: u2,
            /// PCM Data Mode
            /// 00: Linear PCM
            /// 01: Reserved
            /// 10: 8-bit u-law
            /// 11: 8-bit A-law
            RX_PDM: u2,
            /// Sign Extend in Slot [Sample Resolution < Slot Width]
            /// 00: Zeros or audio gain padding at LSB position
            /// 01: Sign extension at MSB position
            /// 10: Reserved
            /// 11: Transfer 0 after each sample in each Slot
            SEXT: u2,
            /// MLS MSB/LSB First Select
            /// 0: MSB First
            /// 1: LSB First
            TX: u1,
            /// MLS MSB/LSB First Select
            /// 0: MSB First
            /// 1: LSB First
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x2033018
        /// I2S_PCM_FSTA
        pub const I2S_PCM_FSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO available sample word counter
            RXA_CNT: u7,
            /// NO Meaning
            PLACE_HOLDER: u1,
            /// RXFIFO Available
            /// 0: No available data in RXFIFO
            /// 1: More than one sample in RXFIFO (>= 1 Word)
            RXA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// TXFIFO Empty Space Word Counter
            TXE_CNT: u8,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TXFIFO Empty
            /// 0: No room for new sample in TXFIFO
            /// 1: More than one room for new sample in TXFIFO (>= 1 Word)
            TXE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x18);

        /// address: 0x203301c
        /// I2S_PCM_INT
        pub const I2S_PCM_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXAI_EN: u1,
            /// RXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXOI_EN: u1,
            /// RXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXUI_EN: u1,
            /// RXFIFO Data Available DRQ Enable
            /// 0: Disabled
            /// 1: Enabled When set to ‘1’, RXFIFO DMA request line is asserted if data is
            /// available in RXFIFO.
            RX_DRQ: u1,
            /// TXFIFO Empty Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEI_EN: u1,
            /// TXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled When set to ‘1’, an interrupt happens when writing new audio data
            /// if TXFIFO is full.
            TXOI_EN: u1,
            /// TXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXUI_EN: u1,
            /// TXFIFO Empty DRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            TX_DRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x203300c
        /// I2S_PCM_ISTA
        pub const I2S_PCM_ISTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Pending Interrupt
            /// 0: No pending IRQ
            /// 1: Data available pending IRQ when data in RXFIFO are more than RX trigger level
            RXA_INT: u1,
            /// RXFIFO Overrun Pending Interrupt
            /// 0: No pending IRQ
            /// 1: RXFIFO overrun pending IRQ Write ‘1’ to clear this interrupt.
            RXO_INT: u1,
            /// RXFIFO Underrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: RXFIFO underrun pending interrupt Write ‘1’ to clear this interrupt.
            RXU_INT: u1,
            reserved0: u1,
            /// TXFIFO Empty Pending Interrupt
            /// 0: No pending IRQ
            /// 1: TXFIFO empty pending interrupt when data in TXFIFO are less than TX trigger
            /// level
            TXE_INT: u1,
            /// TXFIFO Overrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: TXFIFO overrun pending interrupt Write ‘1’ to clear this interrupt.
            TXO_INT: u1,
            /// TXFIFO Underrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: TXFIFO underrun pending interrupt Write ‘1’ to clear this interrupt.
            TXU_INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x2033068
        /// I2S_PCM_RXCHMAP0
        pub const I2S_PCM_RXCHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH12_MAP: u4,
            /// RX Channel 12 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH12_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH13_MAP: u4,
            /// RX Channel 13 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH13_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH14_MAP: u4,
            /// RX Channel 14 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH14_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH15_MAP: u4,
            /// RX Channel 15 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH15_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x68);

        /// address: 0x203306c
        /// I2S_PCM_RXCHMAP1
        pub const I2S_PCM_RXCHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH8_MAP: u4,
            /// RX Channel 8 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH8_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH9_MAP: u4,
            /// RX Channel 9 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH9_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH10_MAP: u4,
            /// RX Channel 10 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH10_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH11_MAP: u4,
            /// RX Channel 11 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH11_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x6c);

        /// address: 0x2033070
        /// I2S_PCM_RXCHMAP2
        pub const I2S_PCM_RXCHMAP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH4_MAP: u4,
            /// RX Channel 4 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH4_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH5_MAP: u4,
            /// RX Channel 5 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH5_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH6_MAP: u4,
            /// RX Channel 6 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH6_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH7_MAP: u4,
            /// RX Channel 7 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH7_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x70);

        /// address: 0x2033074
        /// I2S_PCM_RXCHMAP3
        pub const I2S_PCM_RXCHMAP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH0_MAP: u4,
            /// RX Channel 0 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH0_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH1_MAP: u4,
            /// RX Channel 1 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH1_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH2_MAP: u4,
            /// RX Channel 2 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH2_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH3_MAP: u4,
            /// RX Channel 3 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH3_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x74);

        /// address: 0x2033064
        /// I2S_PCM_RXCHSEL
        pub const I2S_PCM_RXCHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// RX Channel (Slot) Number Select for Input
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            RX_CHSEL: u4,
            /// RX Offset Tune (RX Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            RX_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x64);

        /// address: 0x203302c
        /// I2S_PCM_RXCNT
        pub const I2S_PCM_RXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample Counter The audio sample number of writing into RXFIFO. When one
            /// sample is written by Digital Audio Engine, the RX sample counter register
            /// increases by one. The RX sample counter register can be set to any initial value
            /// at any time. After being updated by the initial value, the counter register
            /// should count on the base of this initial value.
            RX_CNT: u32,
        }), base_address + 0x2c);

        /// address: 0x2033010
        /// I2S_PCM_RXFIFO
        pub const I2S_PCM_RXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample The host can get one sample by reading this register. The left channel
            /// sample data is first and then the right channel sample.
            RX_DATA: u32,
        }), base_address + 0x10);

        /// address: 0x2033044
        /// I2S_PCM_TX0CHMAP0
        pub const I2S_PCM_TX0CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH8_MAP: u4,
            /// TX0 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH9_MAP: u4,
            /// TX0 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH10_MAP: u4,
            /// TX0 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH11_MAP: u4,
            /// TX0 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH12_MAP: u4,
            /// TX0 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH13_MAP: u4,
            /// TX0 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH14_MAP: u4,
            /// TX0 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH15_MAP: u4,
        }), base_address + 0x44);

        /// address: 0x2033048
        /// I2S_PCM_TX0CHMAP1
        pub const I2S_PCM_TX0CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH0_MAP: u4,
            /// TX0 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH1_MAP: u4,
            /// TX0 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH2_MAP: u4,
            /// TX0 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH3_MAP: u4,
            /// TX0 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH4_MAP: u4,
            /// TX0 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH5_MAP: u4,
            /// TX0 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH6_MAP: u4,
            /// TX0 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH7_MAP: u4,
        }), base_address + 0x48);

        /// address: 0x2033034
        /// I2S_PCM_TX0CHSEL
        pub const I2S_PCM_TX0CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel (Slot) Enable The bit[15:0] refer to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX0_CHEN: u16,
            /// TX0 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX0_CHSEL: u4,
            /// TX0 Offset Tune (TX0 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX0_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x34);

        /// address: 0x203304c
        /// I2S_PCM_TX1CHMAP0
        pub const I2S_PCM_TX1CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH8_MAP: u4,
            /// TX1 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH9_MAP: u4,
            /// TX1 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH10_MAP: u4,
            /// TX1 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH11_MAP: u4,
            /// TX1 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH12_MAP: u4,
            /// TX1 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH13_MAP: u4,
            /// TX1 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH14_MAP: u4,
            /// TX1 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH15_MAP: u4,
        }), base_address + 0x4c);

        /// address: 0x2033050
        /// I2S_PCM_TX1CHMAP1
        pub const I2S_PCM_TX1CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH0_MAP: u4,
            /// TX1 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH1_MAP: u4,
            /// TX1 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH2_MAP: u4,
            /// TX1 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH3_MAP: u4,
            /// TX1 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH4_MAP: u4,
            /// TX1 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH5_MAP: u4,
            /// TX1 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH6_MAP: u4,
            /// TX1 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH7_MAP: u4,
        }), base_address + 0x50);

        /// address: 0x2033038
        /// I2S_PCM_TX1CHSEL
        pub const I2S_PCM_TX1CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX1_CHEN: u16,
            /// TX1 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX1_CHSEL: u4,
            /// TX1 Offset Tune (TX1 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX1_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x2033054
        /// I2S_PCM_TX2CHMAP0
        pub const I2S_PCM_TX2CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH8_MAP: u4,
            /// TX2 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH9_MAP: u4,
            /// TX2 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH10_MAP: u4,
            /// TX2 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH11_MAP: u4,
            /// TX2 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH12_MAP: u4,
            /// TX2 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH13_MAP: u4,
            /// TX2 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH14_MAP: u4,
            /// TX2 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH15_MAP: u4,
        }), base_address + 0x54);

        /// address: 0x2033058
        /// I2S_PCM_TX2CHMAP1
        pub const I2S_PCM_TX2CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH0_MAP: u4,
            /// TX2 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH1_MAP: u4,
            /// TX2 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH2_MAP: u4,
            /// TX2 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH3_MAP: u4,
            /// TX2 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH4_MAP: u4,
            /// TX2 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH5_MAP: u4,
            /// TX2 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH6_MAP: u4,
            /// TX2 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH7_MAP: u4,
        }), base_address + 0x58);

        /// address: 0x203303c
        /// I2S_PCM_TX2CHSEL
        pub const I2S_PCM_TX2CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX2_CHEN: u16,
            /// TX2 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX2_CHSEL: u4,
            /// TX2 Offset Tune (TX2 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX2_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x3c);

        /// address: 0x203305c
        /// I2S_PCM_TX3CHMAP0
        pub const I2S_PCM_TX3CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH8_MAP: u4,
            /// TX3 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH9_MAP: u4,
            /// TX3 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH10_MAP: u4,
            /// TX3 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH11_MAP: u4,
            /// TX3 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH12_MAP: u4,
            /// TX3 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH13_MAP: u4,
            /// TX3 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH14_MAP: u4,
            /// TX3 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH15_MAP: u4,
        }), base_address + 0x5c);

        /// address: 0x2033060
        /// I2S_PCM_TX3CHMAP1
        pub const I2S_PCM_TX3CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH0_MAP: u4,
            /// TX3 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH1_MAP: u4,
            /// TX3 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH2_MAP: u4,
            /// TX3 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH3_MAP: u4,
            /// TX3 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH4_MAP: u4,
            /// TX3 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH5_MAP: u4,
            /// TX3 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH6_MAP: u4,
            /// TX3 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH7_MAP: u4,
        }), base_address + 0x60);

        /// address: 0x2033040
        /// I2S_PCM_TX3CHSEL
        pub const I2S_PCM_TX3CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX3_CHEN: u16,
            /// TX3 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX3_CHSEL: u4,
            /// TX3 Offset Tune (TX3 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX3_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x40);

        /// address: 0x2033028
        /// I2S_PCM_TXCNT
        pub const I2S_PCM_TXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Counter The audio sample number of sending into TXFIFO. When one
            /// sample is put into TXFIFO by DMA or by host IO, the TX sample counter register
            /// increases by one. The TX sample counter register can be set to any initial value
            /// at any time. After being updated by the initial value, the counter register
            /// should count on the base of this initial value.
            TX_CNT: u32,
        }), base_address + 0x28);

        /// address: 0x2033020
        /// I2S_PCM_TXFIFO
        pub const I2S_PCM_TXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Transmitting left, right channel sample data should be written to this
            /// register one by one. The left channel sample data is first and then the right
            /// channel sample.
            TX_DATA: u32,
        }), base_address + 0x20);

        /// address: 0x2033080
        /// ASRC MCLK Configuration Register
        pub const MCLKCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequency Division Coefficient 4’d0 = Res (no output), 4’d1 = 1x, 4’d2 =
            /// 1/2x, 4’d3 = 1/4x, 4’d4 = 1/6x, 4’d5 = 1/8x, 4’d6 = 1/12x, 4’d7 =
            /// 1/16x, 4’d8 = 1/24x, 4’d9 = 1/32x, 4’d10 = 1/48, 4’d11 = 1/64x, 4’d12
            /// = 1/96x, 4’d13 = 1/128x, 4’d14 = 1/176x, 4’d15 = 1/192x, others = Res
            ASRC_MCLK_FREQ_DIV_COE: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// ASRC Clock Gate Enable Control
            /// 0: Gated
            /// 1: Not gated
            ASRC_MCLK_GATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x80);
    };

    /// I2S/PCM2
    pub const @"I2S/PCM2" = struct {
        pub const base_address = 0x2034000;

        /// address: 0x203408c
        /// ASRCEN
        pub const ASRCEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Function Enable
            /// 0: Disabled
            /// 1: Enabled
            ASRC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8c);

        /// address: 0x2034098
        /// ASRC FIFO Level Status Register
        pub const ASRCFIFOSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC RXFIFO Full Level The manually-configured FIFO fill level for the ratio
            /// value of the received data.
            ASRC_RX_FIFO_FULL_LEVAL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x98);

        /// address: 0x2034090
        /// ASRC Manual Ratio Configuration Register
        pub const ASRCMANCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC Ratio Value Manual Configure The ratio value is an unsigned 26-bit number
            /// and uses 4.22 data format, which means there are 4 bits to the left of the
            /// decimal point and 22 bits to the right of the decimal point.
            ASRC_RATIO_VALUE_MANUAL_CFG: u26,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Manual Configuration of ASRC Ratio Enable
            /// 0: Disabled
            /// 1: Enabled
            ASRC_RATIO_MANUAL_EN: u1,
        }), base_address + 0x90);

        /// address: 0x203409c
        /// ASRC MBIST Test Configuration Register
        pub const ASRCMBISTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ASRC ROM BIST Enable Enable the ROM BIST.
            ASRC_ROM_BIST_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ASRC RAM BIST Enable Enable the RAM BIST.
            ASRC_RAM_BIST_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x9c);

        /// address: 0x20340a0
        /// ASRCMBISTSTA
        pub const ASRCMBISTSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RAM busy status
            /// 1: RAM busy
            /// 0: RAM idle
            RAM_BUSY_STATUS: u1,
            /// RAM stop status
            /// 1: Stop
            /// 0: Running
            RAM_STOP_STATUS: u1,
            /// RAM BIST error cycle
            RAM_BIST_ERROR_CYCLE: u2,
            /// RAM BIST error pattern
            RAM_BIST_ERROR_PATTERN: u3,
            /// RAM BIST error status
            /// 1: Error
            /// 0: No effect
            RAM_BIST_ERR_STATUS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// ROM BUSY STATUS
            /// 1: ROM busy
            /// 0: ROM idle
            ROM_BUSY_STATUS: u1,
            /// ROM BIST error sum
            ROM_BIST_ERROR_SUM: u1,
            /// ROM BIST error xor
            ROM_BIST_ERROR_XOR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x2034094
        /// ASRC Status Register
        pub const ASRCRATIOSTAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Adaptive Ratio Computational Value
            ADAPT_COMPUT_VALUE: u26,
            reserved0: u1,
            reserved1: u1,
            /// Adaptive Ratio Computational Lock
            /// 0: Unlocked
            /// 1: Locked
            ADAPT_COMPUT_LOCK: u1,
            /// ASRC Receive Data Buffer Overflow State It can control the mute with lock.
            /// 0: No overflow
            /// 1: Overflow
            ASRC_BUF_OVERFLOW_STA: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x94);

        /// address: 0x2034088
        /// ASRC Input Sample Pulse Extend Configuration Register
        pub const FsinEXTCFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Extend Enable
            /// 0: Disabled
            /// 1: Enabled Enable the bit when using ASRC.
            EXTEND_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x88);

        /// address: 0x2034030
        /// I2S_PCM_CHCFG
        pub const I2S_PCM_CHCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Channel/Slot number between CPU/DMA and TXFIFO
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ... 1111:16 channels or slots
            TX_SLOT_NUM: u4,
            /// RX Channel/Slot number between CPU/DMA and RXFIFO
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            RX_SLOT_NUM: u4,
            /// 0: Transfer level 0 in non-transferring slot
            /// 1: Turn to Hi-Z State (TDM) in non-transferring slot
            TX_STATE: u1,
            /// 0: Normal mode for the last half-cycle of BCLK in the slot
            /// 1: Turn to Hi-Z state for the last half-cycle of BCLK in the slot
            TX_SLOT_HIZ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x30);

        /// address: 0x2034024
        /// I2S_PCM_CLKD
        pub const I2S_PCM_CLKD = @intToPtr(*volatile Mmio(32, packed struct {
            /// MCLK Divide Ratio from PLL_AUDIO
            /// 0000: Reserved
            /// 0001: Divide by 1
            /// 0010: Divide by 2
            /// 0011: Divide by 4
            /// 0100: Divide by 6
            /// 0101: Divide by 8
            /// 0110: Divide by 12
            /// 0111: Divide by 16
            /// 1000: Divide by 24
            /// 1001: Divide by 32
            /// 1010: Divide by 48
            /// 1011: Divide by 64
            /// 1100: Divide by 96
            /// 1101: Divide by 128
            /// 1110: Divide by 176
            /// 1111: Divide by 192
            MCLKDIV: u4,
            /// BCLK Divide Ratio from PLL_AUDIO
            /// 0000: Reserved
            /// 0001: Divide by 1
            /// 0010: Divide by 2
            /// 0011: Divide by 4
            /// 0100: Divide by 6
            /// 0101: Divide by 8
            /// 0110: Divide by 12
            /// 0111: Divide by 16
            /// 1000: Divide by 24
            /// 1001: Divide by 32
            /// 1010: Divide by 48
            /// 1011: Divide by 64
            /// 1100: Divide by 96
            /// 1101: Divide by 128
            /// 1110: Divide by 176
            /// 1111: Divide by 192
            BCLKDIV: u4,
            /// 0: Disable MCLK Output
            /// 1: Enable MCLK Output Note: Whether in slave or master mode, when this bit is
            /// set to ‘1’, MCLK should be output.
            MCLKO_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x24);

        /// address: 0x2034000
        /// I2S_PCM_CTL
        pub const I2S_PCM_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Globe Enable
            /// 0: Disabled
            /// 1: Enabled
            GEN: u1,
            /// Receiver Block Enable
            /// 0: Disabled
            /// 1: Enabled
            RXEN: u1,
            /// Transmitter Block Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEN: u1,
            /// Loopback Test
            /// 0: Normal Mode
            /// 1: Loopback Test When set to ‘1’, the bit indicates that the DOUT is
            /// connected to the DIN.
            LOOP: u1,
            /// Mode Selection
            /// 00: PCM Mode (offset 0: Long Frame; offset 1: Short Frame)
            /// 01: Left Mode (offset 0: LJ Mode; offset 1: I2S Mode)
            /// 10: Right-Justified Mode
            /// 11: Reserved
            MODE_SEL: u2,
            /// Data Output Mute Enable
            /// 0: Normal Transfer
            /// 1: Force DOUT to output 0
            OUT_MUTE: u1,
            reserved0: u1,
            /// Data0 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT0_EN: u1,
            /// Data1 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT1_EN: u1,
            /// Data2 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT2_EN: u1,
            /// Data3 Output Enable
            /// 0: Disabled, Hi-Z State
            /// 1: Enabled
            DOUT3_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LRCK Direction Select
            /// 0: Input
            /// 1: Output
            LRCK_OUT: u1,
            /// Bit Clock Direction Select
            /// 0: Input
            /// 1: Output
            BCLK_OUT: u1,
            reserved6: u1,
            /// I2S RX Synchronize Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN: u1,
            /// The bit takes effect only when RX_SYNC_EN is set to 1. I2S0/I2S1/I2S2/OWA RX
            /// Synchronize Enable Start.
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x0);

        /// address: 0x2034014
        /// I2S_PCM_FCTL
        pub const I2S_PCM_FCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Output Mode (Mode 0, 1, 2, 3)
            /// 00: Expanding ‘0’ at LSB of RXFIFO register
            /// 01: Expanding received sample sign bit at MSB of RXFIFO register
            /// 10: Truncating received samples at high half-word of RXFIFO register and low
            /// half-word of RXFIFO register is filled by ‘0’
            /// 11: Truncating received samples at low half-word of RXFIFO register and high
            /// half-word of RXFIFO register is expanded by its sign bit Example for 20-bit
            /// received audio sample: Mode 0: APB_RDATA[31:0] = {RXFIFO[31:12], 12’h0} Mode
            /// 1: APB_RDATA[31:0] = {12{RXFIFO[31]}, RXFIFO[31:12]} Mode 2: APB_RDATA [31:0] =
            /// {RXFIFO[31:16], 16’h0} Mode 3: APB_RDATA[31:0] = {16{RXFIFO[31],
            /// RXFIFO[31:16]}
            RXOM: u2,
            /// TXFIFO Input Mode (Mode 0, 1)
            /// 0: Valid data at the MSB of TXFIFO register
            /// 1: Valid data at the LSB of TXFIFO register Example for 20-bit transmitted audio
            /// sample: Mode 0: TXFIFO[31:0] = {APB_WDATA[31:12], 12’h0} Mode 1: TXFIFO[31:0]
            /// = {APB_WDATA[19:0], 12’h0}
            TXIM: u1,
            reserved0: u1,
            /// RXFIFO Trigger Level Interrupt and DMA request trigger level for RXFIFO normal
            /// condition. Trigger Level = RXTL + 1
            RXTL: u6,
            reserved1: u1,
            reserved2: u1,
            /// TXFIFO Empty Trigger Level Interrupt and DMA request trigger level for TXFIFO
            /// normal condition. Trigger Level = TXTL
            TXTL: u7,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Write ‘1’ to flush RXFIFO, self clear to ‘0’.
            FRX: u1,
            /// Write ‘1’ to flush TXFIFO, self clear to ‘0’.
            FTX: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Audio Hub Enable The bit takes effect only when TXEN is set to 1.
            /// I2S0/I2S1/I2S2/OWA TXFIFO Hub Enable.
            /// 0: Disabled
            /// 1: Enabled
            HUB_EN: u1,
        }), base_address + 0x14);

        /// address: 0x2034004
        /// I2S_PCM_FMT0
        pub const I2S_PCM_FMT0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slot Width Select
            /// 000: Reserved
            /// 001: 8-bit
            /// 010: 12-bit
            /// 011: 16-bit
            /// 100: 20-bit
            /// 101: 24-bit
            /// 110: 28-bit
            /// 111: 32-bit
            SW: u3,
            /// Edge Transfer
            /// 0: DOUT drives data and DIN sample data at the different BCLK edge
            /// 1: DOUT drives data and DIN sample data at the same BCLK edge BCLK_POLARITY = 0,
            /// EDGE_TRANSFER = 0, DIN sample data at positive edge; BCLK_POLARITY = 0,
            /// EDGE_TRANSFER = 1, DIN sample data at negative edge; BCLK_POLARITY = 1,
            /// EDGE_TRANSFER = 0, DIN sample data at negative edge; BCLK_POLARITY = 1,
            /// EDGE_TRANSFER = 1, DIN sample data at positive edge.
            EDGE_TRANSFER: u1,
            /// Sample Resolution
            /// 000: Reserved
            /// 001: 8-bit
            /// 010: 12-bit
            /// 011: 16-bit
            /// 100: 20-bit
            /// 101: 24-bit
            /// 110: 28-bit
            /// 111: 32-bit
            SR: u3,
            /// 0: Normal mode, DOUT drives data at negative edge
            /// 1: Invert mode, DOUT drives data at positive edge
            BCLK_POLARITY: u1,
            /// It is used to program the number of BCLKs per channel of the sample frame. This
            /// value is interpreted as follows. PCM mode: Number of BCLKs within (Left + Right)
            /// channel width. I2S/Left-Justified/Right-Justified mode: Number of BCLKs within
            /// each channel width (Left or Right). For example: N = 7: 8 BCLKs width … N =
            /// 1023: 1024 BCLKs width
            LRCK_PERIOD: u10,
            reserved0: u1,
            /// In I2S/Left-Justified/Right-Justified mode:
            /// 0: Left Channel when LRCK is low.
            /// 1: Left channel when LRCK is high. In PCM mode:
            /// 0: PCM LRCK asserted at the negative edge.
            /// 1: PCM LRCK asserted at the positive edge.
            LRCK_POLARITY: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LRCK Width (only applies to the PCM mode)
            /// 0: LRCK = 1 BCLK Width (Short Frame)
            /// 1: LRCK = 2 BCLK Width (Long Frame)
            LRCK_WIDTH: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x2034008
        /// I2S_PCM_FMT1
        pub const I2S_PCM_FMT1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCM Data Mode
            /// 00: Linear PCM
            /// 01: Reserved
            /// 10: 8-bit u-law
            /// 11: 8-bit A-law
            TX_PDM: u2,
            /// PCM Data Mode
            /// 00: Linear PCM
            /// 01: Reserved
            /// 10: 8-bit u-law
            /// 11: 8-bit A-law
            RX_PDM: u2,
            /// Sign Extend in Slot [Sample Resolution < Slot Width]
            /// 00: Zeros or audio gain padding at LSB position
            /// 01: Sign extension at MSB position
            /// 10: Reserved
            /// 11: Transfer 0 after each sample in each Slot
            SEXT: u2,
            /// MLS MSB/LSB First Select
            /// 0: MSB First
            /// 1: LSB First
            TX: u1,
            /// MLS MSB/LSB First Select
            /// 0: MSB First
            /// 1: LSB First
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x2034018
        /// I2S_PCM_FSTA
        pub const I2S_PCM_FSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO available sample word counter
            RXA_CNT: u7,
            /// NO Meaning
            PLACE_HOLDER: u1,
            /// RXFIFO Available
            /// 0: No available data in RXFIFO
            /// 1: More than one sample in RXFIFO (>= 1 Word)
            RXA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// TXFIFO Empty Space Word Counter
            TXE_CNT: u8,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TXFIFO Empty
            /// 0: No room for new sample in TXFIFO
            /// 1: More than one room for new sample in TXFIFO (>= 1 Word)
            TXE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x18);

        /// address: 0x203401c
        /// I2S_PCM_INT
        pub const I2S_PCM_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXAI_EN: u1,
            /// RXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXOI_EN: u1,
            /// RXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXUI_EN: u1,
            /// RXFIFO Data Available DRQ Enable
            /// 0: Disabled
            /// 1: Enabled When set to ‘1’, RXFIFO DMA request line is asserted if data is
            /// available in RXFIFO.
            RX_DRQ: u1,
            /// TXFIFO Empty Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEI_EN: u1,
            /// TXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled When set to ‘1’, an interrupt happens when writing new audio data
            /// if TXFIFO is full.
            TXOI_EN: u1,
            /// TXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXUI_EN: u1,
            /// TXFIFO Empty DRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            TX_DRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x203400c
        /// I2S_PCM_ISTA
        pub const I2S_PCM_ISTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Pending Interrupt
            /// 0: No pending IRQ
            /// 1: Data available pending IRQ when data in RXFIFO are more than RX trigger level
            RXA_INT: u1,
            /// RXFIFO Overrun Pending Interrupt
            /// 0: No pending IRQ
            /// 1: RXFIFO overrun pending IRQ Write ‘1’ to clear this interrupt.
            RXO_INT: u1,
            /// RXFIFO Underrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: RXFIFO underrun pending interrupt Write ‘1’ to clear this interrupt.
            RXU_INT: u1,
            reserved0: u1,
            /// TXFIFO Empty Pending Interrupt
            /// 0: No pending IRQ
            /// 1: TXFIFO empty pending interrupt when data in TXFIFO are less than TX trigger
            /// level
            TXE_INT: u1,
            /// TXFIFO Overrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: TXFIFO overrun pending interrupt Write ‘1’ to clear this interrupt.
            TXO_INT: u1,
            /// TXFIFO Underrun Pending Interrupt
            /// 0: No pending interrupt
            /// 1: TXFIFO underrun pending interrupt Write ‘1’ to clear this interrupt.
            TXU_INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x2034068
        /// I2S_PCM_RXCHMAP0
        pub const I2S_PCM_RXCHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH12_MAP: u4,
            /// RX Channel 12 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH12_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH13_MAP: u4,
            /// RX Channel 13 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH13_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH14_MAP: u4,
            /// RX Channel 14 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH14_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH15_MAP: u4,
            /// RX Channel 15 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH15_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x68);

        /// address: 0x203406c
        /// I2S_PCM_RXCHMAP1
        pub const I2S_PCM_RXCHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH8_MAP: u4,
            /// RX Channel 8 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH8_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH9_MAP: u4,
            /// RX Channel 9 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH9_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH10_MAP: u4,
            /// RX Channel 10 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH10_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH11_MAP: u4,
            /// RX Channel 11 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH11_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x6c);

        /// address: 0x2034070
        /// I2S_PCM_RXCHMAP2
        pub const I2S_PCM_RXCHMAP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH4_MAP: u4,
            /// RX Channel 4 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH4_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH5_MAP: u4,
            /// RX Channel 5 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH5_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH6_MAP: u4,
            /// RX Channel 6 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH6_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH7_MAP: u4,
            /// RX Channel 7 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH7_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x70);

        /// address: 0x2034074
        /// I2S_PCM_RXCHMAP3
        pub const I2S_PCM_RXCHMAP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH0_MAP: u4,
            /// RX Channel 0 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH0_SELECT: u2,
            reserved0: u1,
            reserved1: u1,
            /// RX Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH1_MAP: u4,
            /// RX Channel 1 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH1_SELECT: u2,
            reserved2: u1,
            reserved3: u1,
            /// RX Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH2_MAP: u4,
            /// RX Channel 2 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH2_SELECT: u2,
            reserved4: u1,
            reserved5: u1,
            /// RX Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            RX_CH3_MAP: u4,
            /// RX Channel 3 Select
            /// 00: SDI0
            /// 01: SDI1
            /// 10: SDI2
            /// 11: SDI3
            RX_CH3_SELECT: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x74);

        /// address: 0x2034064
        /// I2S_PCM_RXCHSEL
        pub const I2S_PCM_RXCHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// RX Channel (Slot) Number Select for Input
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            RX_CHSEL: u4,
            /// RX Offset Tune (RX Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            RX_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x64);

        /// address: 0x203402c
        /// I2S_PCM_RXCNT
        pub const I2S_PCM_RXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample Counter The audio sample number of writing into RXFIFO. When one
            /// sample is written by Digital Audio Engine, the RX sample counter register
            /// increases by one. The RX sample counter register can be set to any initial value
            /// at any time. After being updated by the initial value, the counter register
            /// should count on the base of this initial value.
            RX_CNT: u32,
        }), base_address + 0x2c);

        /// address: 0x2034010
        /// I2S_PCM_RXFIFO
        pub const I2S_PCM_RXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample The host can get one sample by reading this register. The left channel
            /// sample data is first and then the right channel sample.
            RX_DATA: u32,
        }), base_address + 0x10);

        /// address: 0x2034044
        /// I2S_PCM_TX0CHMAP0
        pub const I2S_PCM_TX0CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH8_MAP: u4,
            /// TX0 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH9_MAP: u4,
            /// TX0 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH10_MAP: u4,
            /// TX0 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH11_MAP: u4,
            /// TX0 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH12_MAP: u4,
            /// TX0 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH13_MAP: u4,
            /// TX0 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH14_MAP: u4,
            /// TX0 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH15_MAP: u4,
        }), base_address + 0x44);

        /// address: 0x2034048
        /// I2S_PCM_TX0CHMAP1
        pub const I2S_PCM_TX0CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH0_MAP: u4,
            /// TX0 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH1_MAP: u4,
            /// TX0 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH2_MAP: u4,
            /// TX0 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH3_MAP: u4,
            /// TX0 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH4_MAP: u4,
            /// TX0 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH5_MAP: u4,
            /// TX0 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH6_MAP: u4,
            /// TX0 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX0_CH7_MAP: u4,
        }), base_address + 0x48);

        /// address: 0x2034034
        /// I2S_PCM_TX0CHSEL
        pub const I2S_PCM_TX0CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX0 Channel (Slot) Enable The bit[15:0] refer to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX0_CHEN: u16,
            /// TX0 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX0_CHSEL: u4,
            /// TX0 Offset Tune (TX0 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX0_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x34);

        /// address: 0x203404c
        /// I2S_PCM_TX1CHMAP0
        pub const I2S_PCM_TX1CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH8_MAP: u4,
            /// TX1 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH9_MAP: u4,
            /// TX1 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH10_MAP: u4,
            /// TX1 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH11_MAP: u4,
            /// TX1 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH12_MAP: u4,
            /// TX1 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH13_MAP: u4,
            /// TX1 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH14_MAP: u4,
            /// TX1 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH15_MAP: u4,
        }), base_address + 0x4c);

        /// address: 0x2034050
        /// I2S_PCM_TX1CHMAP1
        pub const I2S_PCM_TX1CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH0_MAP: u4,
            /// TX1 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH1_MAP: u4,
            /// TX1 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH2_MAP: u4,
            /// TX1 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH3_MAP: u4,
            /// TX1 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH4_MAP: u4,
            /// TX1 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH5_MAP: u4,
            /// TX1 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH6_MAP: u4,
            /// TX1 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX1_CH7_MAP: u4,
        }), base_address + 0x50);

        /// address: 0x2034038
        /// I2S_PCM_TX1CHSEL
        pub const I2S_PCM_TX1CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX1 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX1_CHEN: u16,
            /// TX1 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX1_CHSEL: u4,
            /// TX1 Offset Tune (TX1 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX1_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x38);

        /// address: 0x2034054
        /// I2S_PCM_TX2CHMAP0
        pub const I2S_PCM_TX2CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH8_MAP: u4,
            /// TX2 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH9_MAP: u4,
            /// TX2 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH10_MAP: u4,
            /// TX2 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH11_MAP: u4,
            /// TX2 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH12_MAP: u4,
            /// TX2 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH13_MAP: u4,
            /// TX2 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH14_MAP: u4,
            /// TX2 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH15_MAP: u4,
        }), base_address + 0x54);

        /// address: 0x2034058
        /// I2S_PCM_TX2CHMAP1
        pub const I2S_PCM_TX2CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH0_MAP: u4,
            /// TX2 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH1_MAP: u4,
            /// TX2 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH2_MAP: u4,
            /// TX2 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH3_MAP: u4,
            /// TX2 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH4_MAP: u4,
            /// TX2 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH5_MAP: u4,
            /// TX2 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH6_MAP: u4,
            /// TX2 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX2_CH7_MAP: u4,
        }), base_address + 0x58);

        /// address: 0x203403c
        /// I2S_PCM_TX2CHSEL
        pub const I2S_PCM_TX2CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX2 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX2_CHEN: u16,
            /// TX2 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX2_CHSEL: u4,
            /// TX2 Offset Tune (TX2 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX2_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x3c);

        /// address: 0x203405c
        /// I2S_PCM_TX3CHMAP0
        pub const I2S_PCM_TX3CHMAP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel 8 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH8_MAP: u4,
            /// TX3 Channel 9 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH9_MAP: u4,
            /// TX3 Channel 10 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH10_MAP: u4,
            /// TX3 Channel 11 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH11_MAP: u4,
            /// TX3 Channel 12 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH12_MAP: u4,
            /// TX3 Channel 13 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH13_MAP: u4,
            /// TX3 Channel 14 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH14_MAP: u4,
            /// TX3 Channel 15 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH15_MAP: u4,
        }), base_address + 0x5c);

        /// address: 0x2034060
        /// I2S_PCM_TX3CHMAP1
        pub const I2S_PCM_TX3CHMAP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel 0 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH0_MAP: u4,
            /// TX3 Channel 1 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH1_MAP: u4,
            /// TX3 Channel 2 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH2_MAP: u4,
            /// TX3 Channel 3 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH3_MAP: u4,
            /// TX3 Channel 4 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH4_MAP: u4,
            /// TX3 Channel 5 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH5_MAP: u4,
            /// TX3 Channel 6 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH6_MAP: u4,
            /// TX3 Channel 7 Mapping
            /// 0000: The first sample …
            /// 0111: The eighth sample
            /// 1000: The ninth sample ...
            /// 1111: The sixteenth sample
            TX3_CH7_MAP: u4,
        }), base_address + 0x60);

        /// address: 0x2034040
        /// I2S_PCM_TX3CHSEL
        pub const I2S_PCM_TX3CHSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX3 Channel (Slot) Enable The bit[15:0] refers to Slot [15:0]. When one or more
            /// slots are disabled, the affected slots are set to the disable state.
            /// 0: Disabled
            /// 1: Enabled
            TX3_CHEN: u16,
            /// TX3 Channel (Slot) Number Select for Each Output
            /// 0000: 1 channel or slot ...
            /// 0111: 8 channels or slots
            /// 1000: 9 channels or slots ...
            /// 1111: 16 channels or slots
            TX3_CHSEL: u4,
            /// TX3 Offset Tune (TX3 Data offset to LRCK)
            /// 0: No offset n: Data is offset by n BCLKs to LRCK
            TX3_OFFSET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x40);

        /// address: 0x2034028
        /// I2S_PCM_TXCNT
        pub const I2S_PCM_TXCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Counter The audio sample number of sending into TXFIFO. When one
            /// sample is put into TXFIFO by DMA or by host IO, the TX sample counter register
            /// increases by one. The TX sample counter register can be set to any initial value
            /// at any time. After being updated by the initial value, the counter register
            /// should count on the base of this initial value.
            TX_CNT: u32,
        }), base_address + 0x28);

        /// address: 0x2034020
        /// I2S_PCM_TXFIFO
        pub const I2S_PCM_TXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Transmitting left, right channel sample data should be written to this
            /// register one by one. The left channel sample data is first and then the right
            /// channel sample.
            TX_DATA: u32,
        }), base_address + 0x20);

        /// address: 0x2034080
        /// ASRC MCLK Configuration Register
        pub const MCLKCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frequency Division Coefficient 4’d0 = Res (no output), 4’d1 = 1x, 4’d2 =
            /// 1/2x, 4’d3 = 1/4x, 4’d4 = 1/6x, 4’d5 = 1/8x, 4’d6 = 1/12x, 4’d7 =
            /// 1/16x, 4’d8 = 1/24x, 4’d9 = 1/32x, 4’d10 = 1/48, 4’d11 = 1/64x, 4’d12
            /// = 1/96x, 4’d13 = 1/128x, 4’d14 = 1/176x, 4’d15 = 1/192x, others = Res
            ASRC_MCLK_FREQ_DIV_COE: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// ASRC Clock Gate Enable Control
            /// 0: Gated
            /// 1: Not gated
            ASRC_MCLK_GATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x80);
    };

    /// USB1
    pub const USB1 = struct {
        pub const base_address = 0x4200000;

        /// address: 0x4200028
        /// ASYNCLISTADDR
        pub const ASYNCLISTADDR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Link Pointer (LP) This field contains the address of the next asynchronous queue
            /// head to be executed. These bits correspond to memory address signals [31:5],
            /// respectively.
            LINK: u27,
        }), base_address + 0x28);

        /// address: 0x4200000
        /// CAPLENGTH
        pub const CAPLENGTH = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x0);

        /// address: 0x4200050
        /// CONFIGFLAG
        pub const CONFIGFLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configure Flag (CF) Host software sets this bit as the last action in its
            /// process of configuring the Host Controller. This bit controls the default port-
            /// routing control logic as follow: Value Meaning 0 Port routing control logic
            /// default-routs each port to an implementation dependent classic host controller.
            /// 1 Port routing control logic default-routs all ports to this host controller.
            /// The default value of this field is ‘0’. This register is not used in the
            /// normal implementation.
            CONFIGURE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x420001c
        /// FRINDEX
        pub const FRINDEX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame Index The value in this register increment at the end of each time frame
            /// (e.g. micro-frame). Bits[N:3] are used for the Frame List current index. It
            /// means that each location of the frame list is accessed 8 times (frames or
            /// Micro-frames) before moving to the next index. The following illustrates values
            /// of N based on the value of the Frame List Size field in the USBCMD register.
            /// USBCMD[Frame List Size] Number Elements N 00b 1024 12 01b 512 11 10b 256 10 11b
            /// Reserved This register must be written as a DWord. Byte writes produce undefined
            /// results.
            FRAME: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x4200008
        /// HCCPARAMS
        pub const HCCPARAMS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Programmable Frame List Flag If this bit is set to a zero, then system software
            /// must use a frame list length of 1024 elements with this host controller. The
            /// USBCMD register Frame List Size field is a read-only register and should be set
            /// to zero. If set to 1, then system software can specify and use the frame list in
            /// the USBCMD register Frame List Size field to cofigure the host controller. The
            /// frame list must always aligned on a 4K page boundary. This requirement ensures
            /// that the frame list is always physically contiguous.
            PROGRAMMABLE: u1,
            /// Asynchronous Schedule Park Capability If this bit is set to a one, then the host
            /// controller supports the park feature for high-speed queue heads in the
            /// Asynchronous Schedule. The feature can be disabled or enabled and set to a
            /// specific level by using the Asynchronous Schedule Park Mode Enable and
            /// Asynchronous Schedule Park Mode Count fields in the USBCMD register.
            ASYNCHRONOUS: u1,
            reserved1: u1,
            /// Isochronous Scheduling Threshold This field indicates, relative to the current
            /// position of the executing host controller, where software can reliably update
            /// the isochronous schedule. When bit[7] is zero, the value of the least
            /// significant 3 bits indicates the number of micro-frames a host controller can
            /// hold a set of isochronous data structures(one or more) before flushing the
            /// state. When bit[7] is a one, then host software assumes the host controller may
            /// cache an isochronous data structure for an entire frame.
            ISOCHRONOUS: u4,
            /// Extended Capabilities Pointer (EECP) This optional field indicates the existence
            /// of a capabilities list. A value of 00b indicates no extended capabilities are
            /// implemented. A non-zero value in this register indicates the offset in PCI
            /// configuration space of the first EHCI extended capabiliby. The pointer value
            /// must be 40h or greater if implemented to maintain to consistency of the PCI
            /// header defined for this calss of device. The value of this field is always
            /// ‘00b’.
            EHCI: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4200002
        /// HCIVERSION
        pub const HCIVERSION = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2);

        /// address: 0x4200004
        /// HCSPARAMS
        pub const HCSPARAMS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field specifies the number of physical downstream ports implemented on this
            /// host controller. The value of this field determines how many port registers are
            /// addressable in the Operational Register Space. Valid values are in the range of
            /// 0x1 to 0x0f. This field is always 1.
            N_PORTS: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Number of Port per Companion Controller (N_PCC) This field indicates the number
            /// of ports supported per companion host controller host controller. It is used to
            /// indicate the port routing configuration to system software. This field will
            /// always fix with ‘0’.
            NUMBER_OF_PORT_PER_COMPANION_CONTROLLER: u4,
            /// Number of Companion Controller (N_CC) This field indicates the number of
            /// companion controllers associated with this USB2.0 host controller. A zero in
            /// this field indicates there are no companion host controllers. And a value larger
            /// than zero in this field indicates there are companion USB1.1 host controller(s).
            /// This field will always be ‘0’.
            NUMBER_OF_COMPANION_CONTROLLER_THIS: u4,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Debug Port Number This register identifies which of the host controller ports is
            /// the debug port. The value is the port number (one based) of the debug port. This
            /// field will always be ‘0’.
            DEBUG_PORT_NUMBER_THIS_REGISTER_IDENTIFIES: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x420000c
        /// HCSP_PORTROUTE
        pub const HCSP_PORTROUTE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This optional field is valid only if Port Routing Rules field in HCSPARAMS
            /// register is set to a one. This field is used to allow a host controller
            /// implementation to explicitly describe to which companion host controller each
            /// implemented port is mapped. This field is a 15-element nibble array (each 4 bit
            /// is one array element). Each array location corresponds one-to-one with a
            /// physical port provided by the host controller (e.g. PORTROUTE [0] corresponds to
            /// the first PORTSC port, PORTROUTE [1] to the second PORTSC port, etc.). The value
            /// of each element indicates to which the companion host controllers this port is
            /// routed. Only the first N_PORTS elements have valid information. A value of zero
            /// indicates that the port is routed to the lowest numbered function companion host
            /// controller. A value of one indicates that the port is routed to the next lowest
            /// numbered function companion host controller, and so on.
            @"HCSP-PORTROUTE": u32,
        }), base_address + 0xc);

        /// address: 0x420042c
        /// HcBulkCurrentED_BCED_
        pub const HcBulkCurrentED_BCED_ = @intToPtr(*volatile Mmio(32, packed struct {
            /// BulkCurrentED [3:0] Because the general TD length is 16 bytes, the memory
            /// structure for the TD must be aligned to a 16-byte boundary. So the lower bits in
            /// the PCED, through bit 0 to bit 3 must be zero in this field.
            BULKCURRENTED: u4,
            /// This is advanced to the next ED after the HC has served the present one. HC
            /// continues processing the list from where it left off in the last Frame. When it
            /// reaches the end of the Bulk list, HC checks the ControlListFilled of HcControl.
            /// If set, it copies the content of to and clears the bit. If it is not set, it
            /// does nothing. HCD is only allowed to modify this register when the
            /// BulkListEnable of is cleared. When set, the HCD only reads the instantaneous
            /// value of this register. This is initially set to zero to indicate the end of the
            /// Bulk list.
            ADVANCED_TO_THE_NEXT: u28,
        }), base_address + 0x42c);

        /// address: 0x4200428
        /// HcBulkHeadED_BHED_
        pub const HcBulkHeadED_BHED_ = @intToPtr(*volatile u32, base_address + 0x428);

        /// address: 0x4200408
        /// HcCommandStatus
        pub const HcCommandStatus = @intToPtr(*volatile Mmio(32, packed struct {
            /// HostControllerReset This bit is by HCD to initiate a software reset of HC.
            /// Regardless of the functional state of HC, it moves to the USBSuspend state in
            /// which most of the operational registers are reset except those stated otherwise;
            /// e.g, the InteruptRouting field of HcControl, and no Host bus accesses are
            /// allowed. This bit is cleared by HC upon the completion of the reset operation.
            /// The reset operation must be completed within 10 ms. This bit, when set, should
            /// not cause a reset to the Root Hub and no subsequent reset signaling should be
            /// asserted to its downstream ports.
            HOSTCONTROLLERRESET: u1,
            /// ControlListFilled This bit is used to indicate whether there are any TDs on the
            /// Control list. It is set by HCD whenever it adds a TD to an ED in the Control
            /// list. When HC begins to process the head of the Control list, it checks CLF. As
            /// long as ControlListFilled is 0, HC will not start processing the Control list.
            /// If CF is 1, HC will start processing the Control list and will set
            /// ControlListFilled to 0. If HC finds a TD on the list, then HC will set
            /// ControlListFilled to 1 causing the Control list processing to continue. If no TD
            /// is found on the Control list, and if the HCD does not set ControlListFilled ,
            /// then ControlListFilled will still be 0 when HC completes processing the Control
            /// list and Control list processing will stop.
            CONTROLLISTFILLED: u1,
            /// BulklListFilled This bit is used to indicate whether there are any TDs on the
            /// Bulk list. It is set by HCD whenever it adds a TD to an ED in the Bulk list.
            /// When HC begins to process the head of the Bulk list, it checks BLF. As long as
            /// BulkListFilled is 0, HC will not start processing the Bulk list. If
            /// BulkListFilled is 1, HC will start processing the Bulk list and will set BF to
            /// 0. If HC finds a TD on the list, then HC will set BulkListFilled to 1 causing
            /// the Bulk list processing to continue. If no TD is found on the Bulk list, and if
            /// HCD does not set BulkListFilled , then BulkListFilled will still be 0 when HC
            /// completes processing the Bulk list and Bulk list processing will stop.
            BULKLLISTFILLED: u1,
            /// OwershipChangeRequest This bit is set by an OS HCD to request a change of
            /// control of the HC. When set HC will set the OwnershipChange field in . After the
            /// changeover, this bit is cleared and remains so until the next request from OS
            /// HCD.
            OWERSHIPCHANGEREQUEST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// SchedulingOverrunCount These bits are incremented on each scheduling overrun
            /// error. It is initialized to 00b and wraps around at 11b. This will be
            /// incremented when a scheduling overrun is detected even if SchedulingOverrun in
            /// has already been set. This is used by HCD to monitor any persistent scheduling
            /// problem.
            SCHEDULINGOVERRUNCOUNT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x408);

        /// address: 0x4200424
        /// HcControlCurrentED_CCED_
        pub const HcControlCurrentED_CCED_ = @intToPtr(*volatile u32, base_address + 0x424);

        /// address: 0x4200420
        /// HcControlHeadED_CHED_
        pub const HcControlHeadED_CHED_ = @intToPtr(*volatile u32, base_address + 0x420);

        /// address: 0x4200430
        /// HcDoneHead
        pub const HcDoneHead = @intToPtr(*volatile u32, base_address + 0x430);

        /// address: 0x4200434
        /// HcFmInterval_Register
        pub const HcFmInterval_Register = @intToPtr(*volatile Mmio(32, packed struct {
            /// FrameInterval This specifies the interval between two consecutive SOFs in bit
            /// times. The nominal value is set to be 11,999. HCD should store the current value
            /// of this field before resetting HC. By setting the HostControllerReset field of
            /// as this will cause the HC to reset this field to its nominal value. HCD may
            /// choose to restore the stored value upon the completion of the Reset sequence.
            FRAMEINTERVAL: u14,
            reserved0: u1,
            reserved1: u1,
            /// FSLargestDataPacket This field specifies a value which is loaded into the
            /// Largest Data Packet Counter at the beginning of each frame. The counter value
            /// represents the largest amount of data in bits which can be sent or received by
            /// the HC in a single transaction at any given time without causing scheduling
            /// overrun. The field value is calculated by the HCD.
            FSLARGESTDATAPACKET: u15,
            /// FrameIntervalToggler HCD toggles this bit whenever it loads a new value to
            /// FrameInterval .
            FRAMEINTERVALTOGGLER: u1,
        }), base_address + 0x434);

        /// address: 0x420043c
        /// HcFmNumber
        pub const HcFmNumber = @intToPtr(*volatile Mmio(32, packed struct {
            /// FrameNumber This is incremented when is re-loaded. It will be rolled over to 0x0
            /// after 0x0ffff. When entering the USBOPERATIONAL state, this will be incremented
            /// automatically. The content will be written to HCCA after HC has incremented the
            /// FrameNumber at each frame boundary and sent a SOF but before HC reads the first
            /// ED in that Frame. After writing to HCCA, HC will set the StartofFrame in
            FRAMENUMBER: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x43c);

        /// address: 0x4200438
        /// HcFmRemaining
        pub const HcFmRemaining = @intToPtr(*volatile Mmio(32, packed struct {
            /// FramRemaining This counter is decremented at each bit time. When it reaches
            /// zero, it is reset by loading the FrameInterval value specified in at the next
            /// bit time boundary. When entering the USBOPERATIONAL state, HC re-loads the
            /// content with the FrameInterval of and uses the updated value from the next SOF.
            FRAMREMAINING: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// FrameRemaining Toggle This bit is loaded from the FrameIntervalToggle field of
            /// whenever FrameRemaining reaches 0. This bit is used by HCD for the
            /// synchronization between FrameInterval and FrameRemaining .
            FRAMEREMAINING: u1,
        }), base_address + 0x438);

        /// address: 0x4200418
        /// HcHCCA
        pub const HcHCCA = @intToPtr(*volatile u32, base_address + 0x418);

        /// address: 0x4200414
        /// HcInterruptDisable_Register
        pub const HcInterruptDisable_Register = @intToPtr(*volatile Mmio(32, packed struct {
            /// SchedulingOverrun Interrupt Disable 0 Ignore; 1 Disable interrupt generation due
            /// to Scheduling Overrun;
            SCHEDULINGOVERRUN: u1,
            /// WritebackDoneHead Interrupt Disable 0 Ignore; 1 Disable interrupt generation due
            /// to Write back Done Head;
            WRITEBACKDONEHEAD: u1,
            /// StartofFrame Interrupt Disable 0 Ignore; 1 Disable interrupt generation due to
            /// Start of Flame;
            STARTOFFRAME: u1,
            /// ResumeDetected Interrupt Disable 0 Ignore; 1 Disable interrupt generation due to
            /// Resume Detected;
            RESUMEDETECTED: u1,
            /// UnrecoverableError Interrupt Disable 0 Ignore; 1 Disable interrupt generation
            /// due to Unrecoverable Error;
            UNRECOVERABLEERROR: u1,
            /// FrameNumberOverflow Interrupt Disable 0 Ignore; 1 Disable interrupt generation
            /// due to Frame Number Over Flow;
            FRAMENUMBEROVERFLOW: u1,
            /// RootHubStatusChange Interrupt Disable 0 Ignore; 1 Disable interrupt generation
            /// due to Root Hub Status Change;
            ROOTHUBSTATUSCHANGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// MasterInterruptEnable A written ‘0’ to this field is ignored by HC. A
            /// ‘1’ written to this field disables interrupt generation due events specified
            /// in the other bits of this register. This field is set after a hardware or
            /// software reset.
            MASTERINTERRUPTENABLE: u1,
        }), base_address + 0x414);

        /// address: 0x4200410
        /// HcInterruptEnable_Register
        pub const HcInterruptEnable_Register = @intToPtr(*volatile Mmio(32, packed struct {
            /// SchedulingOverrun Interrupt Enable 0 Ignore; 1 Enable interrupt generation due
            /// to Scheduling Overrun;
            SCHEDULINGOVERRUN: u1,
            /// WritebackDoneHead Interrupt Enable 0 Ignore; 1 Enable interrupt generation due
            /// to Write back Done Head;
            WRITEBACKDONEHEAD: u1,
            /// StartofFrame Interrupt Enable 0 Ignore; 1 Enable interrupt generation due to
            /// Start of Flame;
            STARTOFFRAME: u1,
            /// ResumeDetected Interrupt Enable 0 Ignore; 1 Enable interrupt generation due to
            /// Resume Detected;
            RESUMEDETECTED: u1,
            /// UnrecoverableError Interrupt Enable 0 Ignore; 1 Enable interrupt generation due
            /// to Unrecoverable Error;
            UNRECOVERABLEERROR: u1,
            /// FrameNumberOverflow Interrupt Enable 0 Ignore; 1 Enable interrupt generation due
            /// to Frame Number Over Flow;
            FRAMENUMBEROVERFLOW: u1,
            /// RootHubStatusChange Interrupt Enable 0 Ignore; 1 Enable interrupt generation due
            /// to Root Hub Status Change;
            ROOTHUBSTATUSCHANGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// MasterInterruptEnable A ‘0’ writtern to this field is ignored by HC. A
            /// ‘1’ written to this field enables interrupt generation due to events
            /// specified in the other bits of this register. This is used by HCD as Master
            /// Interrupt Enable.
            MASTERINTERRUPTENABLE: u1,
        }), base_address + 0x410);

        /// address: 0x420040c
        /// HcInterruptStatus
        pub const HcInterruptStatus = @intToPtr(*volatile Mmio(32, packed struct {
            /// SchedulingOverrun This bit is set when the USB schedule for the current Frame
            /// overruns and after the update of . A scheduling overrun will also cause the
            /// SchedulingOverrunCount of to be incremented.
            SCHEDULINGOVERRUN: u1,
            /// WritebackDoneHead This bit is set immediately after HC has written to . Further
            /// updates of the will not occur until this bit has been cleared. HCD should only
            /// clear this bit after it has saved the content of .
            WRITEBACKDONEHEAD: u1,
            /// StartofFrame This bit is set by HC at each start of frame and after the update
            /// of HccaFrameNumber. HC also generates a SOF token at the same time.
            STARTOFFRAME: u1,
            /// ResumeDetected This bit is set when HC detects that a device on the USB is
            /// asserting resume signaling. It is the transition from no resume signaling to
            /// resume signaling causing this bit to be set. This bit is not set when HCD sets
            /// the USBRseume state.
            RESUMEDETECTED: u1,
            /// UnrecoverableError This bit is set when HC detects a system error not related to
            /// USB. HC should not proceed with any processing nor signaling before the system
            /// error has been corrected. HCD clears this bit after HC has been reset.
            UNRECOVERABLEERROR: u1,
            /// FrameNumberOverflow This bit is set when the MSb of (bit 15) changes value, from
            /// 0 to 1 or from 1 to 0, and after has been updated.
            FRAMENUMBEROVERFLOW: u1,
            /// RootHubStatusChange This bit is set when the content of or the content of any of
            /// [ NumberofDownstreamPort ] has changed.
            ROOTHUBSTATUSCHANGE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x40c);

        /// address: 0x4200444
        /// HcLSThreshold
        pub const HcLSThreshold = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSThreshold This field contains a value which is compared to the FrameRemaining
            /// field prior to initiating a Low Speed transaction. The transaction is started
            /// only if FrameRemaining this field. The value is calculated by HCD with the
            /// consideration of transmission and setup overhead.
            LSTHRESHOLD: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x444);

        /// address: 0x420041c
        /// HcPeriodCurrentED_PCED_
        pub const HcPeriodCurrentED_PCED_ = @intToPtr(*volatile u32, base_address + 0x41c);

        /// address: 0x4200440
        /// HcPeriodicStatus
        pub const HcPeriodicStatus = @intToPtr(*volatile Mmio(32, packed struct {
            /// PeriodicStart After a hardware reset, this field is cleared. This is then set by
            /// HCD during the HC initialization. The value is calculated roughly as 10% off
            /// from . A typical value will be 0x2A3F (or 0x3e67). When reaches the value
            /// specified, processing of the periodic lists will have priority over Control/Bulk
            /// processing. HC will therefore start processing the Interrupt list after
            /// completing the current Control or Bulk transaction that is in progress.
            PERIODICSTART: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x440);

        /// address: 0x4200404
        /// HcRevision
        pub const HcRevision = @intToPtr(*volatile Mmio(32, packed struct {
            /// ControlBulkServiceRatio This specifies the service ratio between Control and
            /// Bulk EDs. Before processing any of the nonperiodic lists, HC must compare the
            /// ratio specified with its internal count on how many nonempty Control EDs have
            /// been processed, in determining whether to continue serving another Control ED or
            /// switching to Bulk EDs. The internal count will be retained when crossing the
            /// frame boundary. In case of reset, HCD is responsible for restoring this value.
            /// CBSR No. of Control EDs Over Bulk EDs Served 0 1:1 1 2:1 2 3:1 3 4:1 The default
            /// value is 0x0.
            CONTROLBULKSERVICERATIO_THIS_SPECIFIES_THE_SERVICE_RATIO: u2,
            reserved0: u1,
            /// IsochronousEnable This bit is used by HCD to enable/disable processing of
            /// isochronous EDs. While processing the periodic list in a Frame, HC checks the
            /// status of this bit when it finds an Isochronous ED (F=1). If set (enabled), HC
            /// continues processing the EDs. If cleared (disabled), HC halts processing of the
            /// periodic list (which now contains only isochronous EDs) and begins processing
            /// the Bulk/Control lists. Setting this bit is guaranteed to take effect in the
            /// next Frame (not the current Frame).
            ISOCHRONOUSENABLE_THIS_BIT_IS_USED_PROCESSING: u1,
            reserved1: u1,
            reserved2: u1,
            /// 00b USBReset 01b USBResume 10b USBOperational 11b USBSuspend A transition to
            /// USBOperational from another state causes SOF generation to begin 1 ms later. HCD
            /// may determine whether HC has begun sending SOFs by reading the StartoFrame field
            /// of HcInterruptStatus. This field may be changed by HC only when in the
            /// USBSUSPEND state. HC may move from the USBSUSPEND state to the USBRESUME state
            /// after detecting the resume signaling from a downstream port. HC enters
            /// USBSUSPEND after a software reset, whereas it enters USBRESET after a hardware
            /// reset. The latter also resets the Root Hub and asserts subsequent reset
            /// signaling to downstream ports.
            USBRESET_USBRESUME_USBOPERATIONAL: u2,
            /// InterruptRouting This bit determines the routing of interrupts generated by
            /// events registered in HcInterruptStatus. If clear, all interrupt are routed to
            /// the normal host bus interrupt mechanism. If set interrupts are routed to the
            /// System Management Interrupt. HCD clears this bit upon a hardware reset, but it
            /// does not alter this bit upon a software reset. HCD uses this bit as a tag to
            /// indicate the ownership of HC.
            INTERRUPTROUTING_THIS_BIT_DETERMINES_THE_ROUTING: u1,
            /// This bit indicates whether HC supports remote wakeup signaling. If remote wakeup
            /// is supported and used by the system, it is the responsibility of system firmware
            /// to set this bit during POST. HC clear the bit upon a hardware reset but does not
            /// alter it upon a software reset. Remote wakeup signaling of the host system is
            /// host-bus-specific and is not described in this specification.
            HC_SUPPORTS_REMOTE_WAKEUP_SIGNALING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x404);

        /// address: 0x4200448
        /// HcRhDescriptorA
        pub const HcRhDescriptorA = @intToPtr(*volatile Mmio(32, packed struct {
            /// NumberDownstreamPorts These bits specify the number of downstream ports
            /// supported by the Root Hub. It is implementation-specific. The minimum number of
            /// ports is 1. The maximum number of ports supported.
            NUMBERDOWNSTREAMPORTS: u8,
            /// NoPowerSwithcing These bits are used to specify whether power switching is
            /// supported or ports are always powered. It is implementation- specific. When this
            /// bit is cleared, the PowerSwitchingMode specifies global or per-port switching. 0
            /// Ports are power switched. 1 Ports are always powered on when the HC is powered
            /// on.
            NOPOWERSWITHCING: u1,
            /// PowerSwitchingMode This bit is used to specify how the power switching of the
            /// Root Hub ports is controlled. It is implementation-specific. This field is only
            /// valid if the NoPowerSwitching field is cleared. 0 All ports are powered at the
            /// same time. 1 Each port is powered individually. This mode allows port power to
            /// be controlled by either the global switch or per- port switching. If the
            /// PortPowerControlMask bit is set, the port responds only to port power commands (
            /// Set/ClearPortPower ). If the port mask is cleared, then the port is controlled
            /// only by the global power switch ( Set/ClearGlobalPower ).
            POWERSWITCHINGMODE: u1,
            /// Device Type This bit specifies that the Root Hub is not a compound device. The
            /// Root Hub is not permitted to be a compound device. This field should always
            /// read/write 0.
            DEVICE: u1,
            /// OverCurrentProtectionMode This bit describes how the overcurrent status for the
            /// Root Hub ports are reported. At reset, these fields should reflect the same mode
            /// as PowerSwitchingMode . This field is valid only if the NoOverCurrentProtection
            /// field is cleared. 0 Over-current status is reported collectively for all
            /// downstream ports. 1 Over-current status is reported on per-port basis.
            OVERCURRENTPROTECTIONMODE: u1,
            /// NoOverCurrentProtection This bit describes how the overcurrent status for the
            /// Root Hub ports are reported. When this bit is cleared, the
            /// OverCurrentProtectionMode field specifies global or per-port reporting. 0
            /// Over-current status is reported collectively for all downstream ports. 1 No
            /// overcurrent protection supported.
            NOOVERCURRENTPROTECTION: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PowerOnToPowerGoodTime[POTPGT] This byte specifies the duration HCD has to wait
            /// before accessing a powered-on port of the Root Hub. It is
            /// implementation-specific. The unit of time is 2 ms. The duration is calculated as
            /// POTPGT * 2ms.
            POWERONTOPOWERGOODTIME: u8,
        }), base_address + 0x448);

        /// address: 0x420044c
        /// HcRhDescriptorB_Register
        pub const HcRhDescriptorB_Register = @intToPtr(*volatile Mmio(32, packed struct {
            /// DeviceRemovable Each bit is dedicated to a port of the Root Hub. When cleared,
            /// the attached device is removable. When set, the attached device is not
            /// removable. Bit0 Reserved Bit1 Device attached to Port #1. Bit2 Device attached
            /// to Port #2. … Bit15 Device attached to Port #15.
            DEVICEREMOVABLE: u16,
            /// PortPowerControlMask Each bit indicates if a port is affected by a global power
            /// control command when PowerSwitchingMode is set. When set, the port's power state
            /// is only affected by per-port power control ( Set/ClearPortPower ). When cleared,
            /// the port is controlled by the global power switch ( Set/ClearGlobalPower ). If
            /// the device is configured to global switching mode ( PowerSwitchingMode = 0 ),
            /// this field is not valid. Bit0 Reserved Bit1 Ganged-power mask on Port #1. Bit2
            /// Ganged-power mask on Port #2. … Bit15 Ganged-power mask on Port #15.
            PORTPOWERCONTROLMASK: u16,
        }), base_address + 0x44c);

        /// address: 0x4200454
        /// HcRhPortStatus
        pub const HcRhPortStatus = @intToPtr(*volatile Mmio(32, packed struct {
            /// CurrentConnectStatus This bit reflects the current state of the downstream port.
            /// 0 No device connected 1 Device connected (write) ClearPortEnable The HCD writes
            /// a ‘1’ to clear the PortEnableStatus bit. Writing ‘0’ to this bit has no
            /// effect. The CurrentConnectStatus is not affected by any write. Note: This bit is
            /// always read ‘1’ when the attached device is nonremovalble
            /// (DviceRemoveable[NumberDownstreamPort]).
            CURRENTCONNECTSTATUS_THIS_BIT_REFLECTS_THE_CURRENT: u1,
            reserved0: u1,
            /// PortSuspendStatus This bit indicates the port is suspended or in the resume
            /// sequence. It is set by a SetSuspendState write and cleared when
            /// PortSuspendStatusChange is set at the end of the resume interval. This bit
            /// cannot be set if CurrentConnectStatus is cleared. This bit is also cleared when
            /// PortResetStatusChange is set at the end of the port reset or when the HC is
            /// placed in the USBRESUME state. If an upstream resume is in progress, it should
            /// propagate to the HC. 0 port is not suspended 1 port is suspended (write)
            /// SetPortSuspend The HCD sets the PortSuspendStatus bit by writing a ‘1’ to
            /// this bit. Writing a ‘0’ has no effect. If CurrentConnectStatus is cleared,
            /// this write does not set PortSuspendStatus ; instead it sets ConnectStatusChange
            /// . This informs the driver that it attempted to suspend a disconnected port.
            PORTSUSPENDSTATUS_THIS_BIT_INDICATES_THE_PORT: u1,
            /// PortOverCurrentIndicator This bit is only valid when the Root Hub is configured
            /// in such a way that overcurrent conditions are reported on a per-port basis. If
            /// per-port overcurrent reporting is not supported, this bit is set to 0. If
            /// cleared, all power operations are normal for this port. If set, an overcurrent
            /// condition exists on this port. This bit always reflects the overcurrent input
            /// signal. 0 no overcurrent condition. 1 overcurrent condition detected. (write)
            /// ClearSuspendStatus The HCD writes a ‘1’ to initiate a resume. Writing a
            /// ‘0’ has no effect. A resume is initiated only if PortSuspendStatus is set.
            PORTOVERCURRENTINDICATOR_THIS_BIT_IS_ONLY_VALID: u1,
            /// PortResetStatus When this bit is set by a write to SetPortReset , port reset
            /// signaling is asserted. When reset is completed, this bit is cleared when
            /// PortResetStatusChange is set. This bit cannot be set if CurrentConnectStatus is
            /// cleared. 0 port reset signal is not active 1 port reset signal is active (write)
            /// SetPortReset The HCD sets the port reset signaling by writing a ‘1’ to this
            /// bit. Writing a ‘0’ has no effect. If CurrentConnectStatus is cleared, this
            /// write does not set PortResetStatus , but instead sets ConnectStatusChange . This
            /// informs the driver that it attempted to reset a disconnected port.
            PORTRESETSTATUS_WHEN_THIS_BIT_IS_SET: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// LowSpeedDeviceAttached This bit indicates the speed of the device attached to
            /// this port. When set, a Low Speed device is attached to this port. When clear, a
            /// Full Speed device is attached to this port. This field is valid only when the
            /// CurrentConnectStatus is set. 0 full speed device attached 1 low speed device
            /// attached (write) ClearPortPower The HCD clears the PortPowerStatus bit by
            /// writing a ‘1’ to this bit. Writing a ‘0’ has no effect.
            LOWSPEEDDEVICEATTACHED_THIS_BIT_INDICATES_THE_SPEED: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// This bit is set whenever a connect or disconnect event occurs. The HCD writes a
            /// ‘1’ to clear this bit. Writing a ‘0’ has no effect. If
            /// CurrentConnectStatus is cleared when a SetPortReset,SetPortEnable , or
            /// SetPortSuspend write occurs, this bit is set to force the driver to re-evaluate
            /// the connection status since these writes should not occur if the port is
            /// disconnected. 0 no change in PortEnableStatus 1 change in PortEnableStatus Note:
            /// If the DeviceRemovable[NDP] bit is set, this bit is set only after a Root Hub
            /// reset to inform the system that the device is attached.
            WHENEVER_A_CONNECT_OR_DISCONNECT_EVENT: u1,
            /// This bit is set when hardware events cause the PortEnableStatus bit to be
            /// cleared. Changes from HCD writes do not set this bit. The HCD writes a ‘1’
            /// to clear this bit. Writing a ‘0’ has no effect. 0 no change in
            /// PortEnableStatus 1 change in PortEnableStatus
            HARDWARE_EVENTS_CAUSE_THE_PORTENABLESTATUS_BIT: u1,
            /// This bit is set when the full resume sequence has been completed. This sequence
            /// includes the 20-s resume pulse, LS EOP, and 3-ms resychronization delay. The HCD
            /// writes a ‘1’ to clear this bit. Writing a ‘0’ has no effect. This bit is
            /// also cleared when ResetStatusChange is set. 0 resume is not completed 1 resume
            /// completed
            FULL_RESUME_SEQUENCE_HAS_BEEN_COMPLETED: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x454);

        /// address: 0x4200450
        /// HcRhStatus_Register
        pub const HcRhStatus_Register = @intToPtr(*volatile Mmio(32, packed struct {
            /// (Read)LocalPowerStatus When read, this bit returns the LocalPowerStatus of the
            /// Root Hub. The Root Hub does not support the local power status feature; thus,
            /// this bit is always read as ‘0’. (Write)ClearGlobalPower When write, this bit
            /// is operated as the ClearGlobalPower. In global power mode ( PowerSwitchingMode
            /// =0), This bit is written to ‘1’ to turn off power to all ports (clear
            /// PortPowerStatus ). In per-port power mode, it clears PortPowerStatus only on
            /// ports whose PortPowerControlMask bit is not set. Writing a ‘0’ has no
            /// effect.
            WHEN_READ: u1,
            /// This bit reports overcurrent conditions when the global reporting is
            /// implemented. When set, an overcurrent condition exists. When cleared, all power
            /// operations are normal. If per-port overcurrent protection is implemented this
            /// bit is always ‘0’
            REPORTS_OVERCURRENT_CONDITIONS_WHEN_THE_GLOBAL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// (read)DeviceRemoteWakeupEnable This bit enables a ConnectStatusChange bit as a
            /// resume event, causing a USBSUSPEND to USBRESUME state transition and setting the
            /// ResumeDetected interrupt. 0 ConnectStatusChange is not a remote wakeup event. 1
            /// ConnectStatusChange is a remote wakeup event. (write)SetRemoteWakeupEnable
            /// Writing a ‘1’ sets DeviceRemoveWakeupEnable. Writing a ‘0’ has no
            /// effect.
            THIS_BIT_ENABLES_A_CONNECTSTATUSCHANGE: u1,
            /// (read)LocalPowerStartusChange The Root Hub does not support the local power
            /// status features, thus, this bit is always read as ‘0’. (write)SetGlobalPower
            /// In global power mode ( PowerSwitchingMode =0), This bit is written to ‘1’ to
            /// turn on power to all ports (clear PortPowerStatus ). In per-port power mode, it
            /// sets PortPowerStatus only on ports whose PortPowerControlMask bit is not set.
            /// Writing a ‘0’ has no effect.
            THE_ROOT_HUB_DOES_NOT: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            /// (write)ClearRemoteWakeupEnable Write a ‘1’ clears DeviceRemoteWakeupEnable.
            /// Writing a ‘0’ has no effect.
            WRITE_A_CLEARS_DEVICEREMOTEWAKEUPENABLE: u1,
        }), base_address + 0x450);

        /// address: 0x4200024
        /// PERIODICLISTBASE
        pub const PERIODICLISTBASE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Base Address These bits correspond to memory address signals [31:12],
            /// respectively. This register contains the beginning address of the Periodic Frame
            /// List in the system memory. System software loads this register prior to starting
            /// the schedule execution by the Host Controller. The memory structure referenced
            /// by this physical memory pointer is assumed to be 4 Kbyte aligned. The contents
            /// of this register are combined with the Frame Index Register (FRINDEX) to enable
            /// the Host Controller to step through the Periodic Frame List in sequence.
            BASE: u20,
        }), base_address + 0x24);

        /// address: 0x4200810
        /// PHY_CTRL
        pub const PHY_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// vc_clk
            VC_CLK: u1,
            reserved0: u1,
            reserved1: u1,
            /// 1: Write 1 to disable phy
            /// 0: Write 0 to enable phy
            SIDDQ: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// vc_di
            VC_DI: u1,
            /// vc_addr
            VC_ADDR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x810);

        /// address: 0x4200054
        /// PORTSC
        pub const PORTSC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Connect Status Device is present on port when the value of this field is
            /// a one, and no device is present on port when the value of this field is a zero.
            /// This value reflects the current state of the port, and may not correspond
            /// directly to the event that caused the Connect Status Change(Bit 1) to be set.
            /// This field is zero if Port Power zero. This register is only reset by hardware
            /// or in response to a host controller reset.
            CURRENT_CONNECT_STATUS_DEVICE_IS_PRESENT: u1,
            /// Connect Status Change 1=Change in Current Connect Status 0=No change Indicates a
            /// change has occurred in the current connect status of the port. The host
            /// controller sets this bit for all changes to the port device connect status, even
            /// if system software has not cleared an existing connect status change. For
            /// example, the insertion status changes twice before system software has cleared
            /// the changed condition, hub hardware will be “setting” an already-set bit.
            /// Software sets this bit to 0 by writing a 1 to it. This field is zero if Port
            /// Power is zero.
            CONNECT_STATUS_CHANGE_IN_CURRENT: u1,
            /// Port Enabled/Disabled 1=Enable 0=Disable Ports can only be enabled by the host
            /// controller as a part of the reset and enable. Software cannot enable a port by
            /// writing a one to this field. The host controller will only set this bit to a one
            /// when the reset sequence determines that the attached device is a high- speed
            /// device. Ports can be disabled by either a fault condition(disconnect event or
            /// other fault condition) or by host software. Note that the bit status does not
            /// change until the port state actually changes. There may be a delay in disabling
            /// or enabling a port due to other host controller and bus events. When the port is
            /// disabled, downstream propagation of data is blocked on this port except for
            /// reset. The default value of this field is ‘0’. This field is zero if Port
            /// Power is zero.
            @"PORT_ENABLED/DISABLED_PORTS_CAN": u1,
            /// Port Enable/Disable Change 1 = Port enabled/disabled status has changed 0 = No
            /// change For the root hub, this bit gets set to a one only when a port is disabled
            /// due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of
            /// the USB Specification for the definition of a Port Error). Software clears this
            /// bit by writing a 1 to it. This field is zero if Port Power is zero.
            @"PORT_ENABLE/DISABLE_CHANGE_PORT": u1,
            /// Over-current Active 0 = This port does not have an over-current condition 1 =
            /// This port currently has an over-current condition This bit will automatically
            /// transition from a one to a zero when the over current condition is removed. The
            /// default value of this bit is ‘0’.
            @"OVER-CURRENT_ACTIVE_THIS_PORT": u1,
            /// Over-current Change This bit gets set to a one when there is a change to
            /// Over-current Active. Software clears this bit by writing a one to this bit
            /// position.
            @"OVER-CURRENT_CHANGE_THIS_BIT_GETS_SET": u1,
            /// Force Port Resume 1 = Resume detected/driven on port. 0 = No resume (K-state)
            /// detected/driven on port. Default value = 0. This functionality defined for
            /// manipulating this bit depends on the value of the Suspend bit. For example, if
            /// the port is not suspend and software transitions this bit to a one, then the
            /// effects on the bus are undefined. Software sets this bit to 1 to drive resume
            /// signaling. The Host Controller sets this bit to a 1 if a J-to-K transition is
            /// detected while the port is in the Suspend state. When this bit transitions to a
            /// one because a J-to-K transition is detected, the Port Change Detect bit in the
            /// USBSTS register is also set to a one. If software sets this bit to a one, the
            /// host controller must not set the Port Change Detect bit. Note that when the EHCI
            /// controller owns the port, the resume sequence follows the defined sequence
            /// documented in the USB Specification Revision 2.0. The resume signaling
            /// (Full-speed ‘K’) is driven on the port as long as this remains a one.
            /// Software must appropriately time the Resume and set this bit to a zero when the
            /// appropriate amount of time has elapsed. Writing a zero (from one) causes the
            /// port to return high-speed mode (forcing the bus below the port into a high-speed
            /// idle). This bit will remain a one until the port has switched to high-speed
            /// idle. The host controller must complete this transition within 2 milliseconds of
            /// software setting this bit to a zero. This field is zero if Port Power is zero.
            FORCE_PORT_RESUME_RESUME: u1,
            /// Suspend Port Enabled Bit and Suspend bit of this register define the port states
            /// as follows: Bits[Port Enables, Suspend] Port State 0x Disable 10 Enable 11
            /// Suspend When in suspend state, downstream propagation of data is blocked on this
            /// port, except for port reset. The blocking occurs at the end of the current
            /// transaction, if a transaction was in progress when this bit was written to 1. In
            /// the suspend state, the port is sensitive to resume detection. Not that the bit
            /// status does not change until the port is suspend and that there may be a delay
            /// in suspending a port if there is a transaction currently in progress on the USB.
            /// A write of zero to this bit is ignored by the host controller. The host
            /// controller will unconditionally set this bit to a zero when: ① Software sets
            /// the Force Port Resume bit to a zero(from a one). ② Software sets the Port
            /// Reset bit to a one(from a zero). If host software sets this bit to a one when
            /// the port is not enabled(i.e. Port enabled bit is a zero), the results are
            /// undefined. This field is zero if Port Power is zero. The default value in this
            /// field is ‘0’.
            SUSPEND_PORT_ENABLED_BIT_AND_SUSPEND: u1,
            /// Port Reset 1=Port is in Reset. 0=Port is not in Reset. Default value = 0. When
            /// software writes a one to this bit (from a zero), the bus reset sequence as
            /// defined in the USB Specification Revision 2.0 is started. Software writes a zero
            /// to this bit to terminate the bus reset sequence. Software must keep this bit at
            /// a one long enough to ensure the reset sequence, as specified in the USB
            /// Specification Revision 2.0, completes. Note that when software writes a zero to
            /// this bit there may be a delay before the bit status changes to a zero. The bit
            /// status will not read as a zero until after the reset has completed. If the port
            /// is in high-speed mode after reset is complete, the host controller will
            /// automatically enable this port (e.g. set the Port Enable bit to a one). A host
            /// controller must terminate the reset and stabilize the state of the port within 2
            /// milliseconds of software transitioning this bit from a one to a zero. For
            /// example: if the port detects that the attached device is high-speed during
            /// reset, then the host controller must have the port in the enabled state with 2ms
            /// of software writing this bit to a zero. The HC Halted bit in the USBSTS register
            /// should be a zero before software attempts to use this bit. The host controller
            /// may hold Port Reset asserted to a one when the HC Halted bit is a one. This
            /// field is zero if Port Power is zero.
            PORT_RESET_IS_IN_RESET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Port Owner This bit unconditionally goes to a 0b when the Configured bit in the
            /// CONFIGFLAG register makes a 0b to 1b transition. This bit unconditionally goes
            /// to 1b whenever the Configured bit is zero. System software uses this field to
            /// release ownership of the port to selected host controller (in the event that the
            /// attached device is not a high-speed device).Software writes a one to this bit
            /// when the attached device is not a high-speed device. A one in this bit means
            /// that a companion host controller owns and controls the port. Default Value = 1b.
            PORT_OWNER_THIS_BIT_UNCONDITIONALLY_GOES: u1,
            reserved4: u1,
            reserved5: u1,
            /// Port Test Control The value in this field specifies the test mode of the port.
            /// The encoding of the test mode bits are as follows: Bits Test Mode 0000b The port
            /// is NOT operating in a test mode. 0001b Test J_STATE 0010b Test K_STATE 0011b
            /// Test SE0_NAK 0100b Test Packet 0101b Test FORCE_ENABLE 0110b- 1111b Reserved The
            /// default value in this field is ‘0000b’.
            PORT_TEST_CONTROL_THE_VALUE_IN: u4,
            /// Wake on Connect Enable (WKCNNT_E) Writing this bit to a one enable the port to
            /// be sensitive to device connects as wake-up events. This field is zero if Port
            /// Power is zero. The default value in this field is ‘0’.
            WAKE_ON_CONNECT_ENABLE_WRITING: u1,
            /// Wake on Disconnect Enable (WKDSCNNT_E) Writing this bit to a one enables the
            /// port to be sensitive to device disconnects as wake-up events. This field is zero
            /// if Port Power is zero. The default value in this field is ‘0’.
            WAKE_ON_DISCONNECT_ENABLE_WRITING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x54);

        /// address: 0x4200010
        /// USBCMD
        pub const USBCMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Run/Stop When set to a 1, the Host Controller proceeds with execution of the
            /// schedule. When set to 0, the Host Controller completes the current and any
            /// actively pipelined transactions on the USB and then halts. The Host Controller
            /// must halt within 16 micro-frames after software clears this bit. The HC Halted
            /// bit indicates when the Host Controller has finished its pending pipelined
            /// transactions and has entered the stopped state. Software must not write a one to
            /// this field unless the Host Controller is in the Halt State. The default value is
            /// 0x0.
            @"RUN/STOP_WHEN_SET_TO_A_1": u1,
            /// Host Controller Reset This control bit is used by software to reset the host
            /// controller. The effects of this on Root Hub registers are similar to a Chip
            /// Hardware Reset. When software writes a one to this bit, the Host Controller
            /// resets its internal pipelines, timers, counters, state machines, etc. to their
            /// initial value. Any transaction currently in progress on USB is immediately
            /// terminated. A USB reset is not driven on downstream ports. All operational
            /// registers, including port registers and port state machines are set to their
            /// initial values. Port ownership reverts to the companion host controller(s).
            /// Software must reinitialize the host controller as described in Section 4.1 of
            /// the CHEI Specification in order to return the host controller to an operational
            /// state. This bit is set to zero by the Host Controller when the reset process is
            /// complete. Software cannot terminate the reset process early by writing a zero to
            /// this register. Software should not set this bit to a one when the HC Halted bit
            /// in the USBSTS register is a zero. Attempting to reset an actively running host
            /// controller will result in undefined behavior.
            HOST_CONTROLLER_RESET_THIS_CONTROL_BIT: u1,
            reserved0: u1,
            reserved1: u1,
            /// Periodic Schedule Enable This bit controls whether the host controller skips
            /// processing the Periodic Schedule. Values mean: Bit Value Meaning 0 Do not
            /// process the Periodic Schedule. 1 Use the PERIODICLISTBASE register to access the
            /// Periodic Schedule. The default value of this field is ‘0b’.
            PERIODIC_SCHEDULE_ENABLE_THIS_BIT_CONTROLS: u1,
            /// Asynchronous Schedule Enable This bit controls whether the host controller skips
            /// processing the Asynchronous Schedule. Values mean: Bit Value Meaning 0 Do not
            /// process the Asynchronous Schedule. 1 Use the ASYNLISTADDR register to access the
            /// Asynchronous Schedule. The default value of this field is ‘0b’.
            ASYNCHRONOUS_SCHEDULE_ENABLE_THIS_BIT_CONTROLS: u1,
            /// Interrupt on Async Advance Doorbell This bit is used as a doorbell by software
            /// to tell the host controller to issue an interrupt the next time it advances
            /// asynchronous schedule. Software must write a 1 to this bit to ring the doorbell.
            /// When the host controller has evicted all appropriate cached schedule state, it
            /// sets the Interrupt on Async Advance status bit in the USBSTS. if the Interrupt
            /// on Async Advance Enable bit in the USBINTR register is a one then the host
            /// controller will assert an interrupt at the next interrupt threshold. The host
            /// controller sets this bit to a zero after it has set the Interrupt on Async
            /// Advance status bit in the USBSTS register to a one. Software should not write a
            /// one to this bit when the asynchronous schedule is disabled. Doing so will yield
            /// undefined results.
            INTERRUPT_ON_ASYNC_ADVANCE_DOORBELL_THIS: u1,
            /// Light Host Controller Reset (OPTIONAL) This control bit is not required. If
            /// implemented, it allows the driver to reset the EHCI controller without affecting
            /// the state of the ports or relationship to the companion host controllers. For
            /// example, the PORSTC registers should not be reset to their default values and
            /// the CF bit setting should not go to zero (retaining port ownership
            /// relationships). A host software read of this bit as zero indicates the Light
            /// Host Controller Reset has completed and it si safe for software to re-
            /// initialize the host controller. A host software read of this bit as a one
            /// indicates the Light Host
            LIGHT_HOST_CONTROLLER_RESET_THIS: u1,
            /// Asynchronous Schedule Park Mode Count (OPTIONAL) Asynchronous Park Capability
            /// bit in the HCCPARAMS register is a one, then this field defaults to 0x3 and is
            /// W/R. Otherwise it defaults to zero and is R. It contains a count of the number
            /// of successive transactions the host controller is allowed to execute from a
            /// high-speed queue head on the Asynchronous schedule before continuing traversal
            /// of the Asynchronous schedule. Valid value are 0x1 to 0x3.Software must not write
            /// a zero to this bit when Park Mode Enable is a one as it will result in undefined
            /// behavior.
            ASYNCHRONOUS_SCHEDULE_PARK_MODE_COUNT: u2,
            reserved2: u1,
            /// Asynchronous Schedule Park Mode Enable (OPTIONAL) If the Asynchronous Park
            /// Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1
            /// and is R/W. Otherwise the bit must be a zero and is Read Only. Software uses
            /// this bit to enable or disable Park mode. When this bit is one, Park mode is
            /// enabled. When this bit is zero, Park mode is disabled.
            ASYNCHRONOUS_SCHEDULE_PARK_MODE_ENABLE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Interrupt Threshold Control The value in this field is used by system software
            /// to select the maximum rate at which the host controller will issue interrupts.
            /// The only valid values are defined below: Value Minimum Interrupt Interval 0x00
            /// Reserved 0x01 1 micro-frame 0x02 2 micro-frame 0x04 4 micro-frame 0x08 8
            /// micro-frame(default, equates to 1 ms) 0x10 16 micro-frame(2ms) 0x20 32
            /// micro-frame(4ms) 0x40 64 micro-frame(8ms) Any other value in this register
            /// yields undefined results. The default value in this field is 0x08 . Software
            /// modifications to this bit while HC Halted bit is equal to zero results in
            /// undefined behavior.
            INTERRUPT_THRESHOLD_CONTROL_THE_VALUE_IN: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x10);

        /// address: 0x4200018
        /// USBINTR
        pub const USBINTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Enable When this bit is 1, and the USBINT bit in the USBSTS register
            /// is 1,the host controller will issue an interrupt at the next interrupt
            /// threshold. The interrupt is acknowledged by software clearing the USBINT bit
            USB: u1,
            /// Error Interrupt Enable When this bit is 1, and the USBERRINT bit in the USBSTS
            /// register is 1,the host controller will issue an interrupt at the next interrupt
            /// threshold. The interrupt is acknowledged by software clearing the USBERRINT bit.
            USB: u1,
            /// Port Change Interrupt Enable When this bit is 1, and the Port Chang Detect bit
            /// in the USBSTS register is 1, the host controller will issue an interrupt. The
            /// interrupt is acknowledged by software clearing the Port Chang Detect bit.
            PORT_CHANGE_INTERRUPT_ENABLE_WHEN_THIS: u1,
            /// Frame List Rollover Enable When this bit is 1, and the Frame List Rollover bit
            /// in the USBSTS register is 1, the host controller will issue an interrupt. The
            /// interrupt is acknowledged by software clearing the Frame List Rollover bit.
            FRAME_LIST_ROLLOVER_ENABLE_WHEN_THIS: u1,
            /// Host System Error Enable When this bit is 1, and the Host System Error Status
            /// bit in the USBSTS register is 1, the host controller will issue an interrupt.
            /// The interrupt is acknowledged by software clearing the Host System Error bit.
            HOST_SYSTEM_ERROR_ENABLE_WHEN_THIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4200014
        /// USBSTS
        pub const USBSTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt(USBINT) The Host Controller sets this bit to a one on the completion
            /// of a USB transaction, which results in the retirement of a Transfer Descriptor
            /// that had its IOC bit set. The Host Controller also sets this bit to 1 when a
            /// short packet is detected (actual number of bytes received was less than the
            /// expected number of bytes)
            USB: u1,
            /// Error Interrupt(USBERRINT) The Host Controller sets this bit to 1 when
            /// completion of USB transaction results in an error condition(e.g. error counter
            /// underflow).If the TD on which the error interrupt occurred also had its IOC bit
            /// set, both. This bit and USBINT bit are set.
            USB: u1,
            /// Port Change Detect The Host Controller sets this bit to a one when any port for
            /// which the Port Owner bit is set to zero has a change bit transition from a zero
            /// to a one or a Force Port Resume bit transition from a zero to a one as a result
            /// of a J-K transition detected on a suspended port. This bit will also be set as a
            /// result of the Connect Status Chang being set to a one after system software has
            /// relinquished ownership of a connected port by writing a one to a port’s Port
            /// Owner bit.
            PORT_CHANGE_DETECT_THE_HOST_CONTROLLER: u1,
            /// Frame List Rollover The Host Controller sets this bit to a one when the Frame
            /// List Index rolls over from its maximum value to zero. The exact value at which
            /// the rollover occurs depends on the frame list size. For example, if the frame
            /// list size is 1024, the Frame Index Register rolls over every time FRINDEX [13]
            /// toggles. Similarly, if the size is 512, the Host Controller sets this bit to a
            /// one every time FRINDEX [12] toggles.
            FRAME_LIST_ROLLOVER_THE_HOST_CONTROLLER: u1,
            /// Host System Error The Host Controller set this bit to 1 when a serious error
            /// occurs during a host system access involving the Host Controller module. When
            /// this error occurs, the Host Controller clears the Run/Stop bit in the Command
            /// register to prevent further execution of the scheduled TDs.
            HOST_SYSTEM_ERROR_THE_HOST_CONTROLLER: u1,
            /// Interrupt on Async Advance System software can force the host controller to
            /// issue an interrupt the next time the host controller advances the asynchronous
            /// schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the
            /// USBCMD register. This status bit indicates the assertion of that interrupt
            /// source.
            INTERRUPT_ON_ASYNC_ADVANCE_SYSTEM_SOFTWARE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Halted This bit is a zero whenever the Run/Stop bit is a one. The Host
            /// Controller Sets this bit to one after it has stopped executing as a result of
            /// the Run/Stop bit being set to 0, either by software or by the Host Controller
            /// Hardware (e.g. internal error). The default value is ‘1’.
            HC: u1,
            /// Reclamation This is a read-only status bit, which is used to detect an empty
            /// asynchronous schedule.
            @"RECLAMATION_THIS_IS_A_READ-ONLY_STATUS": u1,
            /// Periodic Schedule Status The bit reports the current real status of the Periodic
            /// Schedule. If this bit is a zero then the status of the Periodic Schedule is
            /// disabled. If this bit is a one then the status of the Periodic Schedule is
            /// enabled. The Host Controller is not required to disable or enable the Periodic
            /// Schedule when software transitions the bit in the USBCMD register. When this bit
            /// and the bit are the same value, the Periodic Schedule is either enabled (1) or
            /// disabled (0).
            PERIODIC_SCHEDULE_STATUS_THE_BIT_REPORTS: u1,
            /// Asynchronous Schedule Status The bit reports the current real status of
            /// Asynchronous Schedule. If this bit is a zero then the status of the Asynchronous
            /// Schedule is disabled. If this bit is a one then the status of the Asynchronous
            /// Schedule is enabled. The Host Controller is not required to immediately disable
            /// or enable the Asynchronous Schedule when software transitions the Asynchronous
            /// Schedule Enable bit in the USBCMD register. When this bit and the Asynchronous
            /// Schedule Enable bit are the same value, the Asynchronous Schedule is either
            /// enabled (1) or disabled (0).
            ASYNCHRONOUS_SCHEDULE_STATUS_THE_BIT_REPORTS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4200800
        /// USB_CTRL
        pub const USB_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// bypass enable
            /// 1: Enable UTMI interface, disable ULPI interface
            /// 0: Enable ULPI interface, disable UTMI interface
            ULPI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Master interface INCRX align enable
            /// 1: Start INCRx burst only on burst x-align address
            /// 0: Start burst on any double word boundary Note: This bit must enable if any bit
            /// of bit[11:9] is enabled
            AHB: u1,
            /// Master interface burst type INCR4 enable
            /// 1: Use INCR4 when appropriate
            /// 0: Do not use INCR4, use other enabled INCRX or unspecified length burst INCR
            AHB: u1,
            /// Master interface INCR8 enable
            /// 1: Use INCR8 when appropriate
            /// 0: Do not use INCR8, use other enabled INCRX or unspecified length burst INCR
            AHB: u1,
            /// Master interface INCR16 enable
            /// 1: Use INCR16 when appropriate
            /// 0: Do not use INCR16, use other enabled INCRX or unspecified length burst INCR
            AHB: u1,
            /// 1: ULPI wrapper interface will automatically set or clear DrvVbus register in
            /// ULPI PHY according to the port power status form the root hub
            /// 0: ULPI wrapper will ignore the difference between power status of root hub and
            /// ULPI PHY
            PP2VBUS: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// count select
            /// 1: Simulation mode. The counters will be much shorter then real time
            /// 0: Normal mode. The counters will count full time
            OHCI: u1,
            reserved19: u1,
            reserved20: u1,
            /// Transfer Status Enable
            /// 0: Disable
            /// 1: Enable
            DMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x800);

        /// address: 0x4200828
        /// USB_SPDCR
        pub const USB_SPDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Disable Control
            /// 00: Port Disable when no-se0 detect before SOF
            /// 01: Port Disable when no-se0 detect before SOF
            /// 10: No Port Disable when no-se0 detect before SOF
            /// 11: Port Disable when no-se0 3 time detect before SOF during 8 frames
            PORT: u2,
            reserved0: u1,
            reserved1: u1,
            /// resume_sel When set k-se0 transition 2 us, setting this bit to 1, which is
            /// cooperated with ss_utmi_backward_enb_i.
            RESUME_SEL: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Status This bit is set when no-se0 is detected before SOF when bit[1:0] is 10b
            /// or 11b
            SE0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x828);

        pub const @"HCI CONTROLLER AND PHY INTERFACE REGISTER" = struct {

            /// address: 0x4200808
            /// HCI Control Register
            pub const HCI_CTRL3 = @intToPtr(*volatile Mmio(32, packed struct {
                /// Linestate Change Detect Enable
                /// 1: Enable
                /// 0: Disable
                LINESTATE_CHANGE_DETECT_ENABLE: u1,
                /// Linestate Change Interrupt Enable
                /// 1: Enable
                /// 0: Disable
                LINESTATE_CHANGE_INTERRUPT_ENABLE: u1,
                reserved0: u1,
                /// Remote Wakeup Enable
                /// 1: Enable
                /// 0: Disable
                REMOTE_WAKEUP_ENABLE: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                /// Linestate Change Detect
                /// 0: Linestate change not dected
                /// 1: Linestate change dected Write ‘1’ to clear.
                LINESTATE_CHANGE_DETECT: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x808);

            /// address: 0x4200824
            /// PHY Status Register
            pub const PHY_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
                /// vc_do
                VC_DO: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                /// bist_done
                BIST_DONE: u1,
                /// Bist_error
                BIST_ERROR: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
            }), base_address + 0x824);
        };
    };

    /// Timer
    pub const Timer = struct {
        pub const base_address = 0x2050000;

        /// address: 0x20500c4
        /// AVS Counter 0 Register
        pub const AVS_CNT0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The higher 32 bits of AVS counter0. AVS counter0 is a 33-bit up counter. The
            /// initial value consists of two parts: this register forms the bit[32:1] of AVS
            /// counter0 and the bit[0] is zero. You can set the initial value of the AVS
            /// counter0 by software. The initial value can be updated at anytime. You can also
            /// pasuse the counter by setting AVS_CNT0_PS to ”1”. The counter value will not
            /// increase when it is paused.
            AVS_CNT0: u32,
        }), base_address + 0xc4);

        /// address: 0x20500c8
        /// AVS Counter 1 Register
        pub const AVS_CNT1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The higher 32 bits of AVS counter1. AVS counter1 is a 33-bit up counter. The
            /// initial value consists of two parts: this register forms the bit[32:1] of AVS
            /// counter0 and the bit[0] is zero. You can set the initial value of the AVS
            /// counter1 by software. The initial value can be updated at anytime. You can also
            /// pasuse the counter by setting AVS_CNT1_PS to ”1”. The counter value will not
            /// increase when it is paused.
            AVS_CNT1: u32,
        }), base_address + 0xc8);

        /// address: 0x20500c0
        /// AVS Control Register
        pub const AVS_CNT_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio/Video Sync Counter 0 Enable/Disable The clock source is OSC24M.
            /// 0: Disabled
            /// 1: Enabled
            AVS_CNT0_EN: u1,
            /// Audio/Video Sync Counter 1 Enable/Disable The clock source is OSC24M.
            /// 0: Disabled
            /// 1: Enabled
            AVS_CNT1_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Audio/Video Sync Counter 0 Pause Control
            /// 0: Do not pause.
            /// 1: Pause the AVS counter0.
            AVS_CNT0_PS: u1,
            /// Audio/Video Sync Counter 1 Pause Control
            /// 0: Do not pause.
            /// 1: Pause the AVS counter1.
            AVS_CNT1_PS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0xc0);

        /// address: 0x20500cc
        /// AVS Divisor Register
        pub const AVS_CNT_DIV_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// N0, the divisor factor for AVS0. The clock for AVS0 is 24MHz/N0. N0 = Bit[11:0]
            /// + 1. The valid value for N0 is from 1 to 0x7ff. There is an internal 12-bit
            /// counter maintained by the engine of the 33- bit AVS0. The 12-bit counter is used
            /// for counting the cycle number of the clock OSC24M. When the value of the 12-bit
            /// counter reaches N0, the internal 33-bit counter register will increase 1 and the
            /// 12-bit counter will reset to zero and restart again. You can change the value of
            /// N0 via the software at any time.
            AVS_CNT0_D: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// N1, the divisor factor for AVS1. The clock for AVS1 is 24 MHz/N1. N1 =
            /// Bit[27:16] + 1. The valid value for N1 is from 1 to 0x7ff. There is an internal
            /// 12-bit counter maintained by the engine of the 33- bit AVS1. The 12-bit counter
            /// is used for counting the cycle number of the clock OSC24M. When the value of the
            /// 12-bit counter reaches N1, the internal 33-bit counter register will increase 1
            /// and the 12-bit counter will reset to zero and restart again. You can change the
            /// value of N1 via the software at any time.
            AVS_CNT1_D: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xcc);

        /// address: 0x2050010
        /// Timer0 Control Register
        pub const TMR0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer0 Enable
            /// 0: Stop/Pause
            /// 1: Start By setting the bit to 1, the timer will be started. It reloads the
            /// interval value register and then counts from the interval value to 0. By setting
            /// the bit to 0 before the timer counts to 0, the timer will be paused. The bit
            /// will be locked to 0 for at least 2 cycles. Within the 2 cycles, you cannot set
            /// the bit to 1 to restart the timer. The timer supports updating the interval
            /// value in the pause state. To start to down-count from the updated interval
            /// value, set both the reload bit and enable bit to 1. Additionally, in the single
            /// counting mode, after the count value reaches 0, the system will automatically
            /// change the bit to 0 to stop the timer.
            TMR0_EN: u1,
            /// Timer0 Reload
            /// 0: No effect
            /// 1: Reload the Interval value for timer0 After the bit is set, it can not be
            /// written again before it is cleared automatically.
            TMR0_RELOAD: u1,
            /// Select the clock source for timer0
            /// 00: LOSC
            /// 01: OSC24M
            /// 10: /
            /// 11: /
            TMR0_CLK_SRC: u2,
            /// Select the pre-scale of timer0 clock source
            /// 000: /1
            /// 001: /2
            /// 010: /4
            /// 011: /8
            /// 100: /16
            /// 101: /32
            /// 110: /64
            /// 111: /128
            TMR0_CLK_PRES: u3,
            /// Select the timing mode for timer0
            /// 0: Periodic mode. When the interval value of the timer 0 is reached, the timer
            /// will restart another round of counting automatically.
            /// 1: Single counting mode. When the interval value of the timer 0 is reached, the
            /// timer will stop counting.
            TMR0_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2050018
        /// Timer0 Current Value Register
        pub const TMR0_CUR_VALUE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer0 Current Value Timer0 current value is a 32-bit down-counter (from
            /// interval value to 0).
            TMR0_CUR_VALUE: u32,
        }), base_address + 0x18);

        /// address: 0x2050014
        /// Timer0 Interval Value Register
        pub const TMR0_INTV_VALUE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer0 Interval Value
            TMR0_INTV_VALUE: u32,
        }), base_address + 0x14);

        /// address: 0x2050020
        /// Timer1 Control Register
        pub const TMR1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer1 Enable
            /// 0: Stop/Pause
            /// 1: Start By setting the bit to 1, the timer will be started. It reloads the
            /// interval value register and then counts from the interval value to 0. By setting
            /// the bit to 0 before the timer counts to 0, the timer will be paused. The bit
            /// will be locked to 0 for at least 2 cycles. Within the 2 cycles, you cannot set
            /// the bit to 1 to restart the timer. The timer supports updating the interval
            /// value in the pause state. To start to down-count from the updated interval
            /// value, set both the reload bit and enable bit to 1. Additionally, in the single
            /// counting mode, after the count value reaches 0, the system will automatically
            /// change the bit to 0 to stop the timer.
            TMR1_EN: u1,
            /// Timer1 Reload
            /// 0: No effect
            /// 1: Reload the interval value for timer1 After the bit is set, it can not be
            /// written again before it is cleared automatically.
            TMR1_RELOAD: u1,
            /// Select the pre-scale of timer1 clock source
            /// 00: LOSC
            /// 01: OSC24M
            /// 10: /
            /// 11: /
            TMR1_CLK_SRC: u2,
            /// Select the pre-scale of timer1 clock source
            /// 000: /1
            /// 001: /2
            /// 010: /4
            /// 011: /8
            /// 100: /16
            /// 101: /32
            /// 110: /64
            /// 111: /128
            TMR1_CLK_PRES: u3,
            /// Select the timing mode for timer1
            /// 0: Periodic mode. When the interval value of the timer 1 is reached, the timer
            /// will restart another round of counting automatically.
            /// 1: Single counting mode. When the interval value of the timer 1 is reached, the
            /// timer will stop counting.
            TMR1_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x2050028
        /// Timer1 Current Value Register
        pub const TMR1_CUR_VALUE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer1 Current Value Timer1 current value is a 32-bit down-counter (from
            /// interval value to 0).
            TMR1_CUR_VALUE: u32,
        }), base_address + 0x28);

        /// address: 0x2050024
        /// Timer1 Interval Value Register
        pub const TMR1_INTV_VALUE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer1 Interval Value
            TMR1_INTV_VALUE: u32,
        }), base_address + 0x24);

        /// address: 0x2050000
        /// Timer IRQ Enable Register
        pub const TMR_IRQ_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer0 Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TMR0_IRQ_EN: u1,
            /// Timer1 Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TMR1_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x2050004
        /// Timer Status Register
        pub const TMR_IRQ_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The IRQ pending bit for Timer0
            /// 0: No effect
            /// 1: Pending, indicates that the interval value of the timer 0 is reached. Write 1
            /// to clear the pending status.
            TMR0_IRQ_PEND: u1,
            /// The IRQ pending bit for Timer1
            /// 0: No effect
            /// 1: Pending, indicates that the interval value of the timer 1 is reached. Write 1
            /// to clear the pending status.
            TMR1_IRQ_PEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x20500b4
        /// Watchdog Configuration Register
        pub const WDOG_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configure the operating mode for the watchdog
            /// 00: /
            /// 01: To whole system
            /// 10: Only interrupt mode
            /// 11: /
            WDOG_MODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Select the clock source for the watchdog.
            /// 0: HOSC_32K, that is, OSC24M/750. It is a 32 KHz clock divided from the OSC24M.
            /// 1: LOSC_32K. A clock provided by the LOSC.
            WDOG_CLK_SRC: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Key Field To change the value of bit[15:0], this field should be filled with
            /// 0x16AA.
            KEY_FIELD: u16,
        }), base_address + 0xb4);

        /// address: 0x20500b0
        /// Watchdog Control Register
        pub const WDOG_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog Restart
            /// 0: No effect
            /// 1: Restart the watchdog
            WDOG_RESTART: u1,
            /// Watchdog Key Field It should be written to 0xA57. Writing any other value in
            /// this field aborts the write operation.
            WDOG_KEY_FIELD: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0xb0);

        /// address: 0x20500a0
        /// Watchdog IRQ Enable Register
        pub const WDOG_IRQ_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            WDOG_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa0);

        /// address: 0x20500a4
        /// Watchdog Status Register
        pub const WDOG_IRQ_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The IRQ pending bit for the watchdog Write 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending, indicates that the interval value of the watchdog is reached.
            WDOG_IRQ_PEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa4);

        /// address: 0x20500b8
        /// Watchdog Mode Register
        pub const WDOG_MODE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog Enable
            /// 0: No effect
            /// 1: Enable the Watchdog
            WDOG_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Watchdog Interval Value
            /// 0000: 16000 cycles (0.5 s)
            /// 0001: 32000 cycles (1 s)
            /// 0010: 64000 cycles (2 s)
            /// 0011: 96000 cycles (3 s)
            /// 0100: 128000 cycles (4 s)
            /// 0101: 160000 cycles (5 s)
            /// 0110: 192000 cycles (6 s)
            /// 0111: 256000 cycles (8 s)
            /// 1000: 320000 cycles (10 s)
            /// 1001: 384000 cycles (12 s)
            /// 1010: 448000 cycles (14 s)
            /// 1011: 512000 cycles (16 s) Others: Reserved Note: The corresponding clock cycles
            /// for the interval value (IV) depends on the frequency of the clock: Cycles = F *
            /// IV. For example, to get a interval value of 0.5 second, if the clock source is
            /// HOSC_32K (whose frequency is 32 KHz), the cycle number is 16,000; if the clock
            /// source is LOSC_32K (whose frequency is 32.768 kHz), the cycle number is 16,384.
            WDOG_INTV_VALUE: u4,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Key Field To change the value of bit[15:0], this field should be filled with
            /// 0x16AA.
            KEY_FIELD: u16,
        }), base_address + 0xb8);

        /// address: 0x20500bc
        /// Watchdog Output Configuration Register
        pub const WDOG_OUTPUT_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// OUTPUT CONFIG Configure the valid time for the watchdog reset signal. T =
            /// 1/32ms*(N + 1) The default value is 1 ms.
            WDOG: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xbc);

        /// address: 0x20500a8
        /// Watchdog Software Reset Register
        pub const WDOG_SOFT_RST_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Soft Reset Enable
            /// 0: De-assert
            /// 1: Reset the system
            SOFT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Key Field To change the value of bit[0], this field should be filled with
            /// 0x16AA.
            KEY_FIELD: u16,
        }), base_address + 0xa8);
    };

    /// PWM
    pub const PWM = struct {
        pub const base_address = 0x2000c00;

        /// address: 0x2000cc0
        /// Capture Enable Register
        pub const CER = @intToPtr(*volatile Mmio(32, packed struct {
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP0_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel1 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP1_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel2 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP2_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel3 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP3_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel4 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP4_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel5 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP5_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel6 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP6_EN: u1,
            /// When enabling the capture function, the 16-bit up-counter starts working, and
            /// the capture channel7 is permitted to capture external falling edge or rising
            /// edge.
            /// 0: Capture disable
            /// 1: Capture enable
            CAP7_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc0);

        /// address: 0x2000c10
        /// Capture IRQ Enable Register
        pub const CIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// If the enable bit is set to 1, when the capture channel 0 captures rising edge,
            /// it generates a capture channel 0 pending.
            /// 0: Capture channel 0 rise lock interrupt disable
            /// 1: Capture channel 0 rise lock interrupt enable
            CRIE0: u1,
            /// If the enable bit is set to 1, when the capture channel 0 captures falling edge,
            /// it generates a capture channel 0 pending.
            /// 0: Capture channel 0 fall lock interrupt disable
            /// 1: Capture channel 0 fall lock interrupt enable
            CFIE0: u1,
            /// If the enable bit is set to 1, when the capture channel 1 captures rising edge,
            /// it generates a capture channel 1 pending.
            /// 0: Capture channel 1 rise lock interrupt disable
            /// 1: Capture channel 1 rise lock interrupt enable
            CRIE1: u1,
            /// If the enable bit is set to 1, when the capture channel 1 captures falling edge,
            /// it generates a capture channel 1 pending.
            /// 0: Capture channel 1 fall lock interrupt disable
            /// 1: Capture channel 1 fall lock interrupt enable
            CFIE1: u1,
            /// If the enable bit is set to 1, when the capture channel 2 captures rising edge,
            /// it generates a capture channel 2 pending.
            /// 0: Capture channel 2 rise lock interrupt disable
            /// 1: Capture channel 2 rise lock interrupt enable
            CRIE2: u1,
            /// If the enable bit is set to 1, when the capture channel 2 captures falling edge,
            /// it generates a capture channel 2 pending.
            /// 0: Capture channel 2 fall lock interrupt disable
            /// 1: Capture channel 2 fall lock interrupt enable
            CFIE2: u1,
            /// If the enable bit is set to 1, when the capture channel 3 captures rising edge,
            /// it generates a capture channel 3 pending.
            /// 0: Capture channel 3 rise lock interrupt disable
            /// 1: Capture channel 3 rise lock interrupt enable
            CRIE3: u1,
            /// If the enable bit is set to 1, when the capture channel 3 captures falling edge,
            /// it generates a capture channel 3 pending.
            /// 0: Capture channel 3 fall lock interrupt disable
            /// 1: Capture channel 3 fall lock interrupt enable
            CFIE3: u1,
            /// If the enable bit is set to 1, when the capture channel 4 captures rising edge,
            /// it generates a capture channel 4 pending.
            /// 0: Capture channel 4 rise lock interrupt disable
            /// 1: Capture channel 4 rise lock interrupt enable
            CRIE4: u1,
            /// If the enable bit is set to 1, when the capture channel 4 captures falling edge,
            /// it generates a capture channel 4 pending.
            /// 0: Capture channel 4 fall lock interrupt disable
            /// 1: Capture channel 4 fall lock interrupt enable
            CFIE4: u1,
            /// If the enable bit is set to 1, when the capture channel 5 captures rising edge,
            /// it generates a capture channel 5 pending.
            /// 0: Capture channel 5 rise lock interrupt disable
            /// 1: Capture channel 5 rise lock interrupt enable
            CRIE5: u1,
            /// If the enable bit is set to 1, when the capture channel 5 captures falling edge,
            /// it generates a capture channel 5 pending.
            /// 0: Capture channel 5 fall lock interrupt disable
            /// 1: Capture channel 5 fall lock interrupt enable
            CFIE5: u1,
            /// If the enable bit is set to 1, when the capture channel 6 captures rising edge,
            /// it generates a capture channel 6 pending.
            /// 0: Capture channel 6 rise lock interrupt disable
            /// 1: Capture channel 6 rise lock interrupt enable
            CRIE6: u1,
            /// If the enable bit is set to 1, when the capture channel 6 captures falling edge,
            /// it generates a capture channel 6 pending.
            /// 0: Capture channel 6 fall lock interrupt disable
            /// 1: Capture channel 6 fall lock interrupt enable
            CFIE6: u1,
            /// If the enable bit is set to 1, when the capture channel 7 captures rising edge,
            /// it generates a capture channel 7 pending.
            /// 0: Capture channel 7 rise lock interrupt disable
            /// 1: Capture channel 7 rise lock interrupt enable
            CRIE7: u1,
            /// If the enable bit is set to 1, when the capture channel 7 captures falling edge,
            /// it generates a capture channel 7 pending.
            /// 0: Capture channel 7 fall lock interrupt disable
            /// 1: Capture channel 7 fall lock interrupt enable
            CFIE7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x2000c14
        /// Capture IRQ Status Register
        pub const CISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status of the capture channel 0 rising lock interrupt When the capture channel 0
            /// captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is set
            /// 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel 0
            /// interrupt is not pending. Reads 1: The capture channel 0 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 0
            /// interrupt.
            CRIS0: u1,
            /// Status of the capture channel 0 falling lock interrupt When the capture channel
            /// 0 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 0 interrupt is not pending. Reads 1: The capture channel 0 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 0
            /// interrupt.
            CFIS0: u1,
            /// Status of the capture channel 1 rising lock interrupt. When the capture channel
            /// 1 captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 1 interrupt is not pending. Reads 1: The capture channel 1 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 1
            /// interrupt.
            CRIS1: u1,
            /// Status of the capture channel 1 falling lock interrupt When the capture channel
            /// 1 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 1 interrupt is not pending. Reads 1: The capture channel 1 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 1
            /// interrupt.
            CFIS1: u1,
            /// Status of the capture channel 2 rising lock interrupt. When the capture channel
            /// 2 captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 2 interrupt is not pending. Reads 1: The capture channel 2 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 2
            /// interrupt.
            CRIS2: u1,
            /// Status of the capture channel 2 falling lock interrupt When the capture channel
            /// 2 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 2 interrupt is not pending. Reads 1: The capture channel 2 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 2
            /// interrupt.
            CFIS2: u1,
            /// Status of the capture channel 3 rising lock interrupt When the capture channel 3
            /// captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is set
            /// to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel 3
            /// interrupt is not pending. Reads 1: The capture channel 3 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 3
            /// interrupt.
            CRIS3: u1,
            /// Status of the capture channel 3 falling lock interrupt. When the capture channel
            /// 3 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 3 interrupt is not pending. Reads 1: The capture channel 3 interrupt is pending.
            /// Writes 0: no effect. Writes 1: Clear the status of the capture channel 3
            /// interrupt.
            CFIS3: u1,
            /// Status of the capture channel 4 rising lock interrupt. When the capture channel
            /// 4 captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 4 interrupt is not pending. Reads 1: The capture channel 4 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 4
            /// interrupt status.
            CRIS4: u1,
            /// Status of the capture channel 4 falling lock interrupt When the capture channel
            /// 4 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 4 interrupt is not pending. Reads 1: The capture channel 4 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 4
            /// interrupt.
            CFIS4: u1,
            /// Status of the capture channel 5 rising lock interrupt When the capture channel 5
            /// captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is set
            /// to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel 5
            /// interrupt is not pending. Reads 1: The capture channel 5 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 5
            /// interrupt.
            CRIS5: u1,
            /// Status of the capture channel 5 falling lock interrupt When the capturing
            /// channel 5 captures falling edge, if the fall lock interrupt ( ) is enabled, this
            /// bit is set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture
            /// channel 5 interrupt is not pending. Reads 1: The capture channel 5 interrupt is
            /// pending. Writes 0: No effect. Reads 1: Clear the status of the capture channel 5
            /// interrupt.
            CFIS5: u1,
            /// Status of the capture channel 6 rising lock interrupt. When the capture channel
            /// 6 captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 6 interrupt is not pending. Reads 1: The capture channel 6 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 6
            /// interrupt.
            CRIS6: u1,
            /// Status of the capture channel 6 falling lock interrupt When the capture channel
            /// 6 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 6 interrupt is not pending. Reads 1: The capture channel 6 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 6
            /// interrupt.
            CFIS6: u1,
            /// Status of the capture channel 7 rising lock interrupt When the capture channel 7
            /// captures rising edge, if the rise lock interrupt ( ) is enabled, this bit is set
            /// to 1 by hardware. Write 1 to clear this bit. Reads 0: The capture channel 7
            /// interrupt is not pending. Reads 1: The capture channel 7 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 7
            /// interrupt.
            CRIS7: u1,
            /// Status of the capture channel 7 falling lock interrupt When the capture channel
            /// 7 captures falling edge, if the fall lock interrupt ( ) is enabled, this bit is
            /// set to 1 by hardware. Writing 1 to clear this bit. Reads 0: The capture channel
            /// 7 interrupt is not pending. Reads 1: The capture channel 7 interrupt is pending.
            /// Writes 0: No effect. Writes 1: Clear the status of the capture channel 7
            /// interrupt.
            CFIS7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x2000c20
        /// PWM01 Clock Configuration Register
        pub const PCCR01 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM01 Clock Divide M
            /// 0000: /1
            /// 0001: /2
            /// 0010: /4
            /// 0011: /8
            /// 0100: /16
            /// 0101: /32
            /// 0110: /64
            /// 0111: /128
            /// 1000: /256 Others: Reserved
            PWM01_CLK_DIV_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Select PWM01 Clock Source
            /// 00: HOSC
            /// 01: APB0 Others: Reserved
            PWM01_CLK_SRC: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x20);

        /// address: 0x2000c24
        /// PWM23 Clock Configuration Register
        pub const PCCR23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM23 Clock Divide M
            /// 0000: /1
            /// 0001: /2
            /// 0010: /4
            /// 0011: /8
            /// 0100: /16
            /// 0101: /32
            /// 0110: /64
            /// 0111: /128
            /// 1000: /256 Others: Reserved
            PWM23_CLK_DIV_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Select PWM23 Clock Source
            /// 00: HOSC
            /// 01: APB0 Others: Reserved
            PWM23_CLK_SRC_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x24);

        /// address: 0x2000c28
        /// PWM45 Clock Configuration Register
        pub const PCCR45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM45 Clock Divide M
            /// 0000: /1
            /// 0001: /2
            /// 0010: /4
            /// 0011: /8
            /// 0100: /16
            /// 0101: /32
            /// 0110: /64
            /// 0111: /128
            /// 1000: /256 Others: Reserved
            PWM45_CLK_DIV_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Select PWM45 Clock Source
            /// 00: HOSC
            /// 01: APB0 Others: Reserved
            PWM45_CLK_SRC_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x28);

        /// address: 0x2000c2c
        /// PWM67 Clock Configuration Register
        pub const PCCR67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM67 Clock Divide M
            /// 0000: /1
            /// 0001: /2
            /// 0010: /4
            /// 0011: /8
            /// 0100: /16
            /// 0101: /32
            /// 0110: /64
            /// 0111: /128
            /// 1000: /256 Others: Reserved
            PWM67_CLK_DIV_M: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Select PWM67 Clock Source
            /// 00: HOSC
            /// 01: APB0 Others: Reserved
            PWM67_CLK_SRC_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x2c);

        /// address: 0x2000c40
        /// PWM Clock Gating Register
        pub const PCGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gating clock for PWM0
            /// 0: Mask
            /// 1: Pass
            PWM0_CLK_GATING: u1,
            /// Gating clock for PWM1
            /// 0: Mask
            /// 1: Pass
            PWM1_CLK_GATING: u1,
            /// Gating clock for PWM2
            /// 0: Mask
            /// 1: Pass
            PWM2_CLK_GATING: u1,
            /// Gating clock for PWM3
            /// 0: Mask
            /// 1: Pass
            PWM3_CLK_GATING: u1,
            /// Gating clock for PWM4
            /// 0: Mask
            /// 1: Pass
            PWM4_CLK_GATING: u1,
            /// Gating clock for PWM5
            /// 0: Mask
            /// 1: Pass
            PWM5_CLK_GATING: u1,
            /// Gating clock for PWM6
            /// 0: Mask
            /// 1: Pass
            PWM6_CLK_GATING: u1,
            /// Gating clock for PWM7
            /// 0: Mask
            /// 1: Pass
            PWM7_CLK_GATING: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Bypass clock source (after pre-scale) to PWM0 output
            /// 0: not bypass
            /// 1: bypass
            PWM0_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM1 output
            /// 0: not bypass
            /// 1: bypass
            PWM1_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM2 output
            /// 0: not bypass
            /// 1: bypass
            PWM2_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM3 output
            /// 0: not bypass
            /// 1: bypass
            PWM3_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM4 output
            /// 0: not bypass
            /// 1: bypass
            PWM4_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM5 output
            /// 0: not bypass
            /// 1: bypass
            PWM5_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM6 output
            /// 0: not bypass
            /// 1: bypass
            PWM6_CLK_BYPASS: u1,
            /// Bypass clock source (after pre-scale) to PWM7 output
            /// 0: not bypass
            /// 1: bypass
            PWM7_CLK_BYPASS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x2000c60
        /// PWM01 Dead Zone Control Register
        pub const PDZCR01 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM01 Dead Zone Enable
            /// 0: Dead Zone disable
            /// 1: Dead Zone enable
            PWM01_DZ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// PWM01 Dead Zone Interval Value
            PWM01_DZ_INTV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x60);

        /// address: 0x2000c64
        /// PWM23 Dead Zone Control Register
        pub const PDZCR23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM23 Dead Zone Enable
            /// 0: Dead Zone disable
            /// 1: Dead Zone enable
            PWM23_DZ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// PWM23 Dead Zone Interval Value
            PWM23_DZ_INTV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x64);

        /// address: 0x2000c68
        /// PWM45 Dead Zone Control Register
        pub const PDZCR45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM45 Dead Zone Enable
            /// 0: Dead Zone disable
            /// 1: Dead Zone enable
            PWM45_DZ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// PWM45 Dead Zone Interval Value
            PWM45_DZ_INTV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x68);

        /// address: 0x2000c6c
        /// PWM67 Dead Zone Control Register
        pub const PDZCR67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM67 Dead Zone Enable
            /// 0: Dead Zone disable
            /// 1: Dead Zone enable
            PWM67_DZ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// PWM67 Dead Zone Interval Value
            PWM67_DZ_INTV: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x6c);

        /// address: 0x2000c80
        /// PWM Enable Register
        pub const PER = @intToPtr(*volatile Mmio(32, packed struct {
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel0 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM0_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel1 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM1_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel2 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM2_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel3 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM3_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel4 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM4_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel5 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM5_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel6 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM6_EN: u1,
            /// When PWM is enabled, the 16-bit up-counter starts working and PWM channel7 is
            /// permitted to output PWM waveform.
            /// 0: PWM disable
            /// 1: PWM enable
            PWM7_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x80);

        /// address: 0x2000c90
        /// PWM Group0 Register
        pub const PGR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If bit[i] is set, the PWM i is selected as one channel of PWM Group0.
            PWMG0_CS: u16,
            /// PWM Group0 Enable.
            PWMG0_EN: u1,
            /// The PWM channels selected in start to output PWM waveform at the same time.
            PWMG0_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x90);

        /// address: 0x2000c94
        /// PWM Group1 Register
        pub const PGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If bit[i] is set, the PWM i is selected as one channel of PWM Group1.
            PWMG1_CS: u16,
            /// PWM Group1 Enable.
            PWMG1_EN: u1,
            /// The PWM channels selected in start to output PWM waveform at the same time.
            PWMG1_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x94);

        /// address: 0x2000c98
        /// PWM Group2 Register
        pub const PGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If bit[i] is set, the PWM i is selected as one channel of PWM Group2.
            PWMG2_CS: u16,
            /// PWM Group2 Enable.
            PWMG2_EN: u1,
            /// The PWM channels selected in start to output PWM waveform at the same time.
            PWMG2_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x98);

        /// address: 0x2000c9c
        /// PWM Group3 Register
        pub const PGR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If bit[i] is set, the PWM i is selected as one channel of PWM Group3.
            PWMG3_CS: u16,
            /// PWM Group3 Enable.
            PWMG3_EN: u1,
            /// The PWM channels selected in start to output PWM waveform at the same time.
            PWMG3_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x9c);

        /// address: 0x2000c00
        /// PWM IRQ Enable Register
        pub const PIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM Channel 0 Interrupt Enable
            /// 0: PWM Channel 0 Interrupt Disable
            /// 1: PWM Channel 0 Interrupt Enable
            PCIE0: u1,
            /// PWM Channel 1 Interrupt Enable
            /// 0: PWM Channel 1 Interrupt Disable
            /// 1: PWM Channel 1 Interrupt Enable
            PCIE1: u1,
            /// PWM Channel 2 Interrupt Enable
            /// 0: PWM Channel 2 Interrupt Disable
            /// 1: PWM Channel 2 Interrupt Enable
            PCIE2: u1,
            /// PWM Channel 3 Interrupt Enable
            /// 0: PWM Channel 3 Interrupt Disable
            /// 1: PWM Channel 3 Interrupt Enable
            PCIE3: u1,
            /// PWM Channel 4 Interrupt Enable
            /// 0: PWM Channel 4 Interrupt Disable
            /// 1: PWM Channel 4 Interrupt Enable
            PCIE4: u1,
            /// PWM Channel 5 Interrupt Enable
            /// 0: PWM Channel 5 Interrupt Disable
            /// 1: PWM Channel 5 Interrupt Enable
            PCIE5: u1,
            /// PWM Channel 6 Interrupt Enable
            /// 0: PWM Channel 6 Interrupt Disable
            /// 1: PWM Channel 6 Interrupt Enable
            PCIE6: u1,
            /// PWM Channel 7 Interrupt Enable
            /// 0: PWM Channel 7 Interrupt Disable
            /// 1: PWM Channel 7 Interrupt Enable
            PCIE7: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// PWM Group 0 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PGIE0: u1,
            /// PWM Group 1 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PGIE1: u1,
            /// PWM Group 2 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PGIE2: u1,
            /// PWM Group 3 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PGIE3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x0);

        /// address: 0x2000c04
        /// PWM IRQ Status Register
        pub const PISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWM Channel 0 Interrupt Status When the PWM channel 0 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 0 interrupt is not pending. Reads 1: PWM channel 0 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 0 interrupt status.
            PIS0: u1,
            /// PWM Channel 1 Interrupt Status When the PWM channel 1 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 1 interrupt is not pending. Reads 1: PWM channel 1 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 1 interrupt status.
            PIS1: u1,
            /// PWM Channel 2 Interrupt Status When the PWM channel 2 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 2 interrupt is not pending. Reads 1: PWM channel 2 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 2 interrupt status.
            PIS2: u1,
            /// PWM Channel 3 Interrupt Status When the PWM channel 3 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 3 interrupt is not pending. Reads 1: PWM channel 3 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 3 interrupt status.
            PIS3: u1,
            /// PWM Channel 4 Interrupt Status When the PWM channel 4 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 4 interrupt is not pending. Reads 1: PWM channel 4 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 4 interrupt status.
            PIS4: u1,
            /// PWM Channel 5 Interrupt Status When the PWM channel 5 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 5 interrupt is not pending. Reads 1: PWM channel 5 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 5 interrupt status.
            PIS5: u1,
            /// PWM Channel 6 Interrupt Status When the PWM channel 6 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 6 interrupt is not pending. Reads 1: PWM channel 6 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 6 interrupt status.
            PIS6: u1,
            /// PWM Channel 7 Interrupt Status When the PWM channel 7 counter reaches the Entire
            /// Cycle Value, this bit is set 1 by hardware. Writing 1 to clear this bit. Reads
            /// 0: PWM channel 7 interrupt is not pending. Reads 1: PWM channel 7 interrupt is
            /// pending. Writes 0: No effect. Writes 1: Clear PWM channel 7 interrupt status.
            PIS7: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// PWM Group 0 Interrupt Status
            PGIS0: u1,
            /// PWM Group 1 Interrupt Status
            PGIS1: u1,
            /// PWM Group 2 Interrupt Status
            PGIS2: u1,
            /// PWM Group 3 Interrupt Status
            PGIS3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);
    };

    /// CSIC_CCU
    pub const CSIC_CCU = struct {
        pub const base_address = 0x5800000;

        /// address: 0x5800000
        /// CCU Clock Mode Register
        pub const CCU_CLK_MODE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// 0: CCU Clock Gating Registers(0x0004~0x0010) effect
            /// 1: CCU Clock Gating Registers(0x0004~0x0010) not effect
            CCU_CLK_GATING_DISABLE: u1,
        }), base_address + 0x0);

        /// address: 0x5800004
        /// CCU Parser Clock Enable Register
        pub const CCU_PARSER_CLK_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: CSI Parser0 clock disable
            /// 1: CSI Parser0 clock enable
            MCSI_PARSER0_CLK_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x4);

        /// address: 0x580000c
        /// CCU Post0 Clock Enable Register
        pub const CCU_POST0_CLK_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: BK0 clock disable
            /// 1: BK0 clock enable,when MCSI_POST0_CLK_ENABLE is 1
            MCSI_BK0_CLK_ENABLE: u1,
            /// 0: BK1 clock disable
            /// 1: BK1 clock enable,when MCSI_POST0_CLK_ENABLE is 1
            MCSI_BK1_CLK_ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// 0: POST0 clock disable
            /// 1: POST0 clock enable
            MCSI_POST0_CLK_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);
    };

    /// CSIC_TOP
    pub const CSIC_TOP = struct {
        pub const base_address = 0x5800800;

        /// address: 0x58008dc
        /// CSIC BIST CS Register
        pub const CSIC_BIST_CS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 000: Set when BK0 memory bist
            /// 001: Set when BK1 memory bist Others: Reserved
            BIST_CS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xdc);

        /// address: 0x58008ec
        /// CSIC BIST Data Mask Register
        pub const CSIC_BIST_DATA_MASK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// BIST Data Mask
            /// 0: Unmask
            /// 1: Mask
            BIST_DATA_MASK: u32,
        }), base_address + 0xec);

        /// address: 0x58008a0
        /// CSIC DMA0 Input Select Register
        pub const CSIC_DMA0_INPUT_SEL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Select
            /// 0000: input from ISP0 CH0
            /// 0001: input from ISP0 CH1
            /// 0010: input from ISP0 CH2
            /// 0011: input from ISP0 CH3 Others: Reserved
            DMA0: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xa0);

        /// address: 0x58008a4
        /// CSIC DMA1 Input Select Register
        pub const CSIC_DMA1_INPUT_SEL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input Select
            /// 0000: input from ISP0 CH0
            /// 0001: input from ISP0 CH1
            /// 0010: input from ISP0 CH2
            /// 0011: input from ISP0 CH3 Others: Reserved
            DMA1: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xa4);

        /// address: 0x58008f0
        /// CSIC MBUS REQ MAX Register
        pub const CSIC_MBUS_REQ_MAX_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Maximum of request commands for the master granted in MCSI_MEM arbiter is N+1.
            MCSI_MEM_REQ_MAX: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xf0);

        /// address: 0x5800904
        /// CSIC Multi-Frame Interrupt Register
        pub const CSIC_MULF_INT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            MULF_DONE_EN: u1,
            MULF_ERR_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            MULF_DONE_PD: u1,
            MULF_ERR_PD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x104);

        /// address: 0x5800900
        /// CSIC Multi-Frame Mode Register
        pub const CSIC_MULF_MOD_REG = @intToPtr(*volatile Mmio(32, packed struct {
            MULF_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            MULF_CS: u8,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            MULF_STATUS: u8,
        }), base_address + 0x100);

        /// address: 0x5800824
        /// CSIC Pattern Generation Address Register
        pub const CSIC_PTN_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The pattern DRAM address when generating pattern.
            PTN_ADDR: u32,
        }), base_address + 0x24);

        /// address: 0x5800808
        /// CSIC Pattern Control Register
        pub const CSIC_PTN_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clocks delayed before pattern generating start.
            PTN_GEN_DLY: u8,
            /// Packet generator clock divider
            PTN_GEN_CLK_DIV: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Pattern mode selection 0000~0011:reserved 0100:NCSIC YUV 8 bits width 0101:NCSIC
            /// YUV 16 bits width 0110:reserved 0111:reserved 1000:BT656 8 bits width 1001:BT656
            /// 16 bits width 1010:reserved 1011:reserved 1100:BAYER 12 bits for ISPFE
            /// 1101:UYVY422 12 bits for ISPFE 1110:UYVY420 12 bits for ISPFE 1111:reserved
            PTN_MODE: u4,
            /// 00:8-bit 01:10-bit 10:12-bit 11:reserved
            PTN_GEN_DATA_WIDTH: u2,
            reserved6: u1,
            reserved7: u1,
            /// Pattern Generator output port selection 010:NCSIC0 others:reserved
            PTN_PORT_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x8);

        /// address: 0x5800804
        /// CSIC Pattern Generation Enable Register
        pub const CSIC_PTN_GEN_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pattern Generation Enable
            PTN_GEN_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// CSIC Pattern Generating Start
            /// 0: Finish other: Start Software write this bit to “1” to start pattern
            /// generating from DRAM. When finished, the hardware will clear this bit to “0”
            /// automatically. Generating cycles depends on PTN_CYCLE.
            PTN_START: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Pattern generating cycle counter. The pattern in dram will be generated in
            /// cycles of PTN_CYCLE+1.
            PTN_CYCLE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x5800828
        /// CSIC Pattern ISP Size Register
        pub const CSIC_PTN_ISP_SIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Width Horizontal size, only valid for ISP mode pattern generation.
            WIDTH: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Height Vertical size, only valid for ISP mode pattern generation.
            HEIGHT: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x28);

        /// address: 0x5800820
        /// CSIC Pattern Generation Length Register
        pub const CSIC_PTN_LEN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The pattern length in byte when generating pattern.
            PTN_LEN: u32,
        }), base_address + 0x20);

        /// address: 0x5800800
        /// CSIC TOP Enable Register
        pub const CSIC_TOP_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Reset and disable the CSIC module
            /// 1: Enable the CSIC module
            CSIC_TOP_EN: u1,
            reserved0: u1,
            /// 0: Closed
            /// 1: EN BIST TEST
            BIST_MODE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x0);
    };

    /// CSIC_PARSER0
    pub const CSIC_PARSER0 = struct {
        pub const base_address = 0x5801000;

        /// address: 0x5801014
        /// CSIC_PRS_NCSIC_BT656_HEAD_CFG_REG
        pub const CSIC_PRS_NCSIC_BT656_HEAD_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The low 4-bit of BT656 header for channel 0 Only valid in BT656 multi-channel
            /// mode
            CH0_ID: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// The low 4-bit of BT656 header for channel 1 Only valid in BT656 multi-channel
            /// mode
            CH1_ID: u4,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// The low 4-bit of BT656 header for channel 2 Only valid in BT656 multi-channel
            /// mode
            CH2_ID: u4,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// The low 4-bit of BT656 header for channel 3 Only valid in BT656 multi-channel
            /// mode
            CH3_ID: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x14);

        /// address: 0x5801500
        /// CSIC_PRS_NCSIC_RX_SIGNAL0_DLY_ADJ_REG
        pub const CSIC_PRS_NCSIC_RX_SIGNAL0_DLY_ADJ_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pclk_dly 32 Step for adjust, 1 step = 0.2 ns
            PCLK_DLY: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Hsync_dly 32 Step for adjust, 1 step = 0.2 ns
            HSYNC_DLY: u5,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Vsync_dly 32 Step for adjust, 1 step = 0.2 ns
            VSYNC_DLY: u5,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Filed_dly 32 Step for adjust, 1 step = 0.2 ns
            FILED_DLY: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x500);

        /// address: 0x5801514
        /// CSIC_PRS_NCSIC_RX_SIGNAL5_DLY_ADJ_REG
        pub const CSIC_PRS_NCSIC_RX_SIGNAL5_DLY_ADJ_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// D4_dly 32 Step for adjust, 1 step = 0.2 ns
            D4_DLY: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// D5_dly 32 Step for adjust, 1 step = 0.2 ns
            D5_DLY: u5,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// D6_dly 32 Step for adjust, 1 step = 0.2 ns
            D6_DLY: u5,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// D7_dly 32 Step for adjust, 1 step = 0.2 ns
            D7_DLY: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x514);

        /// address: 0x5801518
        /// CSIC_PRS_NCSIC_RX_SIGNAL6_DLY_ADJ_REG
        pub const CSIC_PRS_NCSIC_RX_SIGNAL6_DLY_ADJ_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// D0_dly 32 Step for adjust, 1 step = 0.2 ns
            D0_DLY: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// D1_dly 32 Step for adjust, 1 step = 0.2 ns
            D1_DLY: u5,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// D2_dly 32 Step for adjust, 1 step = 0.2 ns
            D2_DLY: u5,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// D3_dly 32 Step for adjust, 1 step = 0.2 ns
            D3_DLY: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x518);

        /// address: 0x5801010
        /// CSIC Parser Signal Status Register
        pub const CSIC_PRS_SIGNAL_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the Dn status (n=0–23), MSB for D23, LSB for D0
            /// 0: low
            /// 1: high
            DATA_STA: u24,
            /// Indicates the pclk status
            /// 0: low
            /// 1: high
            PCLK_STA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x10);

        /// address: 0x580100c
        /// Parser Capture Register
        pub const PRS_CAP_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Still capture control: Capture a single still image frame on channel 0.
            /// 0: Disable still capture.
            /// 1: Enable still capture The CSI module starts capturing image data at the start
            /// of the next frame. The CSI module captures only one frame of image data. This
            /// bit is self cleared and always reads as a 0.
            CH0_SCAP_ON: u1,
            /// Video capture control: Capture the video image data stream on channel 0.
            /// 0: Disable video capture If video capture is in progress, the CSI stops
            /// capturing image data at the end of the current frame, and all of the current
            /// frame data is written to output FIFO.
            /// 1: Enable video capture The CSI starts capturing image data at the start of the
            /// next frame.
            CH0_VCAP_ON: u1,
            /// Fps down sample
            /// 0: no down sample
            /// 1: 1/2 fps, only receives the first frame every 2 frames
            /// 2: 1/3 fps, only receives the first frame every 3 frames
            /// 3: 1/4 fps, only receives the first frame every 4 frames
            /// 4: 1/5 fps, only receives the first frame every 4 frames ……
            /// 15: 1/16 fps, only receives the first frame every 16 frames
            CH0_FPS_DS: u4,
            reserved0: u1,
            reserved1: u1,
            /// Still capture control: Capture a single still image frame on channel 1.
            /// 0: Disable still capture
            /// 1: Enable still capture The CSI module starts capturing image data at the start
            /// of the next frame. The CSI module captures only one frame of image data. This
            /// bit is self cleared and always reads as a 0.
            CH1_SCAP_ON: u1,
            /// Video capture control: Capture the video image data stream on channel 1.
            /// 0: Disable video capture If video capture is in progress, the CSI stops
            /// capturing image data at the end of the current frame, and all of the current
            /// frame data is written to output FIFO.
            /// 1: Enable video capture The CSI starts capturing image data at the start of the
            /// next frame.
            CH1_VCAP_ON: u1,
            /// Fps down sample
            /// 0: no down sample
            /// 1: 1/2 fps, only receives the first frame every 2 frames
            /// 2: 1/3 fps, only receives the first frame every 3 frames
            /// 3: 1/4 fps, only receives the first frame every 4 frames
            /// 4: 1/5 fps, only receives the first frame every 4 frames ……
            /// 15: 1/16 fps, only receives the first frame every 16 frames
            CH1_FPS_DS: u4,
            reserved2: u1,
            reserved3: u1,
            /// Still capture control: Capture a single still image frame on channel 2.
            /// 0: Disable still capture
            /// 1: Enable still capture The CSI module starts capturing image data at the start
            /// of the next frame. The CSI module captures only one frame of image data. This
            /// bit is self cleared and always reads as a 0.
            CH2_SCAP_ON: u1,
            /// Video capture control: Capture the video image data stream on channel 2.
            /// 0: Disable video capture If video capture is in progress, the CSI stops
            /// capturing image data at the end of the current frame, and all of the current
            /// frame data is written to output FIFO.
            /// 1: Enable video capture The CSI starts capturing image data at the start of the
            /// next frame.
            CH2_VCAP_ON: u1,
            /// Fps down sample
            /// 0: no down sample
            /// 1: 1/2 fps, only receives the first frame every 2 frames
            /// 2: 1/3 fps, only receives the first frame every 3 frames
            /// 3: 1/4 fps, only receives the first frame every 4 frames
            /// 4: 1/5 fps, only receives the first frame every 4 frames ……
            /// 15: 1/16 fps, only receives the first frame every 16 frames
            CH2_FPS_DS: u4,
            reserved4: u1,
            reserved5: u1,
            /// Still capture control: Capture a single still image frame on channel 3.
            /// 0: Disable still capture
            /// 1: Enable still capture The CSI module starts capturing image data at the start
            /// of the next frame. The CSI module captures only one frame of image data. This
            /// bit is self cleared and always reads as a 0.
            CH3_SCAP_ON: u1,
            /// Video capture control: Capture the video image data stream on channel 3.
            /// 0: Disable video capture If video capture is in progress, the CSI stops
            /// capturing image data at the end of the current frame, and all of the current
            /// frame data is written to output FIFO.
            /// 1: Enable video capture The CSI starts capturing image data at the start of the
            /// next frame.
            CH3_VCAP_ON: u1,
            /// Fps down sample
            /// 0: no down sample
            /// 1: 1/2 fps, only receives the first frame every 2 frames
            /// 2: 1/3 fps, only receives the first frame every 3 frames
            /// 3: 1/4 fps, only receives the first frame every 4 frames
            /// 4: 1/5 fps, only receives the first frame every 4 frames ……
            /// 15: 1/16 fps, only receives the first frame every 16 frames
            CH3_FPS_DS: u4,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc);

        /// address: 0x5801048
        /// Parser Channel_0 Line Time Register
        pub const PRS_CH0_LINE_TIME_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Time of H SYNC when vsync is valid The unit is csi_top_clk cycle
            PRS_CH0_HSYN_TIME: u16,
            /// Time of H Blanking when vsync is valid The unit is csi_top_clk cycle
            PRS_CH0_HBLK_TIME: u16,
        }), base_address + 0x48);

        /// address: 0x5801148
        /// Parser Channel_1 Line Time Register
        pub const PRS_CH1_LINE_TIME_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Time of H SYNC when vsync is valid The unit is csi_top_clk cycle.
            PRS_CH1_HSYN_TIME: u16,
            /// Time of H Blanking when vsync is valid The unit is csi_top_clk cycle.
            PRS_CH1_HBLK_TIME: u16,
        }), base_address + 0x148);

        /// address: 0x5801248
        /// Parser Channel_2 Line Time Register
        pub const PRS_CH2_LINE_TIME_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Time of H SYNC when vsync is valid The unit is csi_top_clk cycle
            PRS_CH2_HSYN_TIME: u16,
            /// Time of H Blanking when vsync is valid The unit is csi_top_clk cycle
            PRS_CH2_HBLK_TIME: u16,
        }), base_address + 0x248);

        /// address: 0x5801348
        /// Parser Channel_3 Line Time Register
        pub const PRS_CH3_LINE_TIME_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Time of H SYNC when vsync is valid The unit is csi_top_clk cycle
            PRS_CH3_HSYN_TIME: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x348);

        /// address: 0x5801000
        /// Parser Enable Register
        pub const PRS_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Reset and disable the parser module
            /// 1: Enable the parser module
            PRS_EN: u1,
            /// 0: Reserved
            /// 1: MCSI
            PRS_MODE: u1,
            /// 0: Parser output channel 0–3 corresponding from input channel 0–3
            /// 1: Parser output channel 0–3 all from input channel 0 (MIPI SEHDR)
            PRS_CH_MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// 0: Gate pclk input
            /// 1: Enable pclk input
            PCLK_EN: u1,
            /// 0: Reset and disable the NCSIC module
            /// 1: Enable the NCSIC module
            NCSIC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);
    };

    /// CSIC_DMA0
    pub const CSIC_DMA0 = struct {
        pub const base_address = 0x5809000;

        /// address: 0x5809064
        /// CSIC_DMA_ACC_ITNL_CLK_CNT_REG
        pub const CSIC_DMA_ACC_ITNL_CLK_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The instant value of internal frame clock counter. When frame done interrupt
            /// comes, the software can query this counter for judging whether it is the time
            /// for updating the double buffer address registers.
            ITNL_CLK_CNT: u24,
            /// The accumulated value of FRM_CLK_CNT for software frame rate statics. Every
            /// interrupt of frame is done, the software checks this accumulated value and
            /// clears it to 0. If the ACC_CLK_CNT is larger than 1, the software has lost
            /// frame. When frame done or vsync comes, ACC_CLK_CNT = ACC_CLK_CNT + 1, and
            /// cleared to 0 when writing this register.
            ACC_CLK_CNT: u8,
        }), base_address + 0x64);

        /// address: 0x5809080
        /// CSIC_DMA_BUF_ADDR_FIFO0_ENTRY_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO0_ENTRY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Entry of Buffer Address FIFO0 for input frames to be stored, only used in
            /// Buffer Addr FIFO Mode
            CSIC_DMA_BUF_ADDR_FIFO0_ENTRY: u32,
        }), base_address + 0x80);

        /// address: 0x5809084
        /// CSIC_DMA_BUF_ADDR_FIFO1_ENTRY_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO1_ENTRY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Entry of Buffer Address FIFO1 for input frames to be stored, only used in
            /// Buffer Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO1_ENTRY: u32,
        }), base_address + 0x84);

        /// address: 0x5809088
        /// CSIC_DMA_BUF_ADDR_FIFO2_ENTRY_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO2_ENTRY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Entry of Buffer Address FIFO2 for input frames to be stored, only used in
            /// Buffer Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO2_ENTRY: u32,
        }), base_address + 0x88);

        /// address: 0x5809090
        /// CSIC_DMA_BUF_ADDR_FIFO_CON_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO_CON_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Content of address buffered in Buffer Address FIFO0, only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO0_CONTENT: u6,
            reserved0: u1,
            reserved1: u1,
            /// FIFO Content of address buffered in Buffer Address FIFO1, only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO1_CONTENT: u6,
            reserved2: u1,
            reserved3: u1,
            /// FIFO Content of address buffered in Buffer Address FIFO2, only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO2_CONTENT: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x90);

        /// address: 0x5809038
        /// CSIC DMA Buffer Length Register
        pub const CSIC_DMA_BUF_LEN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA_MODE:Buffer length of luminance Y in a line. Unit is byte. LBC_MODE: Buffer
            /// length Stride of luminance Y and chroma C in YC line. Unit is byte. Only
            /// Readable when BUF_LENGTH_CFG_MODE is set 0.
            BUF_LEN: u14,
            reserved0: u1,
            reserved1: u1,
            /// DMA_MODE: Buffer length of chroma C in a line. Unit is byte. LBC_MODE: Buffer
            /// length Stride of luminance Y in ONLY Y line. Unit is byte. Only Readable when
            /// BUF_LENGTH_CFG_MODE is set 0.
            BUF_LEN_C: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x38);

        /// address: 0x580908c
        /// CSIC DMA BUF Threshold Register
        pub const CSIC_DMA_BUF_TH_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// when content in Buffer Address FIFO less than the threshold, an interrupt is
            /// set, only used in Buffer Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO_THRESHOLD: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// when stored frame counter value reaches the threshold , counter is cleared to 0
            /// , only used in Buffer Addr FIFO Mode.
            CSIC_DMA_STORED_FRM_THRESHOLD: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8c);

        /// address: 0x580904c
        /// CSIC DMA Capture Status Register
        pub const CSIC_DMA_CAP_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Still capture in progress Indicates the CSI is capturing still image data
            /// (single frame). The bit is set at the start of the first frame after enabling
            /// still frame capture. It clears itself after the last pixel of the first frame is
            /// captured. For CCIR656 interface, if the output format is frame planar YCbCr 420
            /// mode, the frame end means the field2 end, the other frame end means filed end.
            SCAP_STA: u1,
            /// Video capture in progress Indicates the CSI is capturing video image data
            /// (multiple frames). The bit is set at the start of the first frame after enabling
            /// video capture. When software disables video capture, it clears itself after the
            /// last pixel of the current frame is captured.
            VCAP_STA: u1,
            /// The status of the received field
            /// 0: Field 0
            /// 1: Field 1
            FIELD_STA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c);

        /// address: 0x5809004
        /// CSIC DMA Configuration Register
        pub const CSIC_DMA_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Minimum size of SDRAM block write
            /// 00: 256 bytes (if hflip is enabled, always select 256 bytes)
            /// 01: 512 bytes
            /// 10: 1K bytes
            /// 11: 2K bytes
            MIN_SDR_WR_SIZE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Fps down sample
            /// 0: no down sample
            /// 1: 1/2 fps, only receives the first frame every 2 frames
            /// 2: 1/3 fps, only receives the first frame every 3 frames
            /// 3: 1/4 fps, only receives the first frame every 4 frames
            /// 4: 1/5 fps, only receives the first frame every 4 frames ……
            /// 15: 1/16 fps, only receives the first frame every 16 frames
            FPS_DS: u4,
            /// Field selection
            /// 00: Capturing with field 0
            /// 01: Capturing with field 1
            /// 10: Capturing with either field
            /// 11: Reserved
            FIELD_SEL: u2,
            /// Horizontal flip enable When enabled, the received data will be arranged in
            /// horizontal flip.
            /// 0: Disable
            /// 1: Enable
            HFLIP_EN: u1,
            /// Vertical flip enable When enabled, the received data will be arranged in
            /// vertical flip.
            /// 0: Disable
            /// 1: Enable
            VFLIP_EN: u1,
            reserved4: u1,
            reserved5: u1,
            /// Output data format When the input format is set to RAW stream
            /// 0000: field-raw-8
            /// 0001: field-raw-10
            /// 0010: field-raw-12
            /// 0011: reserved
            /// 0100: field-rgb565
            /// 0101: field-rgb888
            /// 0110: field-prgb888
            /// 0111: reserved
            /// 1000: frame-raw-8
            /// 1001: frame-raw-10
            /// 1010: frame-raw-12
            /// 1011: reserved
            /// 1100: frame-rgb565
            /// 1101: frame-rgb888
            /// 1110: frame-prgb888
            /// 1111: reserved When the input format is set to YUV422
            /// 0000: field planar YCbCr 422
            /// 0001: field planar YCbCr 420
            /// 0010: frame planar YCbCr 420
            /// 0011: frame planar YCbCr 422
            /// 0100: field planar YCbCr 422 UV combined (UV sequence)
            /// 0101: field planar YCbCr 420 UV combined (UV sequence)
            /// 0110: frame planar YCbCr 420 UV combined (UV sequence)
            /// 0111: frame planar YCbCr 422 UV combined (UV sequence)
            /// 1000: filed planar YCbCr 422 UV combined (VU sequence)
            /// 1001: field planar YCbCr 420 UV combined (VU sequence)
            /// 1010: frame planar YCbCr 420 UV combined (VU sequence)
            /// 1011: frame planar YCbCr 422 UV combined (VU sequence)
            /// 1100: reserved
            /// 1101: field YCbCr 400
            /// 1110: reserved
            /// 1111: frame YCbCr 400 When the input format is set to YUV420
            /// 0000: reserved
            /// 0001: field planar YCbCr 420
            /// 0010: frame planar YCbCr 420
            /// 0011: reserved
            /// 0100: reserved
            /// 0101: field planar YCbCr 420 UV combined (UV sequence)
            /// 0110: frame planar YCbCr 420 UV combined (UV sequence) 0111~1000: reserved
            /// 1001: field planar YCbCr 420 UV combined (VU sequence)
            /// 1010: frame planar YCbCr 420 UV combined (VU sequence) 1011~1100: reserved
            /// 1101: field YCbCr 400
            /// 1110: reserved
            /// 1111: frame YCbCr 400
            OUTPUT_FMT: u4,
            /// 10-bit store configuration
            /// 0: YUV 10-bit stored in low 10-bit of a 16-bit word
            /// 1: YUV 10-bit stored in high 10-bit of a 16-bit word
            YUV: u1,
            /// 10-bit input cut to 8-bit
            /// 0: Disable
            /// 1: Enable
            YUV: u1,
            reserved6: u1,
            reserved7: u1,
            /// Padding value when OUTPUT_FMT is prgb888 0x00–0xff
            PAD_VAL: u8,
        }), base_address + 0x4);

        /// address: 0x5809000
        /// CSIC DMA Enable Register
        pub const CSIC_DMA_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable
            /// 1: Enable
            BK_TOP_EN: u1,
            /// clk count per frame enable
            CLK_CNT_EN: u1,
            /// Sampling time for clk counter per frame
            /// 0: Sampling clock counter every frame done
            /// 1: Sampling clock counter every vsync
            CLK_CNT_SPL: u1,
            reserved0: u1,
            /// When BK_TOP_EN is enabled, setting 1 to this bit indicates the module works in
            /// DMA mode.
            /// 0: Disable
            /// 1: Enable
            DMA_EN: u1,
            /// When BK_TOP_EN is enabled, setting 1 to this bit indicates the Frame counter
            /// starts to add.
            /// 0: Disable
            /// 1: Enable
            FRAME_CNT_EN: u1,
            /// Enable Video Input Timeout counter, add 1 when there is no effective video input
            /// in a 12M clock, clear to 0 when detecting effective video input.
            /// 0: Disable
            /// 1: Enable
            VI_TO_CNT_EN: u1,
            /// 0: Buffer Address Register Mode
            /// 1: Buffer Address FIFO Mode
            BUF_ADDR_MODE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// FLIP SIZE set by software or calculated by hardware
            /// 0: Hardware
            /// 1: Software
            FLIP_SIZE_CFG_MODE: u1,
            /// Buffer length set by software or calculated by hardware
            /// 0: Hardware
            /// 1: Software
            BUF_LENGTH_CFG_MODE: u1,
            /// Vflip buffer address set by software or calculated by hardware
            /// 0: Hardware
            /// 1: Software
            VFLIP_BUF_ADDR_CFG_MODE: u1,
            VER_EN: u1,
        }), base_address + 0x0);

        /// address: 0x5809020
        /// CSIC DMA FIFO 0 Output Buffer-A Address Register
        pub const CSIC_DMA_F0_BUFA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// When BK_TOP_EN is enabled, FBC_EN is enabled, DMA_EN is disabled, these bits
            /// indicate output address of overhead data in FBC mode. When BK_TOP_EN is enabled,
            /// FBC_EN is disabled, DMA_EN is enabled, LBC_EN is disabled, these bits indicate
            /// FIFO 0 output buffer-A address in DMA mode. When BK_TOP_EN is enabled, FBC_EN is
            /// disabled, DMA_EN is enabled, LBC_EN is enabled, these bits indicate the output
            /// buffer address in LBC mode.
            F0_BUFA: u32,
        }), base_address + 0x20);

        /// address: 0x5809024
        /// CSIC DMA FIFO 0 Output Buffer-A Address Result Register
        pub const CSIC_DMA_F0_BUFA_RESULT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicate the final F0_BUFA address used for DMA or FBC after software
            /// configuration or hardware calculation from Buffer-A address register or buffer
            /// address fifo. Only used for debug.
            F0_BUFA_RESULT: u32,
        }), base_address + 0x24);

        /// address: 0x5809028
        /// CSIC DMA FIFO 1 Output Buffer-A Address Register
        pub const CSIC_DMA_F1_BUFA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// When BK_TOP_EN is enabled, FBC_EN is enabled, DMA_EN is disabled, these bits
            /// indicate the output address of compressed data in FBC mode. When BK_TOP_EN is
            /// enabled, FBC_EN is disabled, DMA_EN is enabled, these bits indicate the FIFO 1
            /// output buffer-A address in DMA mode.
            F1_BUFA: u32,
        }), base_address + 0x28);

        /// address: 0x580902c
        /// CSIC DMA FIFO 2 Output Buffer-A Address Result Register
        pub const CSIC_DMA_F1_BUFA_RESULT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicate the final F1_BUFA address used for DMA or FBC after software
            /// configuration or hardware calculation from Buffer-A address register or buffer
            /// address fifo. Only used for debug.
            F1_BUFA_RESULT: u32,
        }), base_address + 0x2c);

        /// address: 0x5809030
        /// CSIC DMA FIFO 2 Output Buffer-A Address Register
        pub const CSIC_DMA_F2_BUFA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO 2 output buffer-A address.
            F2_BUFA: u32,
        }), base_address + 0x30);

        /// address: 0x5809068
        /// CSIC DMA FIFO Statistic Register
        pub const CSIC_DMA_FIFO_STAT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the maximum depth of FIFO being occupied for whole frame. Update at
            /// every vsync or framedone.
            FIFO_FRM_MAX: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Line Index Indicates the line index in current vsync.
            LINE: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x68);

        /// address: 0x580906c
        /// CSIC DMA FIFO Threshold Register
        pub const CSIC_DMA_FIFO_THRS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// When FIFO occupied memory exceed the threshold, dram frequency can not change.
            FIFO_THRS: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x6c);

        /// address: 0x580903c
        /// CSIC DMA Flip Size Register
        pub const CSIC_DMA_FLIP_SIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Valid components of a line when in HFLIP mode. Unit is pixel component. Only
            /// Readable when FLIP_SIZE_CFG_MODE is set to 0.
            VALID_LEN: u14,
            reserved0: u1,
            reserved1: u1,
            /// Vertical line number when in VFLIP mode. Unit is line. Only Readable when
            /// FLIP_SIZE_CFG_MODE is set to 0.
            VER_LEN: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x3c);

        /// address: 0x5809060
        /// CSIC DMA Frame Clock Counter Register
        pub const CSIC_DMA_FRM_CLK_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value between every frame. For instant hardware frame rate statics. The
            /// internal counter is added by one every 12 MHz clock cycle. When frame done or
            /// vsync comes, the internal counter value is sampled to FRM_CLK_CNT, and cleared
            /// to 0.
            FRM_CLK_CNT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x60);

        /// address: 0x580905c
        /// CSIC DMA Frame Counter Register
        pub const CSIC_DMA_FRM_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value of frame. When frame done comes, the internal counter value add 1,
            /// and when the reg full, it is cleared to 0 . When parser sent a sync signal, it
            /// is cleared to 0.
            FRM_CNT: u16,
            /// Frame cnt clear cycle N*T
            PCLK_DMA_CLR_DISTANCE: u15,
            /// When the bit set to 1, Frame cnt is cleared to 0.
            FRM_CNT_CLR: u1,
        }), base_address + 0x5c);

        /// address: 0x5809010
        /// CSIC DMA Horizontal Size Register
        pub const CSIC_DMA_HSIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal pixel unit start. Pixel is valid from this pixel.
            HOR_START: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// When BK_TOP_EN is enabled, DMA_EN is enabled, these bits indicate Horizontal
            /// pixel unit length. Valid pixel of a line in DMA mode.
            HOR_LEN: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x5809050
        /// CSIC DMA Interrupt Enable Register
        pub const CSIC_DMA_INT_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture done Indicates the CSI has completed capturing the image data. For still
            /// capture, the bit is set when one frame data has been written to buffer. For
            /// video capture, the bit is set when the last frame has been written to buffer
            /// after video capture has been disabled. For CCIR656 interface, if the output
            /// format is frame planar YCbCr 420 mode, the frame end means the field2 end, the
            /// other frame end means field end.
            CD_INT_EN: u1,
            /// Frame done Indicates the CSI has finished capturing an image frame. Applies to
            /// video capture mode. The bit is set after each completed frame capturing data is
            /// written to buffer as long as video capture remains enabled.
            FD_INT_EN: u1,
            /// FIFO 0 overflow The bit is set when the FIFO 0 became overflow.
            FIFO0_OF_INT_EN: u1,
            /// FIFO 1 overflow The bit is set when the FIFO 1 became overflow.
            FIFO1_OF_INT_EN: u1,
            /// FIFO 2 overflow The bit is set when the FIFO 2 became overflow.
            FIFO2_OF_INT_EN: u1,
            /// Line counter flag The bit is set when the specific line has been written to dram
            /// every frame. The line number is set in the line counter register.
            LC_INT_EN: u1,
            /// Hblank FIFO overflow The bit is set when 3 FIFOs still overflow after the
            /// hblank.
            HB_OF_INT_EN: u1,
            /// vsync flag The bit is set when vsync come. And at this time load the buffer
            /// address for the coming frame. So after this irq come, changing the buffer
            /// address could only effect next frame
            VS_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Set a INT when clear Frame cnt.
            CLR_FRAME_CNT_INT_EN: u1,
            /// Set an INT when no video input exceeds the setting threshold time
            VIDEO_INPUT_TO_INT_EN: u1,
            /// Set an INT when content in BUF Address FIFO less than
            /// CSIC_DMA_BUFA_FIFO_THRESHOLD, only use in BUF Address FIFO MODE.
            BUF_ADDR_FIFO_INT_EN: u1,
            /// Set an INT when the value of CSIC_DMA_STORED_FRM_CNT reaches
            /// CSIC_DMA_STORED_FRM_THRESHOLD, only use in BUF Address FIFO MODE.
            STORED_FRM_CNT_INT_EN: u1,
            /// Set an INT when frame starts with empty Buffer Address FIFO, only use in BUF
            /// Address FIFO MODE.
            FRM_LOST_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x5809054
        /// CSIC DMA Interrupt Status Register
        pub const CSIC_DMA_INT_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture done
            CD_PD: u1,
            /// Frame done
            FD_PD: u1,
            /// FIFO 0 overflow
            FIFO0_OF_PD: u1,
            /// FIFO 1 overflow
            FIFO1_OF_PD: u1,
            /// FIFO 2 overflow
            FIFO2_OF_PD: u1,
            /// Line counter flag
            LC_PD: u1,
            /// Line information FIFO (16 lines) overflow
            LI_OF_PD: u1,
            /// vsync flag
            VS_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Set a INT when clear Frame cnt.
            CLR_FRAME_CNT_INT: u1,
            /// Set an INT Pending when no video input exceeds the setting threshold time.
            VIDEO_INPUT_TO_INT_PD: u1,
            /// Set an INT when content in BUF Address FIFO less than
            /// CSIC_DMA_BUFA_FIFO_THRESHOLD, only use in BUF Address FIFO MODE.
            BUF_ADDR_FIFO_INT_PD: u1,
            /// Set an INT when the value of CSIC_DMA_STORED_FRM_CNT reaches
            /// CSIC_DMA_STORED_FRM_THRESHOLD, only use in BUF Address FIFO MODE.
            STORED_FRM_CNT_INT_PD: u1,
            /// Set an INT when frame starts with empty Buffer Address FIFO, only use in BUF
            /// Address FIFO MODE.
            FRM_LOST_INT_PD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x5809058
        /// CSIC DMA LINE Counter Register
        pub const CSIC_DMA_LINE_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The LINE_CNT_NUM value is set by user,when internal line counter reach the set
            /// value, the LC_PD will be set.
            LINE_CNT_NUM: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x58);

        /// address: 0x5809070
        /// CSIC DMA PCLK Statistic Register
        pub const CSIC_DMA_PCLK_STAT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates minimum pixel clock counter value for each line. Update at every vsync
            /// or framedone.
            PCLK_CNT_LINE_MIN: u15,
            reserved0: u1,
            /// Indicates maximum pixel clock counter value for each line. Update at every vsync
            /// or framedone.
            PCLK_CNT_LINE_MAX: u15,
            padding0: u1,
        }), base_address + 0x70);

        /// address: 0x5809094
        /// CSIC DMA Stored Frame Counter Register
        pub const CSIC_DMA_STORED_FRM_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates value of stored frames counter. When the counter value reaches
            /// CSIC_DMA_STORED_FRM_THRESHOLD, the counter is cleared to 0. Only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_STORED_FRM_CNT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x94);

        /// address: 0x5809048
        /// CSIC DMA Video Input Timeout Counter Value Register
        pub const CSIC_DMA_VI_TO_CNT_VAL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Input Timeout Counter Value Indicate the current value of Video Input
            /// Timeout Counter
            VIDEO: u32,
        }), base_address + 0x48);

        /// address: 0x5809040
        /// CSIC DMA Video Input Timeout Threshold0 Register
        pub const CSIC_DMA_VI_TO_TH0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Input Timeout Threshold0 Set VIDEO_INPUT_TO_INT_PD when VI Counter reaches
            /// TH0 after VI_TO_CNT_EN is set, the Time Unit is a 12M clock period.
            VIDEO: u32,
        }), base_address + 0x40);

        /// address: 0x5809044
        /// CSIC DMA Video Input Timeout Threshold1 Register
        pub const CSIC_DMA_VI_TO_TH1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Input Timeout Threshold1 Set VIDEO_INPUT_TO_INT_PD when VI Counter reaches
            /// TH1 after getting the first frame has been input, the Time Unit is a 12M clock
            /// period.
            VIDEO: u32,
        }), base_address + 0x44);

        /// address: 0x5809014
        /// CSIC DMA Vertical Size Register
        pub const CSIC_DMA_VSIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical line start Data is valid from this line.
            VER_START: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// When BK_TOP_EN is enabled, DMA_EN is enabled, these bits indicate Valid line
            /// number of a frame in DMA mode.
            VER_LEN: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x14);

        /// address: 0x58091f4
        /// CSIC DMA Feature List Register
        pub const CSIC_FEATURE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: No Embedded DMA
            /// 1: Embedded FBC
            DMA0_EMBEDDED_FBC: u1,
            /// 0: No Embedded LBC
            /// 1: Embedded LBC
            DMA0_EMBEDDED_LBC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1f4);
    };

    /// CSIC_DMA1
    pub const CSIC_DMA1 = struct {
        pub const base_address = 0x5809200;

        /// address: 0x5809264
        /// CSIC_DMA_ACC_ITNL_CLK_CNT_REG
        pub const CSIC_DMA_ACC_ITNL_CLK_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The instant value of internal frame clock counter. When frame done interrupt
            /// comes, the software can query this counter for judging whether it is the time
            /// for updating the double buffer address registers.
            ITNL_CLK_CNT: u24,
            /// The accumulated value of FRM_CLK_CNT for software frame rate statics. Every
            /// interrupt of frame is done, the software checks this accumulated value and
            /// clears it to 0. If the ACC_CLK_CNT is larger than 1, the software has lost
            /// frame. When frame done or vsync comes, ACC_CLK_CNT = ACC_CLK_CNT + 1, and
            /// cleared to 0 when writing this register.
            ACC_CLK_CNT: u8,
        }), base_address + 0x64);

        /// address: 0x5809280
        /// CSIC_DMA_BUF_ADDR_FIFO0_ENTRY_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO0_ENTRY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Entry of Buffer Address FIFO0 for input frames to be stored, only used in
            /// Buffer Addr FIFO Mode
            CSIC_DMA_BUF_ADDR_FIFO0_ENTRY: u32,
        }), base_address + 0x80);

        /// address: 0x5809284
        /// CSIC_DMA_BUF_ADDR_FIFO1_ENTRY_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO1_ENTRY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Entry of Buffer Address FIFO1 for input frames to be stored, only used in
            /// Buffer Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO1_ENTRY: u32,
        }), base_address + 0x84);

        /// address: 0x5809288
        /// CSIC_DMA_BUF_ADDR_FIFO2_ENTRY_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO2_ENTRY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Entry of Buffer Address FIFO2 for input frames to be stored, only used in
            /// Buffer Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO2_ENTRY: u32,
        }), base_address + 0x88);

        /// address: 0x5809290
        /// CSIC_DMA_BUF_ADDR_FIFO_CON_REG
        pub const CSIC_DMA_BUF_ADDR_FIFO_CON_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Content of address buffered in Buffer Address FIFO0, only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO0_CONTENT: u6,
            reserved0: u1,
            reserved1: u1,
            /// FIFO Content of address buffered in Buffer Address FIFO1, only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO1_CONTENT: u6,
            reserved2: u1,
            reserved3: u1,
            /// FIFO Content of address buffered in Buffer Address FIFO2, only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO2_CONTENT: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x90);

        /// address: 0x5809238
        /// CSIC DMA Buffer Length Register
        pub const CSIC_DMA_BUF_LEN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA_MODE:Buffer length of luminance Y in a line. Unit is byte. LBC_MODE: Buffer
            /// length Stride of luminance Y and chroma C in YC line. Unit is byte. Only
            /// Readable when BUF_LENGTH_CFG_MODE is set 0.
            BUF_LEN: u14,
            reserved0: u1,
            reserved1: u1,
            /// DMA_MODE: Buffer length of chroma C in a line. Unit is byte. LBC_MODE: Buffer
            /// length Stride of luminance Y in ONLY Y line. Unit is byte. Only Readable when
            /// BUF_LENGTH_CFG_MODE is set 0.
            BUF_LEN_C: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x38);

        /// address: 0x580928c
        /// CSIC DMA BUF Threshold Register
        pub const CSIC_DMA_BUF_TH_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// when content in Buffer Address FIFO less than the threshold, an interrupt is
            /// set, only used in Buffer Addr FIFO Mode.
            CSIC_DMA_BUF_ADDR_FIFO_THRESHOLD: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// when stored frame counter value reaches the threshold , counter is cleared to 0
            /// , only used in Buffer Addr FIFO Mode.
            CSIC_DMA_STORED_FRM_THRESHOLD: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8c);

        /// address: 0x580924c
        /// CSIC DMA Capture Status Register
        pub const CSIC_DMA_CAP_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Still capture in progress Indicates the CSI is capturing still image data
            /// (single frame). The bit is set at the start of the first frame after enabling
            /// still frame capture. It clears itself after the last pixel of the first frame is
            /// captured. For CCIR656 interface, if the output format is frame planar YCbCr 420
            /// mode, the frame end means the field2 end, the other frame end means filed end.
            SCAP_STA: u1,
            /// Video capture in progress Indicates the CSI is capturing video image data
            /// (multiple frames). The bit is set at the start of the first frame after enabling
            /// video capture. When software disables video capture, it clears itself after the
            /// last pixel of the current frame is captured.
            VCAP_STA: u1,
            /// The status of the received field
            /// 0: Field 0
            /// 1: Field 1
            FIELD_STA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c);

        /// address: 0x5809204
        /// CSIC DMA Configuration Register
        pub const CSIC_DMA_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Minimum size of SDRAM block write
            /// 00: 256 bytes (if hflip is enabled, always select 256 bytes)
            /// 01: 512 bytes
            /// 10: 1K bytes
            /// 11: 2K bytes
            MIN_SDR_WR_SIZE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Fps down sample
            /// 0: no down sample
            /// 1: 1/2 fps, only receives the first frame every 2 frames
            /// 2: 1/3 fps, only receives the first frame every 3 frames
            /// 3: 1/4 fps, only receives the first frame every 4 frames
            /// 4: 1/5 fps, only receives the first frame every 4 frames ……
            /// 15: 1/16 fps, only receives the first frame every 16 frames
            FPS_DS: u4,
            /// Field selection
            /// 00: Capturing with field 0
            /// 01: Capturing with field 1
            /// 10: Capturing with either field
            /// 11: Reserved
            FIELD_SEL: u2,
            /// Horizontal flip enable When enabled, the received data will be arranged in
            /// horizontal flip.
            /// 0: Disable
            /// 1: Enable
            HFLIP_EN: u1,
            /// Vertical flip enable When enabled, the received data will be arranged in
            /// vertical flip.
            /// 0: Disable
            /// 1: Enable
            VFLIP_EN: u1,
            reserved4: u1,
            reserved5: u1,
            /// Output data format When the input format is set to RAW stream
            /// 0000: field-raw-8
            /// 0001: field-raw-10
            /// 0010: field-raw-12
            /// 0011: reserved
            /// 0100: field-rgb565
            /// 0101: field-rgb888
            /// 0110: field-prgb888
            /// 0111: reserved
            /// 1000: frame-raw-8
            /// 1001: frame-raw-10
            /// 1010: frame-raw-12
            /// 1011: reserved
            /// 1100: frame-rgb565
            /// 1101: frame-rgb888
            /// 1110: frame-prgb888
            /// 1111: reserved When the input format is set to YUV422
            /// 0000: field planar YCbCr 422
            /// 0001: field planar YCbCr 420
            /// 0010: frame planar YCbCr 420
            /// 0011: frame planar YCbCr 422
            /// 0100: field planar YCbCr 422 UV combined (UV sequence)
            /// 0101: field planar YCbCr 420 UV combined (UV sequence)
            /// 0110: frame planar YCbCr 420 UV combined (UV sequence)
            /// 0111: frame planar YCbCr 422 UV combined (UV sequence)
            /// 1000: filed planar YCbCr 422 UV combined (VU sequence)
            /// 1001: field planar YCbCr 420 UV combined (VU sequence)
            /// 1010: frame planar YCbCr 420 UV combined (VU sequence)
            /// 1011: frame planar YCbCr 422 UV combined (VU sequence)
            /// 1100: reserved
            /// 1101: field YCbCr 400
            /// 1110: reserved
            /// 1111: frame YCbCr 400 When the input format is set to YUV420
            /// 0000: reserved
            /// 0001: field planar YCbCr 420
            /// 0010: frame planar YCbCr 420
            /// 0011: reserved
            /// 0100: reserved
            /// 0101: field planar YCbCr 420 UV combined (UV sequence)
            /// 0110: frame planar YCbCr 420 UV combined (UV sequence) 0111~1000: reserved
            /// 1001: field planar YCbCr 420 UV combined (VU sequence)
            /// 1010: frame planar YCbCr 420 UV combined (VU sequence) 1011~1100: reserved
            /// 1101: field YCbCr 400
            /// 1110: reserved
            /// 1111: frame YCbCr 400
            OUTPUT_FMT: u4,
            /// 10-bit store configuration
            /// 0: YUV 10-bit stored in low 10-bit of a 16-bit word
            /// 1: YUV 10-bit stored in high 10-bit of a 16-bit word
            YUV: u1,
            /// 10-bit input cut to 8-bit
            /// 0: Disable
            /// 1: Enable
            YUV: u1,
            reserved6: u1,
            reserved7: u1,
            /// Padding value when OUTPUT_FMT is prgb888 0x00–0xff
            PAD_VAL: u8,
        }), base_address + 0x4);

        /// address: 0x5809200
        /// CSIC DMA Enable Register
        pub const CSIC_DMA_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable
            /// 1: Enable
            BK_TOP_EN: u1,
            /// clk count per frame enable
            CLK_CNT_EN: u1,
            /// Sampling time for clk counter per frame
            /// 0: Sampling clock counter every frame done
            /// 1: Sampling clock counter every vsync
            CLK_CNT_SPL: u1,
            reserved0: u1,
            /// When BK_TOP_EN is enabled, setting 1 to this bit indicates the module works in
            /// DMA mode.
            /// 0: Disable
            /// 1: Enable
            DMA_EN: u1,
            /// When BK_TOP_EN is enabled, setting 1 to this bit indicates the Frame counter
            /// starts to add.
            /// 0: Disable
            /// 1: Enable
            FRAME_CNT_EN: u1,
            /// Enable Video Input Timeout counter, add 1 when there is no effective video input
            /// in a 12M clock, clear to 0 when detecting effective video input.
            /// 0: Disable
            /// 1: Enable
            VI_TO_CNT_EN: u1,
            /// 0: Buffer Address Register Mode
            /// 1: Buffer Address FIFO Mode
            BUF_ADDR_MODE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// FLIP SIZE set by software or calculated by hardware
            /// 0: Hardware
            /// 1: Software
            FLIP_SIZE_CFG_MODE: u1,
            /// Buffer length set by software or calculated by hardware
            /// 0: Hardware
            /// 1: Software
            BUF_LENGTH_CFG_MODE: u1,
            /// Vflip buffer address set by software or calculated by hardware
            /// 0: Hardware
            /// 1: Software
            VFLIP_BUF_ADDR_CFG_MODE: u1,
            VER_EN: u1,
        }), base_address + 0x0);

        /// address: 0x5809220
        /// CSIC DMA FIFO 0 Output Buffer-A Address Register
        pub const CSIC_DMA_F0_BUFA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// When BK_TOP_EN is enabled, FBC_EN is enabled, DMA_EN is disabled, these bits
            /// indicate output address of overhead data in FBC mode. When BK_TOP_EN is enabled,
            /// FBC_EN is disabled, DMA_EN is enabled, LBC_EN is disabled, these bits indicate
            /// FIFO 0 output buffer-A address in DMA mode. When BK_TOP_EN is enabled, FBC_EN is
            /// disabled, DMA_EN is enabled, LBC_EN is enabled, these bits indicate the output
            /// buffer address in LBC mode.
            F0_BUFA: u32,
        }), base_address + 0x20);

        /// address: 0x5809224
        /// CSIC DMA FIFO 0 Output Buffer-A Address Result Register
        pub const CSIC_DMA_F0_BUFA_RESULT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicate the final F0_BUFA address used for DMA or FBC after software
            /// configuration or hardware calculation from Buffer-A address register or buffer
            /// address fifo. Only used for debug.
            F0_BUFA_RESULT: u32,
        }), base_address + 0x24);

        /// address: 0x5809228
        /// CSIC DMA FIFO 1 Output Buffer-A Address Register
        pub const CSIC_DMA_F1_BUFA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// When BK_TOP_EN is enabled, FBC_EN is enabled, DMA_EN is disabled, these bits
            /// indicate the output address of compressed data in FBC mode. When BK_TOP_EN is
            /// enabled, FBC_EN is disabled, DMA_EN is enabled, these bits indicate the FIFO 1
            /// output buffer-A address in DMA mode.
            F1_BUFA: u32,
        }), base_address + 0x28);

        /// address: 0x580922c
        /// CSIC DMA FIFO 2 Output Buffer-A Address Result Register
        pub const CSIC_DMA_F1_BUFA_RESULT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicate the final F1_BUFA address used for DMA or FBC after software
            /// configuration or hardware calculation from Buffer-A address register or buffer
            /// address fifo. Only used for debug.
            F1_BUFA_RESULT: u32,
        }), base_address + 0x2c);

        /// address: 0x5809230
        /// CSIC DMA FIFO 2 Output Buffer-A Address Register
        pub const CSIC_DMA_F2_BUFA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO 2 output buffer-A address.
            F2_BUFA: u32,
        }), base_address + 0x30);

        /// address: 0x5809268
        /// CSIC DMA FIFO Statistic Register
        pub const CSIC_DMA_FIFO_STAT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the maximum depth of FIFO being occupied for whole frame. Update at
            /// every vsync or framedone.
            FIFO_FRM_MAX: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Line Index Indicates the line index in current vsync.
            LINE: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x68);

        /// address: 0x580926c
        /// CSIC DMA FIFO Threshold Register
        pub const CSIC_DMA_FIFO_THRS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// When FIFO occupied memory exceed the threshold, dram frequency can not change.
            FIFO_THRS: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x6c);

        /// address: 0x580923c
        /// CSIC DMA Flip Size Register
        pub const CSIC_DMA_FLIP_SIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Valid components of a line when in HFLIP mode. Unit is pixel component. Only
            /// Readable when FLIP_SIZE_CFG_MODE is set to 0.
            VALID_LEN: u14,
            reserved0: u1,
            reserved1: u1,
            /// Vertical line number when in VFLIP mode. Unit is line. Only Readable when
            /// FLIP_SIZE_CFG_MODE is set to 0.
            VER_LEN: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x3c);

        /// address: 0x5809260
        /// CSIC DMA Frame Clock Counter Register
        pub const CSIC_DMA_FRM_CLK_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value between every frame. For instant hardware frame rate statics. The
            /// internal counter is added by one every 12 MHz clock cycle. When frame done or
            /// vsync comes, the internal counter value is sampled to FRM_CLK_CNT, and cleared
            /// to 0.
            FRM_CLK_CNT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x60);

        /// address: 0x580925c
        /// CSIC DMA Frame Counter Register
        pub const CSIC_DMA_FRM_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value of frame. When frame done comes, the internal counter value add 1,
            /// and when the reg full, it is cleared to 0 . When parser sent a sync signal, it
            /// is cleared to 0.
            FRM_CNT: u16,
            /// Frame cnt clear cycle N*T
            PCLK_DMA_CLR_DISTANCE: u15,
            /// When the bit set to 1, Frame cnt is cleared to 0.
            FRM_CNT_CLR: u1,
        }), base_address + 0x5c);

        /// address: 0x5809210
        /// CSIC DMA Horizontal Size Register
        pub const CSIC_DMA_HSIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal pixel unit start. Pixel is valid from this pixel.
            HOR_START: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// When BK_TOP_EN is enabled, DMA_EN is enabled, these bits indicate Horizontal
            /// pixel unit length. Valid pixel of a line in DMA mode.
            HOR_LEN: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x5809250
        /// CSIC DMA Interrupt Enable Register
        pub const CSIC_DMA_INT_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture done Indicates the CSI has completed capturing the image data. For still
            /// capture, the bit is set when one frame data has been written to buffer. For
            /// video capture, the bit is set when the last frame has been written to buffer
            /// after video capture has been disabled. For CCIR656 interface, if the output
            /// format is frame planar YCbCr 420 mode, the frame end means the field2 end, the
            /// other frame end means field end.
            CD_INT_EN: u1,
            /// Frame done Indicates the CSI has finished capturing an image frame. Applies to
            /// video capture mode. The bit is set after each completed frame capturing data is
            /// written to buffer as long as video capture remains enabled.
            FD_INT_EN: u1,
            /// FIFO 0 overflow The bit is set when the FIFO 0 became overflow.
            FIFO0_OF_INT_EN: u1,
            /// FIFO 1 overflow The bit is set when the FIFO 1 became overflow.
            FIFO1_OF_INT_EN: u1,
            /// FIFO 2 overflow The bit is set when the FIFO 2 became overflow.
            FIFO2_OF_INT_EN: u1,
            /// Line counter flag The bit is set when the specific line has been written to dram
            /// every frame. The line number is set in the line counter register.
            LC_INT_EN: u1,
            /// Hblank FIFO overflow The bit is set when 3 FIFOs still overflow after the
            /// hblank.
            HB_OF_INT_EN: u1,
            /// vsync flag The bit is set when vsync come. And at this time load the buffer
            /// address for the coming frame. So after this irq come, changing the buffer
            /// address could only effect next frame
            VS_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Set a INT when clear Frame cnt.
            CLR_FRAME_CNT_INT_EN: u1,
            /// Set an INT when no video input exceeds the setting threshold time
            VIDEO_INPUT_TO_INT_EN: u1,
            /// Set an INT when content in BUF Address FIFO less than
            /// CSIC_DMA_BUFA_FIFO_THRESHOLD, only use in BUF Address FIFO MODE.
            BUF_ADDR_FIFO_INT_EN: u1,
            /// Set an INT when the value of CSIC_DMA_STORED_FRM_CNT reaches
            /// CSIC_DMA_STORED_FRM_THRESHOLD, only use in BUF Address FIFO MODE.
            STORED_FRM_CNT_INT_EN: u1,
            /// Set an INT when frame starts with empty Buffer Address FIFO, only use in BUF
            /// Address FIFO MODE.
            FRM_LOST_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x5809254
        /// CSIC DMA Interrupt Status Register
        pub const CSIC_DMA_INT_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture done
            CD_PD: u1,
            /// Frame done
            FD_PD: u1,
            /// FIFO 0 overflow
            FIFO0_OF_PD: u1,
            /// FIFO 1 overflow
            FIFO1_OF_PD: u1,
            /// FIFO 2 overflow
            FIFO2_OF_PD: u1,
            /// Line counter flag
            LC_PD: u1,
            /// Line information FIFO (16 lines) overflow
            LI_OF_PD: u1,
            /// vsync flag
            VS_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Set a INT when clear Frame cnt.
            CLR_FRAME_CNT_INT: u1,
            /// Set an INT Pending when no video input exceeds the setting threshold time.
            VIDEO_INPUT_TO_INT_PD: u1,
            /// Set an INT when content in BUF Address FIFO less than
            /// CSIC_DMA_BUFA_FIFO_THRESHOLD, only use in BUF Address FIFO MODE.
            BUF_ADDR_FIFO_INT_PD: u1,
            /// Set an INT when the value of CSIC_DMA_STORED_FRM_CNT reaches
            /// CSIC_DMA_STORED_FRM_THRESHOLD, only use in BUF Address FIFO MODE.
            STORED_FRM_CNT_INT_PD: u1,
            /// Set an INT when frame starts with empty Buffer Address FIFO, only use in BUF
            /// Address FIFO MODE.
            FRM_LOST_INT_PD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x5809258
        /// CSIC DMA LINE Counter Register
        pub const CSIC_DMA_LINE_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The LINE_CNT_NUM value is set by user,when internal line counter reach the set
            /// value, the LC_PD will be set.
            LINE_CNT_NUM: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x58);

        /// address: 0x5809270
        /// CSIC DMA PCLK Statistic Register
        pub const CSIC_DMA_PCLK_STAT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates minimum pixel clock counter value for each line. Update at every vsync
            /// or framedone.
            PCLK_CNT_LINE_MIN: u15,
            reserved0: u1,
            /// Indicates maximum pixel clock counter value for each line. Update at every vsync
            /// or framedone.
            PCLK_CNT_LINE_MAX: u15,
            padding0: u1,
        }), base_address + 0x70);

        /// address: 0x5809294
        /// CSIC DMA Stored Frame Counter Register
        pub const CSIC_DMA_STORED_FRM_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates value of stored frames counter. When the counter value reaches
            /// CSIC_DMA_STORED_FRM_THRESHOLD, the counter is cleared to 0. Only used in Buffer
            /// Addr FIFO Mode.
            CSIC_DMA_STORED_FRM_CNT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x94);

        /// address: 0x5809248
        /// CSIC DMA Video Input Timeout Counter Value Register
        pub const CSIC_DMA_VI_TO_CNT_VAL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Input Timeout Counter Value Indicate the current value of Video Input
            /// Timeout Counter
            VIDEO: u32,
        }), base_address + 0x48);

        /// address: 0x5809240
        /// CSIC DMA Video Input Timeout Threshold0 Register
        pub const CSIC_DMA_VI_TO_TH0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Input Timeout Threshold0 Set VIDEO_INPUT_TO_INT_PD when VI Counter reaches
            /// TH0 after VI_TO_CNT_EN is set, the Time Unit is a 12M clock period.
            VIDEO: u32,
        }), base_address + 0x40);

        /// address: 0x5809244
        /// CSIC DMA Video Input Timeout Threshold1 Register
        pub const CSIC_DMA_VI_TO_TH1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Input Timeout Threshold1 Set VIDEO_INPUT_TO_INT_PD when VI Counter reaches
            /// TH1 after getting the first frame has been input, the Time Unit is a 12M clock
            /// period.
            VIDEO: u32,
        }), base_address + 0x44);

        /// address: 0x5809214
        /// CSIC DMA Vertical Size Register
        pub const CSIC_DMA_VSIZE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical line start Data is valid from this line.
            VER_START: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// When BK_TOP_EN is enabled, DMA_EN is enabled, these bits indicate Valid line
            /// number of a frame in DMA mode.
            VER_LEN: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x14);

        /// address: 0x58093f4
        /// CSIC DMA Feature List Register
        pub const CSIC_FEATURE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: No Embedded DMA
            /// 1: Embedded FBC
            DMA0_EMBEDDED_FBC: u1,
            /// 0: No Embedded LBC
            /// 1: Embedded LBC
            DMA0_EMBEDDED_LBC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1f4);
    };

    /// CE_NS
    pub const CE_NS = struct {
        pub const base_address = 0x3040000;

        /// address: 0x3040028
        /// DMA Current Destination Address
        pub const CE_CDA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current destination address
            CUR_DST_ADDR: u32,
        }), base_address + 0x28);

        /// address: 0x3040024
        /// DMA Current Source Address
        pub const CE_CSA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current source address
            CUR_SRC_ADDR: u32,
        }), base_address + 0x24);

        /// address: 0x3040018
        /// Error Status Register
        pub const CE_ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Task Channel0 Error Type
            /// xxx1: Algorithm not support
            /// xx1x: Data length error
            /// x1xx: keysram access error for AES
            /// 1xxx: Reserved
            TASK_CHANNEL0: u4,
            /// Task Channel1 Error Type
            /// xxx1: Algorithm not support
            /// xx1x: Data length error
            /// x1xx: keysram access error for AES
            /// 1xxx: Reserved
            TASK_CHANNEL1: u4,
            /// Task Channel2 Error Type
            /// xxx1: Algorithm not support
            /// xx1x: Data length error
            /// x1xx: keysram access error for AES
            /// 1xxx: Reserved
            TASK_CHANNEL2: u4,
            /// Task Channel3 Error Type
            /// xxx1: Algorithm not support
            /// xx1x: Data length error
            /// x1xx: keysram access error for AES
            /// 1xxx: Reserved
            TASK_CHANNEL3: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x3040008
        /// Interrupt Control Register
        pub const CE_ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Task Channel3–0 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TASK: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x8);

        /// address: 0x304000c
        /// Interrupt Status Register
        pub const CE_ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Task Channel3–0 End Pending
            /// 0: Not finished
            /// 1: Finished It indicates whether task is completed. Write the corresponding
            /// channel bit of the register to clear the end flag. When the last task in the
            /// task chain ends, the operation of the task chain will end normally. If the task
            /// fails in the middle, the task chain will be aborted. The CE_ISR register will be
            /// automatically updated when it ends normally or aborts abnormally. And it is
            /// determined whether to generate an interrupt signal according to the IE
            /// configuration (bit31) of Common Control when the current task ends or aborts. If
            /// using interrupt, after receiving the interrupt, read the corresponding channel
            /// bit of CE_ISR to judge whether it ends successfully or stops failure. If not
            /// using interrupt, the CE_ISR status register can be continuously queried for the
            /// channel bit until the successful end flag is set or the failure stop flag is
            /// set. Write the corresponding channel bit of the register to clear the end flag.
            /// If it fails to stop, you can read the error code on the channel corresponding to
            /// the register.
            TASK: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xc);

        /// address: 0x3040000
        /// Task Descriptor Address
        pub const CE_TDA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Task Descriptor Address Configure as the first address of the descriptor
            /// structure.
            TASK: u32,
        }), base_address + 0x0);

        /// address: 0x3040010
        /// Task Load Register
        pub const CE_TLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Task Load When set, the CE can load the descriptor of task if the task FIFO is
            /// not full.
            TASK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x304002c
        /// Throughput Register
        pub const CE_TPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// It indicates the throughput writing to this register at last time. Writing to
            /// this register will clear it to 0.
            TP_NUM: u32,
        }), base_address + 0x2c);

        /// address: 0x3040014
        /// Task Status Register
        pub const CE_TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Running Channel Number
            /// 00: Task channel0
            /// 01: Task channel1
            /// 10: Task channel2
            /// 11: Task channel3
            RUNNING_CHANNEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);
    };

    /// CIR_RX
    pub const CIR_RX = struct {
        pub const base_address = 0x7040000;

        /// address: 0x7040000
        /// CIR Control Register
        pub const CIR_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Global Enable A disable on this bit overrides any other block or channel enables
            /// and flushes all FIFOs.
            /// 0: Disable
            /// 1: Enable
            GEN: u1,
            /// Receiver Block Enable
            /// 0: Disable
            /// 1: Enable
            RXEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// ENABLE 00~10: Reserved
            /// 11: CIR mode enable
            CIR: u2,
            /// Active Pulse Accept Mode 00, 01: Both positive and negative pulses are valid as
            /// a leading code
            /// 10: Only negative pulse is valid as a leading code
            /// 11: Only positive pulse is valid as a leading code
            APAM: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x7040034
        /// CIR Receiver Configure Register
        pub const CIR_RXCFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Clock Select for CIR SCS2 SCS[1] SCS[0] Sample Clock 0 0 0 CIR_CLK/64 0 0
            /// 1 CIR_CLK/128 0 1 0 CIR_CLK/256 0 1 1 CIR_CLK/512 1 0 0 CIR_CLK 1 0 1 Reserved 1
            /// 1 0 Reserved 1 1 1 Reserved
            SCS: u2,
            /// Noise Threshold for CIR When the duration of the signal pulse (high or low
            /// level) is less than NTHR, the pulse is taken as noise and should be discarded by
            /// hardware.
            /// 0: All samples are recorded into RX FIFO
            /// 1: If the signal is only one sample duration, it is taken as noise and
            /// discarded.
            /// 2: If the signal is less than (<=) two sample duration, it is taken as noise and
            /// discarded. …
            /// 61: If the signal is less than (<=) sixty-one sample duration, it is taken as
            /// noise and discarded.
            NTHR: u6,
            /// Idle Threshold for CIR The Receiver uses it to decide whether the CIR command is
            /// received. If there is no CIR signal on the air, the receiver is staying in IDLE
            /// status. One active pulse will bring the receiver from IDLE status to Receiving
            /// status. After the CIR receiver ends, the inputting signal will keep the
            /// specified level (high or low level) for a long time. The receiver can use this
            /// idle signal duration to decide that it has received the CIR command. The
            /// corresponding flag is asserted. If the corresponding interrupt is enabled, the
            /// interrupt line is asserted to the CPU. When the duration of the signal keeps one
            /// status (high or low level) for the specified duration ((ITHR + 1)*128
            /// sample_clk), this means that the previous CIR command is finished.
            ITHR: u8,
            /// Active Threshold for CIR These bits control the duration of CIR from the idle to
            /// the active state. The duration can be calculated by ((ATHR + 1)*(ATHC? Sample
            /// Clock: 128*Sample Clock)).
            ATHR: u7,
            /// Active Threshold Control for CIR
            /// 0: ATHR in a unit of (Sample Clock)
            /// 1: ATHR in a unit of (128*Sample Clocks)
            ATHC: u1,
            /// Bit2 of Sample Clock Select for CIR This bit is defined by SCS bits below.
            SCS2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x34);

        /// address: 0x7040020
        /// CIR Receiver FIFO Register
        pub const CIR_RXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Byte FIFO
            RBF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x704002c
        /// CIR Receiver Interrupt Control Register
        pub const CIR_RXINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver FIFO Overrun Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            ROI_EN: u1,
            /// Receiver Packet End Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RPEI_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// RX FIFO Available Interrupt Enable
            /// 0: Disable
            /// 1: Enable When it is set to ‘1’, the Receiver FIFO IRQ is asserted if
            /// reaching RAL. The IRQ is de-asserted when the condition fails.
            RAI_EN: u1,
            /// RX FIFO DMA Enable
            /// 0: Disable
            /// 1: Enable When it is set to ‘1’, the Receiver FIFO DRQ is asserted if
            /// reaching RAL. The DRQ is de-asserted when the condition fails.
            DRQ_EN: u1,
            reserved2: u1,
            reserved3: u1,
            /// RX FIFO available received byte level for interrupt and DMA request
            /// TRIGGER_LEVEL = RAL + 1
            RAL: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x2c);

        /// address: 0x7040010
        /// CIR Receiver Pulse Configure Register
        pub const CIR_RXPCFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Receiver Pulse Polarity Invert
            /// 0: Do not invert receiver signal
            /// 1: Invert receiver signal
            RPPI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x10);

        /// address: 0x7040030
        /// CIR Receiver Status Register
        pub const CIR_RXSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver FIFO Overrun
            /// 0: Receiver FIFO not overrun
            /// 1: Receiver FIFO overrun Writing 1 clears this bit.
            ROI: u1,
            /// Receiver Packet End Flag
            /// 0: STO was not detected. In CIR mode, one CIR symbol is receiving or not
            /// detected.
            /// 1: STO field or packet abort symbol (7’b0000,000 and 8’b0000,0000 for MIR
            /// and FIR) is detected. In CIR mode, one CIR symbol is received. Writing 1 clears
            /// this bit.
            RPE: u1,
            reserved0: u1,
            reserved1: u1,
            /// RX FIFO Available
            /// 0: RX FIFO not available according to its level
            /// 1: RX FIFO available according to its level Writing 1 clears this bit.
            RA: u1,
            reserved2: u1,
            reserved3: u1,
            /// Status of CIR
            /// 0: Idle
            /// 1: Busy
            STAT: u1,
            /// RX FIFO Available Counter
            /// 0: No available data in RX FIFO
            /// 1: 1-byte available data in RX FIFO
            /// 2: 2-bytes available data in RX FIFO …
            /// 64: 64-bytes available data in RX FIFO
            RAC: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);
    };

    /// CIR_TX
    pub const CIR_TX = struct {
        pub const base_address = 0x2003000;

        /// address: 0x2003034
        /// CIR_DMA_CTL
        pub const CIR_DMA_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake Configuration
            /// 0xA5: DMA waiting cycle mode
            /// 0xEA: DMA handshake mode
            DMA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x34);

        /// address: 0x200300c
        /// CIR Transmit Idle Duration Threshold High Bit Register
        pub const CIR_IDC_H = @intToPtr(*volatile Mmio(32, packed struct {
            /// Idle Duration Counter Threshold (High 4 bits) Idle Duration = 128*IDC*Ts (IDC =
            /// 0–4095) It is used in cyclical transmission mode. When all the data in FIFO is
            /// transmitted, the signals can be transmitted after a specific time.
            IDC_H: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xc);

        /// address: 0x2003010
        /// CIR Transmit Idle Duration Threshold Low Bit Register
        pub const CIR_IDC_L = @intToPtr(*volatile Mmio(32, packed struct {
            /// Idle Duration Counter Threshold (Low 8 bits) Idle Duration = 128*IDC*Ts (IDC =
            /// 0–4095) It is used in cyclical transmission mode. When all the data in FIFO is
            /// transmitted, the signals can be transmitted after a specific time.
            IDC_L: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x10);

        /// address: 0x2003028
        /// CIR Transmit FIFO Available Counter Register
        pub const CIR_TAC = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Available Space Counter
            /// 0x00: No available space in TX FIFO
            /// 0x01: 1 byte available space in TX FIFO
            /// 0x02: 2 bytes available space in TX FIFO …
            /// 0x80: 128 bytes available space in TX FIFO
            TAC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);

        /// address: 0x2003008
        /// CIR Transmit Control Register
        pub const CIR_TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Type of the transmission signal
            /// 0: The transmitting wave is a single non-cyclical pulse.
            /// 1: The transmitting wave is a cyclical short-pulse.
            TTS: u1,
            /// Reference Clock Select for CIR Transmit The data in TX_FIFO is used to describe
            /// the pulse in Run-Length Code. The basic unit of pulse width is Reference Clock.
            /// 000: CIR Transmit reference clock is ir_clk
            /// 001: CIR Transmit reference clock is ir_clk/2
            /// 010: CIR Transmit reference clock is ir_clk/4
            /// 011: CIR Transmit reference clock is ir_clk/8
            /// 100: CIR Transmit reference clock is ir_clk/64
            /// 101: CIR Transmit reference clock is ir_clk/128
            /// 110: CIR Transmit reference clock is ir_clk/256
            /// 111: CIR Transmit reference clock is ir_clk/512
            RCS: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Cyclical Pulse Start/Stop Control
            /// 0: Stop when cleared to '0'. From start to stop, all data in FIFO must be
            /// transmitted.
            /// 1: Start. Start to transmit when it is set to '1'.
            CSS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x2003020
        /// CIR TX FIFO Empty Level Register
        pub const CIR_TEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO empty Level for DRQ and IRQ. TRIGGER_LEVEL = TEL + 1
            TEL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x2003000
        /// CIR Transmit Global Register
        pub const CIR_TGLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Block Enable
            /// 0: Disable the CIR Transmitter
            /// 1: Enable the CIR Transmitter
            TXEN: u1,
            /// Transmit Reset When this bit is set, the transmitting is reset. The FIFO will be
            /// flushed, the TIC filed and the CSS field will be cleared during Transmit Reset.
            /// This field will automatically be cleared when the Transmit Reset is finished,
            /// and the CIR transmitter will state Idle.
            TR: u1,
            /// Transmit Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            TPPI: u1,
            reserved0: u1,
            reserved1: u1,
            /// Duty ratio of modulated carrier is high level/low level.
            /// 00: Low level is equal to high level
            /// 01: Low level is the double of high level
            /// 10: Low level is the triple of high level
            /// 11: Reserved
            DRMC: u2,
            /// Internal Modulation Select
            /// 0: The transmitting signal is not modulated
            /// 1: The transmitting signal is modulated internally
            IMS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2003014
        /// CIR Transmit Idle Counter High Bit Register
        pub const CIR_TICR_H = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Idle Counter_H (High 8 bits) It is used to count the idle duration of
            /// CIR transmitter by software. Count in 128*Ts (Sample Duration, 1/Fs) when the
            /// transmitter is idle, and it should be reset when the transmitter is active. When
            /// this counter reaches the maximum value (0xFFFF), it will stop automatically, and
            /// should not be cleared to zero.
            TIC_H: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2003018
        /// CIR Transmit Idle Counter Low Bit Register
        pub const CIR_TICR_L = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Idle Counter_L (Low 8 bits) It is used to count the idle duration of
            /// CIR transmitter by software. Count in 128*Ts (Sample Duration, 1/Fs) when the
            /// transmitter is idle, and it should be reset when the transmitter is active. When
            /// this counter reaches the maximum value (0xFFFF), it will stop automatically, and
            /// should not be cleared to zero.
            TIC_L: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2003004
        /// CIR Transmit Modulation Control Register
        pub const CIR_TMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reference Frequency of modulated carrier. Reference Frequency of modulated
            /// carrier based on a division of a fixed functional clock (FCLK). The range of the
            /// modulated carrier is usually 30 kHz to 60 kHz. Most consumer electronics is 38
            /// kHz. The default modulated carrier is 38 kHz when FCLK is 12 MHz. RFMC=
            /// FCLK/((N+1)*(DRMC+2)).
            RFMC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2003080
        /// CIR Transmit FIFO Data Register
        pub const CIR_TXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Byte FIFO When the transmission is triggered, the data in the FIFO will
            /// be transmitted until the data number is transmitted completely. 10 Security
            /// System
            /// .....................................................................................................................................................
            /// 1344 10.1 Crypto Engine
            /// ................................................................................................................................................
            /// 1344 10.1.1 Overview
            /// ...........................................................................................................................................
            /// 1344 10.1.2 Block Diagram
            /// ...................................................................................................................................
            /// 1345 10.1.3 Functional Description
            /// ......................................................................................................................
            /// 1345 10.1.4 Programming Guidelines
            /// ...................................................................................................................
            /// 1365 10.1.5 Register List
            /// .......................................................................................................................................
            /// 1368 10.1.6 Register Description
            /// ..........................................................................................................................
            /// 1369 10.2 Security ID
            /// .....................................................................................................................................................
            /// 1373 Figure 10-1 CE Block Diagram
            /// .........................................................................................................................................
            /// 1345 Figure 10-2 DES Encryption and Decryption
            /// ...................................................................................................................
            /// 1346 Figure 10-3 3DES Encryption and Decryption of a 3-key Operation and a 2-key
            /// Operation .......................................... 1347 Figure 10-4 ECB Mode
            /// Encryption and
            /// Decryption.........................................................................................................
            /// 1348 Figure 10-5 CBC Mode Encryption and Decryption
            /// ........................................................................................................
            /// 1349 Figure 10-6 CTR Mode Encryption and
            /// Decryption.........................................................................................................
            /// 1350 Figure 10-7 CFB Mode Encryption and Decryption
            /// .........................................................................................................
            /// 1351 Figure 10-8 OFB Mode Encryption and Decryption
            /// ........................................................................................................
            /// 1352 Figure 10-9 CTS Mode Encryption and Decryption
            /// .........................................................................................................
            /// 1353 Figure 10-10 Structure of Task Descriptor Chaining
            /// .......................................................................................................
            /// 1354 Figure 10-11 Word Address of Message
            /// .........................................................................................................................
            /// 1361 Figure 10-12 Byte Order
            /// ..................................................................................................................................................
            /// 1361 Figure 10-13 Bit Order
            /// ....................................................................................................................................................
            /// 1361 Figure 10-14 The Storage Method of 32-bit IV
            /// ...............................................................................................................
            /// 1362 Figure 10-15 The Storage Method of 64-bit IV
            /// ...............................................................................................................
            /// 1362 Figure 10-16 Task Request Process
            /// .................................................................................................................................
            /// 1365
            TBF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x80);

        /// address: 0x2003024
        /// CIR Transmit Interrupt Control Register
        pub const CIR_TXINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Packet End Interrupt Enable for Cyclical Pulse
            /// 0: Disable
            /// 1: Enable TUI_EN Transmitter FIFO Underrun Interrupt Enable for Non-cyclical
            /// Pulse
            /// 0: Disable
            /// 1: Enable
            TPEI_EN: u1,
            /// TX FIFO Available Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TAI_EN: u1,
            /// TX FIFO DMA Enable
            /// 0: Disable
            /// 1: Enable When it is set to ‘1’, the TX FIFO DRQ is asserted if the number
            /// of the transmitting data in the FIFO is less than the RAL. The DRQ is
            /// de-asserted when the condition fails.
            DRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x24);

        /// address: 0x200302c
        /// CIR Transmit Status Register
        pub const CIR_TXSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmitter Packet End Flag for Cyclical Pulse
            /// 0: Transmissions of address, control and data fields not completed
            /// 1: Transmissions of address, control and data fields completed TUR Transmitter
            /// FIFO Underrun Flag for Non-cyclical Pulse
            /// 0: No transmitter FIFO underrun
            /// 1: Transmitter FIFO underrun Writing 1 clears this bit.
            TPE: u1,
            /// TX FIFO Available Interrupt Flag
            /// 0: TX FIFO not available by its level
            /// 1: TX FIFO available by its level Writing 1 clears this bit.
            TAI: u1,
            /// DMA Request Flag When set to ‘1’, the TX FIFO DRQ is asserted if the number
            /// of the transmission data in the FIFO is less than the RAL. The DRQ is de-
            /// asserted when the condition fails. This bit is for debugging.
            DRQ: u1,
            /// Status of CIR Transmitter
            /// 0: Idle
            /// 1: Active This bit will automatically set when the controller begins to transmit
            /// the data in the FIFO. The “1” will last when the data in the FIFO. It will
            /// automatically be cleared to “0” when all data in the FIFO is transmitted.
            /// The bit is for debugging. The output Level of Idle state is determined by the
            /// level of the last data output.
            STCT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x2c);

        /// address: 0x2003030
        /// CIR Transmit Threshold Register
        pub const CIR_TXT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Non-cyclical Pulse Transmit Threshold The controller will trigger transmitting
            /// the data in the FIFO when the data byte number has reached the Transmit
            /// Threshold set in this field.
            NCTT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);
    };

    /// DMIC
    pub const DMIC = struct {
        pub const base_address = 0x2031000;

        /// address: 0x2031030
        /// Data0 and Data1 Volume Control Register
        pub const DATA0_DATA1_VOL_CTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data0 Right Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA0R_VOL: u8,
            /// Data0 Left Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA0L_VOL: u8,
            /// Data1 Right Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA1R_VOL: u8,
            /// Data1 Left Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA1L_VOL: u8,
        }), base_address + 0x30);

        /// address: 0x2031034
        /// Data2 And Data3 Volume Control Register
        pub const DATA2_DATA3_VOL_CTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data2 Right Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA2R_VOL: u8,
            /// Data2 Light Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA2L_VOL: u8,
            /// Data3 Right Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA3R_VOL: u8,
            /// Data3 Light Channel Volume Control (-119.25 dB to 71.25 dB, 0.75 dB/Step)
            /// 0x00: Mute
            /// 0x01: -119.25 dB ...
            /// 0x9F: -0.75 dB
            /// 0xA0: 0 dB
            /// 0xA1: 0.75 dB ...
            /// 0xFF: 71.25 dB
            DATA3L_VOL: u8,
        }), base_address + 0x34);

        /// address: 0x2031028
        /// DMIC Channel Mapping Register
        pub const DMIC_CH_MAP = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMIC Channel0 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH0_MAP: u4,
            /// DMIC Channel 1 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH1_MAP: u4,
            /// DMIC Channel 2 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH2_MAP: u4,
            /// DMIC Channel 3 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH3_MAP: u4,
            /// DMIC Channel 4 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH4_MAP: u4,
            /// DMIC Channel 5 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH5_MAP: u4,
            /// DMIC Channel 6 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH6_MAP: u4,
            /// DMIC Channel 7 Mapping
            /// 0000: DATA0 Left Channel
            /// 0001: DATA0 Right Channel
            /// 0010: DATA1 Left Channel
            /// 0011: DATA1 Right Channel
            /// 0100: DATA2 Left Channel
            /// 0101: DATA2 Right Channel
            /// 0110: DATA3 Left Channel
            /// 0111: DATA3 Right Channel
            DMIC_CH7_MAP: u4,
        }), base_address + 0x28);

        /// address: 0x2031024
        /// DMIC Channel Numbers Register
        pub const DMIC_CH_NUM = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x24);

        /// address: 0x203102c
        /// DMIC Counter Register
        pub const DMIC_CNT = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x2031008
        /// DMIC Control Register
        pub const DMIC_CTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Oversample Rate
            /// 0: 128 (Supports 8 kHz to 24 kHz)
            /// 1: 64 (Supports 16 kHz to 48 kHz)
            DMIC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Left Data and Right Data Swap Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA0: u1,
            /// Left Data and Right Data Swap Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA1: u1,
            /// Left Data and Right Data Swap Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA2: u1,
            /// Left Data and Right Data Swap Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA3: u1,
            /// DMIC RXFIFO Delay Function for Writing Data after GLOBE_EN
            /// 0: Disabled
            /// 1: Enabled
            DMICDFEN: u1,
            /// DMIC RXFIFO Delay Time for Writing Data after GLOBE_EN
            /// 00: 5 ms
            /// 01: 10 ms
            /// 10: 20 ms
            /// 11: 30 ms
            DMICFDT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x8);

        /// address: 0x2031010
        /// DMIC Data Register
        pub const DMIC_DATA = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x2031000
        /// DMIC Enable Control Register
        pub const DMIC_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA0_CHL_EN: u1,
            /// DATA0 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA0_CHR_EN: u1,
            /// DATA1 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA1_CHL_EN: u1,
            /// DATA1 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA1_CHR_EN: u1,
            /// DATA2 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA2_CHL_EN: u1,
            /// DATA2 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA2_CHR_EN: u1,
            /// DATA3 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA3_CHL_EN: u1,
            /// DATA3 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA3_CHR_EN: u1,
            /// DMIC Globe Enable
            /// 0: Disabled
            /// 1: Enabled
            GLOBE_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// DMIC RX Synchronize Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN: u1,
            /// Audio Subsys RX Synchronize Enable Start Includes Audio
            /// codec/I2S0/I2S1/I2S2/DMIC/OWA RX. The bit takes effect only when RX_SYNC_EN is
            /// set to 1.
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN_START: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x2031014
        /// DMIC Interrupt Control Register
        pub const DMIC_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMIC RXFIFO Data Available IRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            DATA_IRQ_EN: u1,
            /// DMIC RXFIFO Overrun IRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            RXFIFO_OVERRUN_IRQ_EN: u1,
            /// DMIC RXFIFO Data Available DRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            RXFIFO_DRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x14);

        /// address: 0x2031018
        /// DMIC Interrupt Status Register
        pub const DMIC_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMIC RXFIFO Data Available Pending Interrupt
            /// 0: No pending IRQ
            /// 1: Data available pending IRQ Writing ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            RXFIFO_DATA_IRQ_PENDING: u1,
            /// DMIC RXFIFO Overrun Pending Interrupt
            /// 0: No pending IRQ
            /// 1: RXFIFO overrun pending IRQ Writing ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            RXFIFO_OVERRUN_IRQ_PENDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x18);

        /// address: 0x203101c
        /// DMIC RXFIFO Control Register
        pub const DMIC_RXFIFO_CTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Trigger Level (TRLV[7:0]) Interrupt and DMA request trigger level for
            /// DMIC RXFIFO normal condition IRQ/DRQ Generated when WLEVEL > TRLV[7:0]) WLEVEL
            /// represents the number of valid samples in the DMIC RXFIFO
            RXFIFO_TRG_LEVEL: u8,
            /// 0: 16-bit
            /// 1: 24- bit
            SAMPLE_RESOLUTION: u1,
            /// RXFIFO Output Mode (Mode 0, 1)
            /// 0: Expanding ‘0’ at LSB of RXFIFO register
            /// 1: Expanding received sample sign bit at MSB of RXFIFO register For 24-bit
            /// received audio sample: Mode 0: RXDATA[31:0] = {RXFIFO_O[20:0], 11’h0} Mode 1:
            /// RXDATA[31:0] = {8{RXFIFO_O[20]}, RXFIFO_O[20:0], 3’h0} For 16-bit received
            /// audio sample: Mode 0: RXDATA[31:0] = {RXFIFO_O[20:5], 16’h0} Mode 1:
            /// RXDATA[31:0] = {16{RXFIFO_O[20]}, RXFIFO_O[20:5]}
            RXFIFO_MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// DMIC RXFIFO Flush Writing ‘1’ to flush RXFIFO, self clear to ‘0’
            DMIC_RXFIFO_FLUSH: u1,
        }), base_address + 0x1c);

        /// address: 0x2031020
        /// DMIC RXFIFO Status Register
        pub const DMIC_RXFIFO_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMIC RXFIFO Available Sample Word Counter
            DMIC_DATA_CNT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x2031004
        /// DMIC Sample Rate Register
        pub const DMIC_SR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x203103c
        /// High Pass Filter Coefficient Register
        pub const HPF_COEF_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// High Pass Filter Coefficient
            HPF_COE: u32,
        }), base_address + 0x3c);

        /// address: 0x2031038
        /// High Pass Filter Enable Control Register
        pub const HPF_EN_CTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// High Pass Filter DATA0 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA0_CHL_EN: u1,
            /// High Pass Filter DATA0 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA0_CHR_EN: u1,
            /// High Pass Filter DATA1 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA1_CHL_EN: u1,
            /// High Pass Filter DATA1 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA1_CHR_EN: u1,
            /// High Pass Filter DATA2 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA2_CHL_EN: u1,
            /// High Pass Filter DATA2 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA2_CHR_EN: u1,
            /// High Pass Filter DATA3 Left Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA3_CHL_EN: u1,
            /// High Pass Filter DATA3 Right Channel Enable
            /// 0: Disabled
            /// 1: Enabled
            HPF_DATA3_CHR_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x38);

        /// address: 0x2031040
        /// High Pass Filter Gain Register
        pub const HPF_GAIN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// High Pass Filter Gain
            HPF_GAIN: u32,
        }), base_address + 0x40);
    };

    /// SPI_DBI
    pub const SPI_DBI = struct {
        pub const base_address = 0x4026000;

        /// address: 0x4026100
        /// DBI Control Register 0
        pub const DBI_CTL_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Video Source Type
            /// 0: RGB32
            /// 1: RGB16
            VI_SRC_TYPE: u1,
            /// Element A Position Only for RGB32 Data Format
            /// 0: A component is in the bit[31:24] of data source
            /// 1: A component is in the bit[7:0] of data source
            ELEMENT_A_POS: u1,
            /// RGB Bit Order
            /// 0: Remain the sequence of RGB data
            /// 1: Swap the higher bit and the lower bit for each component of DRAM RGB
            RGB_BO: u1,
            /// Dummy Cycle Value Output Value During Dummy Cycle
            DUM_VAL: u1,
            /// When video_source_type is RGB32 (DBI_CTL_0[bit0] = 0)
            /// 0000: RGB
            /// 0001: RBG
            /// 0010: GRB
            /// 0011: GBR
            /// 0100: BRG
            /// 0101: BGR Others: Reserved When video_source_type is RGB16 (DBI_CTL_0[bit0] = 1)
            /// 0000: RGB 0001~0100: Reserved
            /// 0101: BGR
            /// 0110: GRBG_0 {G[5:3]R[4:0]B[4:0]G[2:0]}
            /// 0111: GBRG_0 {G[5:3]B[4:0]R[4:0]G[2:0]}
            /// 1000: GRBG_1 {G[2:0]R[4:0]B[4:0]G[5:3]}
            /// 1001: GBRG_1 {G[2:0]B[4:0]R[4:0]G[5:3]} Others: Reserved
            RGB_SOURCE_FORMAT: u4,
            /// Interface
            /// 000: 3 Line Interface I
            /// 001: 3 Line Interface II
            /// 010: 4 Line Interface I
            /// 011: 4 Line Interface II
            /// 100: 2 Data Lane Interface
            DBI: u3,
            reserved0: u1,
            /// Output Data Format
            /// 000: RGB111
            /// 001: RGB444
            /// 010: RGB565
            /// 011: RGB666
            /// 100: RGB888 (only for 2 Data Lane Interface) 101~111: Reserved
            DAT_FMT: u3,
            /// Transmit Mode
            /// 0: Command/Parameter
            /// 1: Video
            TRAN_MOD: u1,
            /// Output RGB Sequence
            /// 000: RGB
            /// 001: RBG
            /// 010: GRB
            /// 011: GBR
            /// 100: BRG
            /// 101: BGR 110, 111: Reserved
            RGB_SEQ: u3,
            /// Output Data Sequence
            /// 0: MSB First
            /// 1: LSB First
            DAT_SEQ: u1,
            /// Write Command Dummy Cycles Controls dummy cycles between two write commands
            /// Range 1~255 Default Condition: there is a dbi_clk cycle between each command or
            /// parameter.
            WCDC: u11,
            /// Command Type
            /// 0: Write Command
            /// 1: Read Command
            CMDT: u1,
        }), base_address + 0x100);

        /// address: 0x4026104
        /// DBI Control Register 1
        pub const DBI_CTL_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read Data Number of Bytes Sample Bytes data based on configuration.
            RDBN: u8,
            /// Read Command Dummy Cycles The dummy cycle between the read command and read data
            /// Reading 1-byte (8 bits) data has not dummy cycle.
            RCDC: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Bit Order of Read Data
            /// 0: A reading data is the higher bit
            /// 1: A reading data is the lower bit
            RDAT_LSB: u1,
            /// 16 Data Source Select RGB 16 Data Source Select
            /// 0: Pixel1 is stored in the higher bit of address, and Pixel0 is stored in the
            /// lower bit of address
            /// 1: Pixel0 is stored in the higher bit of address, and Pixel1 is stored in the
            /// lower bit of address
            RGB: u1,
            /// DCX Data Value
            /// 0: DCX Value equal to 0
            /// 1: DCX Value equal to 1
            DCX_DATA: u1,
            /// DBI clock output inverse
            /// 0: The falling edge releases the CSX signal, and the falling edge releases data
            /// 1: The rising edge releases the CSX signal, and the rising edge releases data
            /// 0: The rising edge releases the CSX signal, and the falling edge releases data
            /// 1: The falling edge releases the CSX signal, and the rising edge releases data
            DBI_CLKO_INV: u1,
            /// DBI output clock mode
            /// 0: DBI clock always on (DCX Setup/hold equals one clock cycle)
            /// 1: DBI clock auto gating (DCX Setup/hold equals to a half clock cycle)
            DBI_CLKO_MOD: u1,
            /// DBI rx clock inverse
            /// 0: Sample data by using the positive edge of the output clock
            /// 1: Sample data by using the negative edge of the output clock
            DBI_RXCLK_INV: u1,
            /// 2 Data Lane RGB666 Format
            /// 00: Normal Format
            /// 01: Special Format for ILITEK
            /// 10: Special Format for New Vision
            RGB666_FMT: u2,
            reserved4: u1,
            /// EN MODE SEL DBI Enable Mode Select
            /// 00: Always on DBI mode
            /// 01: Software trigger mode
            /// 10: Timer trigger mode
            /// 11: TE trigger mode
            DBI: u2,
            /// DBI soft trigger It is only available for software trigger mode. Writing ‘1’
            /// to this bit will start DBI TX module and auto clear to ‘0’ when completing
            /// start operation, writing ‘0’ to this bit has no effect.
            DBI_SOFT_TRG: u1,
        }), base_address + 0x104);

        /// address: 0x4026108
        /// DBI Control Register 2
        pub const DBI_CTL_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TE enable
            /// 0: TE Disable
            /// 1: TE Enable
            TE_EN: u1,
            /// TE edge trigger select
            /// 0: TE rising edge
            /// 1: TE falling edge
            TE_TRIG_SEL: u1,
            /// TE debounce function select
            /// 0: debounce
            /// 1: no-debounce
            TE_DBC_SEL: u1,
            /// DBI SDI PIN Function Select
            /// 00: DBI_SDI (Interface II)
            /// 01: DBI_TE
            /// 10: DBI_DCX
            /// 11: Reserved
            DBI_SDI_SEL: u2,
            /// DBI DCX PIN Function Select
            /// 0: DBI DCX Function
            /// 1: WRX (2 Data Lane Interface)
            DBI_DCX_SEL: u1,
            /// DBI SDI PIN Output Select The signal is used with the DBI SDI PIN Function Sel
            /// bit.
            /// 0: Output WRX (When DBI DCX PIN Function Sel = 0, the SDI pin outputs data)
            /// 1: Output DCX
            DBI_SDI_OUT_SEL: u1,
            reserved0: u1,
            /// DBI FIFO Empty Request Trigger Level
            DBI_TRIG_LEVEL: u7,
            /// DBI FIFO DMA Request Enable
            /// 0: Disable
            /// 1: Enable
            DBI_FIFO_DRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x108);

        /// address: 0x4026124
        /// DBI_Debug_0
        pub const DBI_Debug_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FSM for DBI Memory
            /// 00: IDLE_FRM
            /// 01: FRM_POS
            /// 10: FRM_RDY
            MEM_CS: u2,
            reserved0: u1,
            reserved1: u1,
            /// FSM for shifter 0~11 : SH0~SH11
            SH_CS: u4,
            /// FSM for DBI Receive RX_BS0 ~ RX_BS6 , Gray - Code
            DBI_RXCS: u4,
            /// TE input value
            /// 0: TE not Trigger
            /// 1: TE Trigger
            TE_VAL: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DBI_FIFO ROOM VALID 0~127 Words
            DBI_FIFO_AVAIL: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x124);

        /// address: 0x4026128
        /// DBI_Debug_1
        pub const DBI_Debug_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Component counter The number of RGB components that are currently sent The field
            /// is equal to pixel_cnt *3.
            CCNT: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Line counter The number of pixel lines that are currently sent
            LCNT: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x128);

        /// address: 0x4026120
        /// DBI Interrupt Register
        pub const DBI_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Line Done Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            LINE_DONE_INT_EN: u1,
            /// Frame Done Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            FRAM_DONE_INT_EN: u1,
            /// TE Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TE_INT_EN: u1,
            /// Read Done Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RD_DONE_INT_EN: u1,
            /// Timer Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TIMER_INT_EN: u1,
            /// DBI FIFO Full Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            DBI_FIFO_FULL_INT_EN: u1,
            /// DBI FIFO Empty Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            DBI_FIFO_EMPTY_INT_EN: u1,
            reserved0: u1,
            /// It indicates that a line of video data has been sent. Writing 1 to this bit
            /// clears it.
            /// 0: A line of video data has not been sent
            /// 1: A line of video data has been sent
            LINE_DONE_INT: u1,
            /// It indicates that a frame video data has been sent. Writing 1 to this bit clears
            /// it.
            /// 0: A frame video has not been sent
            /// 1: A frame video has been sent
            FRAM_DONE_INT: u1,
            /// It indicates that the TE signal has been changed. Writing 1 to this bit clears
            /// it.
            /// 0: TE signal has not been changed
            /// 1: TE signal has been changed
            TE_INT: u1,
            /// It indicates that the number of byte setting in DBI_Control Register 1[19:8] has
            /// been read. Writing 1 to this bit clears it.
            /// 0: All data has not been read
            /// 1: All data has been read
            RD_DONE_INT: u1,
            /// It indicates that the timer has been count sclk cycles to the value of DBI_Timer
            /// Register[30:0]. Writing 1 to this bit clears it.
            /// 0: Timer has not been achieved the objective
            /// 1: Timer has been achieved the objective
            TIMER_INT: u1,
            /// DBI FIFO Full Interrupt Status
            /// 0: DBI_FIFO is not full
            /// 1: DBI_FIFO is full
            DBI_FIFO_FULL_INT: u1,
            /// DBI FIFO Empty Interrupt Status
            /// 0: DBI_FIFO is not empty
            /// 1: DBI_FIFO is empty
            DBI_FIFO_EMPTY_INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x120);

        /// address: 0x402610c
        /// DBI_Timer
        pub const DBI_Timer = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer Value It sets the time interval between sending data twice, which is frame
            /// blanking. It is used to set the time at which the interrupt of the DBI Timer is
            /// triggered. When the Timer_EN is 1, the timer starts to count (the clock of the
            /// counting is SCLK), and the counter reaches the target value to trigger the
            /// Timer_INT of DBI, the data will start to send in series.
            DBI: u31,
            /// DBI Timer Enable
            /// 0: Enable
            /// 1: Disable
            DBI_TM_EN: u1,
        }), base_address + 0x10c);

        /// address: 0x4026110
        /// DBI_Video_Size
        pub const DBI_Video_Size = @intToPtr(*volatile Mmio(32, packed struct {
            /// It is used to generate the Line int.
            H_SIZE: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// It is used to generate the Frame int.
            V_SIZE: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x110);

        /// address: 0x4026040
        /// SPI_BATC
        pub const SPI_BATC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Work Mode Select
            /// 00: Data frame is byte aligned in standard SPI, dual-output/dual input SPI, dual
            /// IO SPI, and quad-output/quad-input SPI
            /// 01: Reserved
            /// 10: Data frame is bit aligned in 3-wire SPI
            /// 11: Data frame is bit aligned in standard SPI
            WMS: u2,
            /// SPI Chip Select Select one of four external SPI Master/Slave Devices
            /// 00: SPI_SS0 will be asserted
            /// 01: SPI_SS1 will be asserted
            /// 10: SPI_SS2 will be asserted
            /// 11: SPI_SS3 will be asserted It is only valid when Work Mode Select==0x10/0x11,
            /// and only work in Mode0, cannot be written when TCE=1.
            SS_SEL: u2,
            reserved0: u1,
            /// SPI Chip Select Signal Polarity Control
            /// 0: Active high polarity (0 = Idle)
            /// 1: Active low polarity (1 = Idle) It is only valid when Work Mode
            /// Select==0x10/0x11, and only work in Mode0, cannot be written when TCE=1.
            SPOL: u1,
            /// SS Output Owner Select Usually, the controller sends the SS signal automatically
            /// with data together. When this bit is set to 1, the software must manually write
            /// SS_LEVEL (SPI_BATC[7]) to 1 or 0 to control the level of the SS signal.
            /// 0: SPI controller
            /// 1: Software It is only valid when Work Mode Select==0x10/0x11, and only work in
            /// Mode0, cannot be written when TCE=1.
            SS_OWNER: u1,
            /// When control SS signal manually, set this bit to ‘1’ or ‘0’ to control
            /// the level of SS signal.
            /// 0: Set SS to low
            /// 1: Set SS to high It is only valid when Work Mode Select==0x10/0x11, and only
            /// work in Mode0, cannot be written when TCE=1.
            SS_LEVEL: u1,
            /// Configure the length of serial data frame (burst) of TX
            /// 000000: 0 bit
            /// 000001: 1 bit …
            /// 100000: 32 bits Other values: reserved It is only valid when Work Mode
            /// Select==0x10/0x11, and cannot be written when TCE=1.
            TX_FEM_LEN: u6,
            reserved1: u1,
            reserved2: u1,
            /// Configure the length of serial data frame (burst) of RX
            /// 000000: 0 bit
            /// 000001: 1 bit …
            /// 100000: 32 bits Other values: reserved It is only valid when Work Mode
            /// Select==0x10/0x11, and cannot be written when TCE (SPI_BATC[31])=1.
            RX_FEM_LEN: u6,
            reserved3: u1,
            reserved4: u1,
            /// Transfer Bits Completed Interrupt Enable
            /// 0: Disable
            /// 1: Enable It is only valid when Work Mode Select==0x10/0x11.
            TBC_INT_EN: u1,
            /// Transfer Bits Completed When set, this bit indicates that the last bit of the
            /// serial data frame in SPI TX Bit Register (or SPI RX Bit Register) has been
            /// transferred completely. Writing 1 to this bit clears it.
            /// 0: Busy
            /// 1: Transfer Completed It is only valid when Work Mode Select==0x10/0x11.
            TBC: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Master Sample Standard
            /// 0: Delay Sample Mode
            /// 1: Standard Sample Mode In Standard Sample Mode, the SPI master samples the data
            /// at the standard rising edge of SCLK for each SPI mode; In Delay Sample Mode, the
            /// SPI master samples data at the edge that is half cycle delayed by the standard
            /// rising edge of SCLK defined in respective SPI mode.
            MSMS: u1,
            /// Transfer Control Enable In master mode, it is used to start to transfer the
            /// serial bits frame, it is only valid when Work Mode Select==0x10/0x11.
            /// 0: Idle
            /// 1: Initiates transfer Writing “1” to this bit will start to transfer serial
            /// bits frame (the value comes from the SPI TX Bit Register or SPI RX Bit
            /// Register), and will auto-clear after the bursts transfer completely. Writing
            /// ‘0’ to this bit has no effect.
            TCE: u1,
        }), base_address + 0x40);

        /// address: 0x4026044
        /// SPI Bit-Aligned Clock Configuration Register
        pub const SPI_BA_CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock Divide Rate (Master Mode Only) The SPI_SCLK is determined according to the
            /// following equation: SPI_CLK = Source_CLK / (2*(CDR_N + 1)). This register is
            /// only valid when Work Mode Select==0x10/0x11.
            CDR_N: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x44);

        /// address: 0x4026038
        /// SPI Master Burst Control Register
        pub const SPI_BCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master Single Mode Transmit Counter In master mode, this field specifies the
            /// burst number that should be sent in the single mode before automatically sending
            /// dummy bursts. This is the first transmit counter in all bursts.
            /// 0: 0 burst
            /// 1: 1 burst … N: N bursts Cannot be written when XCH=1
            STC: u24,
            /// Master Dummy Burst Counter In master mode, this field specifies the burst number
            /// that should be sent before receiving in dual SPI mode. The data does not care by
            /// the device.
            /// 0: 0 burst
            /// 1: 1 burst … N: N bursts Cannot be written when XCH=1
            DBC: u4,
            /// Master Dual Mode RX Enable It is only valid when Quad_Mode_EN=0.
            /// 0: RX uses the single-bit mode
            /// 1: RX uses the dual mode Cannot be written when XCH=1.
            DRM: u1,
            /// Quad_Mode_EN The Quad mode includes Quad-Input and Quad-Output.
            /// 0: Quad mode disable
            /// 1: Quad mode enable Cannot be written when XCH=1.
            QUAD_EN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x38);

        /// address: 0x4026018
        /// SPI FIFO Control Register
        pub const SPI_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Ready Request Trigger Level
            RX_TRIG_LEVEL: u8,
            /// RXFIFO DMA Request Enable
            /// 0: Disable
            /// 1: Enable
            RF_DRQ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// RX Test Mode Enable
            /// 0: Disable
            /// 1: Enable In normal mode, the RXFIFO can only be written by the SPI controller,
            /// writing ‘1’ to this bit will switch the read and write function of RXFIFO to
            /// AHB bus. This bit is used to test the RXFIFO, do not set in normal operation,
            /// and do not set RF_TEST and TF_TEST at the same time.
            RF_TEST: u1,
            /// RXFIFO Reset Writing ‘1’ to this bit will reset the control portion of the
            /// receiver FIFO, and auto clear to ‘0’ when completing the reset operation,
            /// writing ‘0’ to this bit has no effect.
            RF_RST: u1,
            /// TX FIFO Empty Request Trigger Level
            TX_TRIG_LEVEL: u8,
            /// TX FIFO DMA Request Enable
            /// 0: Disable
            /// 1: Enable
            TF_DRQ_EN: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TX Test Mode Enable
            /// 0: Disable
            /// 1: Enable In normal mode, the TXFIFO can only be read by the SPI controller,
            /// writing ‘1’ to this bit will switch the read and write function of TXFIFO to
            /// AHB bus. This bit is used to test the TXFIFO, do not set in normal operation,
            /// and do not set RF_TEST and TF_TEST at the same time.
            TF_TEST_ENB: u1,
            /// TX FIFO Reset Writing ‘1’ to this bit will reset the control portion of the
            /// TXFIFO and auto clear to ‘0’ when completing the reset operation, writing
            /// ‘0’ to this bit has no effect.
            TX_FIFO_RST: u1,
        }), base_address + 0x18);

        /// address: 0x402601c
        /// SPI FIFO Status Register
        pub const SPI_FSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Counter These bits indicate the number of words in RXFIFO
            /// 0: 0 byte in RXFIFO
            /// 1: 1 byte in RXFIFO …
            /// 64: 64 bytes in RXFIFO other: Reserved
            RF_CNT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// RXFIFO Read Buffer Counter These bits indicate the number of words in RXFIFO
            /// Read Buffer
            RB_CNT: u3,
            /// RXFIFO Read Buffer Write Enable
            RB_WR: u1,
            /// TXFIFO Counter These bits indicate the number of words in TXFIFO
            /// 0: 0 byte in TXFIFO
            /// 1: 1 byte in TXFIFO …
            /// 64: 64 bytes in TXFIFO other: Reserved
            TF_CNT: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// TXFIFO Write Buffer Counter These bits indicate the number of words in TXFIFO
            /// Write Buffer
            TB_CNT: u3,
            /// TXFIFO Write Buffer Write Enable
            TB_WR: u1,
        }), base_address + 0x1c);

        /// address: 0x4026004
        /// SPI Global Control Register
        pub const SPI_GCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI Module Enable Control
            /// 0: Disable
            /// 1: Enable After transforming from bit_mode to byte_mode, it must enable the SPI
            /// module again.
            EN: u1,
            /// SPI Function Mode Select
            /// 0: Slave mode
            /// 1: Master mode Cannot be written when XCH=1.
            MODE: u1,
            /// Sample Timing Mode Select
            /// 0: Old mode of Sample Timing
            /// 1: New mode of Sample Timing Cannot be written when XCH=1.
            MODE_SELEC: u1,
            /// DBI Working Mode Select
            /// 0: SPI MODE
            /// 1: DBI MODE
            SPI_DBI_MODE_SEL: u1,
            /// EN DBI Module Enable Control
            /// 0: Disable
            /// 1: Enable
            DBI: u1,
            reserved0: u1,
            reserved1: u1,
            /// Transmit Pause Enable In master mode, it is used to control transmit state
            /// machine to stop smart burst sending when RX FIFO is full.
            /// 0: Normal operation, ignore RXFIFO status
            /// 1: Stop transmit data when RXFIFO full Cannot be written when XCH=1.
            TP_EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// Soft reset Writing ‘1’ to this bit will clear the SPI controller, and auto
            /// clear to ‘0’ when reset operation completes. Writing ‘0’ to this bit has
            /// no effect.
            SRST: u1,
        }), base_address + 0x4);

        /// address: 0x4026010
        /// SPI Interrupt Control Register
        pub const SPI_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Ready Request Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RF_RDY_INT_EN: u1,
            /// RX FIFO Empty Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RX_EMP_INT_EN: u1,
            /// RX FIFO Full Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RF_FUL_INT_EN: u1,
            reserved0: u1,
            /// TX FIFO Empty Request Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TX_ERQ_INT_EN: u1,
            /// TX FIFO Empty Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TX_EMP_INT_EN: u1,
            /// TX FIFO Full Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TF_FUL_INT_EN: u1,
            reserved1: u1,
            /// RX FIFO Overflow Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RF_OVF_INT_EN: u1,
            /// RXFIFO Underrun Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RF_UDR_INT_EN: u1,
            /// TX FIFO Overflow Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TF_OVF_INT_EN: u1,
            /// TXFIFO Underrun Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TF_UDR_INT_EN: u1,
            /// Transfer Completed Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TC_INT_EN: u1,
            /// SSI Interrupt Enable Chip select signal (SSx) from the valid state to the
            /// invalid state
            /// 0: Disable
            /// 1: Enable
            SS_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x10);

        /// address: 0x4026014
        /// SPI Interrupt Status Register
        pub const SPI_ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Ready
            /// 0: RX_WL < RX_TRIG_LEVEL
            /// 1: RX_WL >= RX_TRIG_LEVEL This bit will be immediately set to 1 if RX_WL >=
            /// RX_TRIG_LEVEL. Writing “1” to this bit clears it. The RX_WL is the water
            /// level of RXFIFO.
            RX_RDY: u1,
            /// RXFIFO Empty This bit is set when the RXFIFO is empty. Writing 1 to this bit
            /// clears it.
            /// 0: Not empty
            /// 1: empty
            RX_EMP: u1,
            /// RXFIFO Full This bit is set when the RXFIFO is full. Writing 1 to this bit
            /// clears it.
            /// 0: Not Full
            /// 1: Full
            RX_FULL: u1,
            reserved0: u1,
            /// TXFIFO Ready
            /// 0: TX_WL > TX_TRIG_LEVEL
            /// 1: TX_WL <= TX_TRIG_LEVEL This bit will be immediately set to 1 if TX_WL <=
            /// TX_TRIG_LEVEL. Writing “1” to this bit clears it. The TX_WL is the water
            /// level of TXFIFO.
            TX_READY: u1,
            /// TXFIFO Empty This bit is set when the TXFIFO is empty. Writing 1 to this bit
            /// clears it.
            /// 0: TXFIFO contains one or more words.
            /// 1: TXFIFO is empty
            TX_EMP: u1,
            /// TXFIFO Full This bit is set when the TXFIFO is full. Writing 1 to this bit
            /// clears it.
            /// 0: TXFIFO is not Full
            /// 1: TXFIFO is Full
            TX_FULL: u1,
            reserved1: u1,
            /// RXFIFO Overflow When set, this bit indicates that RXFIFO is overflowed. Writing
            /// 1 to this bit clears it.
            /// 0: RXFIFO is not overflowed
            /// 1: RXFIFO is overflowed
            RX_OVF: u1,
            /// RXFIFO Underrun When set, this bit indicates that RXFIFO is underrun. Writing 1
            /// to this bit clears it.
            /// 0: RXFIFO is not underrun
            /// 1: RXFIFO is underrun
            RX_UDF: u1,
            /// TXFIFO Overflow This bit is set when the TXFIFO is overflowed. Writing 1 to this
            /// bit clears it.
            /// 0: TXFIFO is not overflowed
            /// 1: TXFIFO is overflowed
            TF_OVF: u1,
            /// TXFIFO Underrun This bit is set when the TXFIFO is underrun. Writing 1 to this
            /// bit clears it.
            /// 0: TXFIFO is not underrun
            /// 1: TXFIFO is underrun
            TF_UDF: u1,
            /// Transfer Completed In master mode, it indicates that all bursts specified by BC
            /// have been exchanged. In other conditions, when set, this bit indicates that all
            /// the data in TXFIFO has been loaded in the Shift register, and the Shift register
            /// has shifted out all the bits. Writing 1 to this bit clears it.
            /// 0: Busy
            /// 1: Transfer completed
            TC: u1,
            /// SS Invalid Interrupt When SSI is 1, it indicates that SS has changed from the
            /// valid state to the invalid state. Writing 1 to this bit clears it.
            SSI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x14);

        /// address: 0x4026030
        /// SPI Master Burst Counter Register
        pub const SPI_MBC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master Burst Counter In master mode, this field specifies the total burst number
            /// which includes the TXD, RXD, and dummy burst.
            /// 0: 0 burst
            /// 1: 1 burst … N: N bursts Cannot be written when XCH=1.
            MBC: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x30);

        /// address: 0x4026034
        /// SPI Master Transmit Counter Register
        pub const SPI_MTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master Write Transmit Counter In master mode, this field specifies the burst
            /// number that should be sent to TXFIFO before automatically sending dummy bursts.
            /// For saving bus bandwidth, the dummy bursts (all zero bits or all one bits) are
            /// sent by SPI Controller automatically.
            /// 0: 0 burst
            /// 1: 1 burst … N: N bursts Cannot be written when XCH=1.
            MWTC: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x4026088
        /// SPI Normal DMA Mode Control Register
        pub const SPI_NDMA_MODE_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delay Cycles The counts of hold cycles from DMA last signal high to dma_active
            /// high
            SPI_DMA_WAIT: u5,
            /// SPI NDMA Acknowledge Mode
            /// 0: active fall do not care ack
            /// 1: active fall must after detect ack is high
            SPI_ACK_M: u1,
            /// SPI NDMA Active Mode
            /// 00: dma_active is low
            /// 01: dma_active is high
            /// 10: dma_active is controlled by dma_request (DRQ)
            /// 11: dma_active is controlled by controller
            SPI_ACT_M: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x402604c
        /// SPI RX Bit Register
        pub const SPI_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The Value of the Receive Bits This register is used to store the value of the
            /// received serial data frame. In the process of transmission, the LSB is
            /// transmitted first. This register is only valid when Work Mode Select==0x10/0x11.
            VRB: u32,
        }), base_address + 0x4c);

        /// address: 0x4026300
        /// SPI RX Data register
        pub const SPI_RXD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive Data This register can be accessed in the byte, half-word, or word unit
            /// by AHB. In the byte accessing method, if there are data in RXFIFO, the top word
            /// is returned and the RXFIFO depth is decreased by 1. In the half-word accessing
            /// method, two SPI bursts are returned and the RXFIFO depth is decreased by 2. In
            /// the word accessing method, the four SPI bursts are returned and the RXFIFO depth
            /// is decreased by 4.
            RDATA: u32,
        }), base_address + 0x300);

        /// address: 0x4026028
        /// SPI Sample Delay Control Register
        pub const SPI_SAMP_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Delay Software The relative delay between the clock line and command
            /// line, data lines. It can be determined according to the value of SAMP_DL, the
            /// cycle of the card clock, and the input timing requirement of the device. Cannot
            /// be written when XCH=1.
            SAMP_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable When set, it indicates that enable sample delay
            /// specified at SAMP_DL_SW Cannot be written when XCH=1.
            SAMP_DL_SW_EN: u1,
            /// Sample Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the card clock nearly. Generally, it is necessary to do drive delay
            /// calibration when the card clock is changed. This bit is valid only when
            /// SAMP_DL_CAL_DONE is set. Cannot be written when XCH=1.
            SAMP_DL: u6,
            /// Sample Delay Calibration Done When set, it indicates that the sample delay chain
            /// calibration is done and the result of calibration is shown in SAMP_DL. Cannot be
            /// written when XCH=1.
            SAMP_DL_CAL_DONE: u1,
            /// Sample Delay Calibration Start When set, it indicates that start sample delay
            /// chain calibration. Cannot be written when XCH=1.
            SAMP_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4026048
        /// SPI TX Bit Register
        pub const SPI_TBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The Value of the Transmit Bits This register is used to store the value of the
            /// transmitted serial data frame. In the process of transmission, the LSB is
            /// transmitted first. This register is only valid when Work Mode Select==0x10/0x11.
            VTB: u32,
        }), base_address + 0x48);

        /// address: 0x4026008
        /// SPI Transfer Control Register
        pub const SPI_TCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI Clock/Data Phase Control
            /// 0: Phase 0 (Leading edge for sample data)
            /// 1: Phase 1 (Leading edge for setup data) Cannot be written when XCH=1.
            CPHA: u1,
            /// SPI Clock Polarity Control
            /// 0: Active high polarity (0 = Idle)
            /// 1: Active low polarity (1 = Idle) Cannot be written when XCH=1.
            CPOL: u1,
            /// SPI Chip Select Signal Polarity Control
            /// 0: Active high polarity (0 = Idle)
            /// 1: Active low polarity (1 = Idle) Cannot be written when XCH=1.
            SPOL: u1,
            /// In master mode, this bit selects the output waveform for the SPI_SSx signal.
            /// Only valid when SS_OWNER (SPI_TCR[6])= 0.
            /// 0: SPI_SSx remains asserted between SPI bursts
            /// 1: Negate SPI_SSx between SPI bursts Cannot be written when XCH=1.
            SSCTL: u1,
            /// SPI Chip Select Select one of four external SPI Master/Slave Devices
            /// 00: SPI_SS0 will be asserted
            /// 01: SPI_SS1 will be asserted
            /// 10: SPI_SS2 will be asserted
            /// 11: SPI_SS3 will be asserted Cannot be written when XCH=1.
            SS_SEL: u2,
            /// SS Output Owner Select Usually, the controller sends the SS signal automatically
            /// with data together. When this bit is set to 1, the software must manually write
            /// SS_LEVEL (SPI_TCR[7]) to 1 or 0 to control the level of the SS signal.
            /// 0: SPI controller
            /// 1: Software Cannot be written when XCH=1.
            SS_OWNER: u1,
            /// SPI Chip Select Level When control SS signal manually (SS_OWNER
            /// (SPI_TCR[6])==1), set this bit to ‘1’ or ‘0’ to control the level of SS
            /// signal.
            /// 0: Set SS to low
            /// 1: Set SS to high Cannot be written when XCH=1.
            SS_LEVEL: u1,
            /// Discard Hash Burst In master mode, it controls whether discarding unused SPI
            /// bursts
            /// 0: Receiving all SPI bursts in the BC period
            /// 1: Discard unused SPI bursts, only fetching the SPI bursts during the dummy
            /// burst period. The burst number is specified by TC. Cannot be written when XCH=1.
            DHB: u1,
            /// Dummy Burst Type
            /// 0: The bit value of dummy SPI burst is zero
            /// 1: The bit value of dummy SPI burst is one Cannot be written when XCH=1.
            DDB: u1,
            /// Rapids Mode Select Select rapid mode for high speed write.
            /// 0: Normal write mode
            /// 1: Rapid write mode Cannot be written when XCH=1.
            RPSM: u1,
            /// Master Sample Data Control Set this bit to ‘1’ to make the internal read
            /// sample point with a delay of half-cycle of SPI_CLK. It is used in high speed
            /// read operation to reduce the error caused by the time delay of SPI_CLK between
            /// master and slave.
            /// 0: Normal operation, do not delay the internal read sample point
            /// 1: Delay the internal read sample point Cannot be written when XCH=1.
            SDC: u1,
            /// First Transmit Bit Select
            /// 0: MSB first. The upper bits are transmitted first.
            /// 1: LSB first. The lower bits are transmitted first. Cannot be written when
            /// XCH=1.
            FBS: u1,
            /// Master Sample Data Mode
            /// 0: Delay sample mode
            /// 1: Normal sample mode In normal sample mode, the SPI master samples the data at
            /// the correct edge for each SPI mode; In delay sample mode, the SPI master samples
            /// data at the edge that is half cycle delayed by the correct edge defined in
            /// respective SPI mode. Cannot be written when XCH=1.
            SDM: u1,
            /// Sending Data Delay Mode
            /// 0: Normal sending
            /// 1: Delay sending Set the bit to "1" to make the data that should be sent with a
            /// delay of half-cycle of SPI_CLK in dual IO mode for SPI mode 0. Cannot be written
            /// when XCH=1.
            SDDM: u1,
            /// Master Sample Data Control register1 Set this bit to ‘1’ to make the
            /// internal read sample point with a delay of half-cycle of SPI_CLK. It is used in
            /// high speed read operation to reduce the error caused by the time delay of
            /// SPI_CLK between master and slave.
            /// 0: Normal operation, do not delay the internal read sample point
            /// 1: Delay the internal read sample point Cannot be written when XCH=1.
            SDC1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Exchange Burst In master mode, it is used to start SPI burst
            /// 0: Idle
            /// 1: Initiates exchange. Writing “1” to this bit will start the SPI burst, and
            /// will auto-clear after finishing the bursts transfer specified by BC. Writing
            /// “1” to SRST will also clear this bit. Writing ‘0’ to this bit has no
            /// effect. Cannot be written when XCH=1.
            XCH: u1,
        }), base_address + 0x8);

        /// address: 0x4026200
        /// SPI TX Data register
        pub const SPI_TXD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Data This register can be accessed in the byte, half-word, or word unit
            /// by AHB. In the byte accessing method, if there are rooms in TXFIFO, one burst
            /// data is written to TXFIFO and the depth is increased by 1. In the half-word
            /// accessing method, two SPI burst data are written and the TXFIFO depth is
            /// increased by 2. In the word accessing method, four SPI burst data are written
            /// and the TXFIFO depth is increased by 4.
            TDATA: u32,
        }), base_address + 0x200);

        /// address: 0x4026020
        /// SPI Wait Clock Register
        pub const SPI_WCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wait Clock Counter (In master mode) These bits control the number of wait states
            /// to be inserted in data transfers. The SPI module counts SPI_SCLK by WCC for
            /// delaying the next word data transfer.
            /// 0: No wait states inserted n: n SPI_SCLK wait states inserted Cannot be written
            /// when XCH=1.
            WCC: u16,
            /// Dual mode direction switch wait clock counter (for master mode only). These bits
            /// control the number of wait states to be inserted before starting dual data
            /// transfer in dual SPI mode. The SPI module counts SPI_SCLK by SWC for delaying
            /// the next word data transfer.
            /// 0: No wait states inserted n: n SPI_SCLK wait states inserted Cannot be written
            /// when XCH=1.
            SWC: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x20);
    };

    /// DMAC
    pub const DMAC = struct {
        pub const base_address = 0x3002000;

        /// address: 0x3002028
        /// DMAC Auto Gating Register
        pub const DMAC_AUTO_GATE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto gating bit of DMA channel circuit
            /// 0: Auto gating enabled
            /// 1: Auto gating disabled
            DMA_CHAN_CIRCUIT: u1,
            /// Auto gating bit of DMA common circuit
            /// 0: Auto gating enabled
            /// 1: Auto gating disabled
            DMA_COMMON_CIRCUIT: u1,
            /// Auto gating bit of DMA MCLK interface circuit
            /// 0: Auto gating enabled
            /// 1: Auto gating disabled
            DMA_MCLK_CIRCUIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x28);

        /// address: 0x3002000
        /// DMAC IRQ Enable Register 0
        pub const DMAC_IRQ_EN_REG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the half package interrupt of DMA channel 0
            /// 0: Disabled
            /// 1: Enabled
            DMA0_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 0
            /// 0: Disabled
            /// 1: Enabled
            DMA0_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 0
            /// 0: Disabled
            /// 1: Enabled
            DMA0_QUEUE_IRQ_EN: u1,
            reserved0: u1,
            /// Enable the half package interrupt of DMA channel 1
            /// 0: Disabled
            /// 1: Enabled
            DMA1_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 1
            /// 0: Disabled
            /// 1: Enabled
            DMA1_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 1
            /// 0: Disabled
            /// 1: Enabled
            DMA1_QUEUE_IRQ_EN: u1,
            reserved1: u1,
            /// Enable the half package interrupt of DMA channel 2
            /// 0: Disabled
            /// 1: Enabled
            DMA2_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 2
            /// 0: Disabled
            /// 1: Enabled
            DMA2_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 2
            /// 0: Disabled
            /// 1: Enabled
            DMA2_QUEUE_IRQ_EN: u1,
            reserved2: u1,
            /// Enable the half package interrupt of DMA channel 3
            /// 0: Disabled
            /// 1: Enabled
            DMA3_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 3
            /// 0: Disabled
            /// 1: Enabled
            DMA3_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 3
            /// 0: Disabled
            /// 1: Enabled
            DMA3_QUEUE_IRQ_EN: u1,
            reserved3: u1,
            /// Enable the half package interrupt of DMA channel 4
            /// 0: Disabled
            /// 1: Enabled
            DMA4_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 4
            /// 0: Disabled
            /// 1: Enabled
            DMA4_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 4
            /// 0: Disabled
            /// 1: Enabled
            DMA4_QUEUE_IRQ_EN: u1,
            reserved4: u1,
            /// Enable the half package interrupt of DMA channel 5
            /// 0: Disabled
            /// 1: Enabled
            DMA5_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 5
            /// 0: Disabled
            /// 1: Enabled
            DMA5_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 5
            /// 0: Disabled
            /// 1: Enabled
            DMA5_QUEUE_IRQ_EN: u1,
            reserved5: u1,
            /// Enable the half package interrupt of DMA channel 6
            /// 0: Disabled
            /// 1: Enabled
            DMA6_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 6
            /// 0: Disabled
            /// 1: Enabled
            DMA6_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 6
            /// 0: Disabled
            /// 1: Enabled
            DMA6_QUEUE_IRQ_EN: u1,
            reserved6: u1,
            /// Enable the half package interrupt of DMA channel 7
            /// 0: Disabled
            /// 1: Enabled
            DMA7_HLAF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 7
            /// 0: Disabled
            /// 1: Enabled
            DMA7_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 7
            /// 0: Disabled
            /// 1: Enabled
            DMA7_QUEUE_IRQ_EN: u1,
            padding0: u1,
        }), base_address + 0x0);

        /// address: 0x3002004
        /// DMAC IRQ Enable Register 1
        pub const DMAC_IRQ_EN_REG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the half package interrupt of DMA channel 8
            /// 0: Disabled
            /// 1: Enabled
            DMA8_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 8
            /// 0: Disabled
            /// 1: Enabled
            DMA8_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 8
            /// 0: Disabled
            /// 1: Enabled
            DMA8_QUEUE_IRQ_EN: u1,
            reserved0: u1,
            /// Enable the half package interrupt of DMA channel 9
            /// 0: Disabled
            /// 1: Enabled
            DMA9_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 9
            /// 0: Disabled
            /// 1: Enabled
            DMA9_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 9
            /// 0: Disabled
            /// 1: Enabled
            DMA9_QUEUE_IRQ_EN: u1,
            reserved1: u1,
            /// Enable the half package interrupt of DMA channel 10
            /// 0: Disabled
            /// 1: Enabled
            DMA10_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 10
            /// 0: Disabled
            /// 1: Enabled
            DMA10_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 10
            /// 0: Disabled
            /// 1: Enabled
            DMA10_QUEUE_IRQ_EN: u1,
            reserved2: u1,
            /// Enable the half package interrupt of DMA channel 11
            /// 0: Disabled
            /// 1: Enabled
            DMA11_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 11
            /// 0: Disabled
            /// 1: Enabled
            DMA11_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 11
            /// 0: Disabled
            /// 1: Enabled
            DMA11_QUEUE_IRQ_EN: u1,
            reserved3: u1,
            /// Enable the half package interrupt of DMA channel 12
            /// 0: Disabled
            /// 1: Enabled
            DMA12_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 12
            /// 0: Disabled
            /// 1: Enabled
            DMA12_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 12
            /// 0: Disabled
            /// 1: Enabled
            DMA12_QUEUE_IRQ_EN: u1,
            reserved4: u1,
            /// Enable the half package interrupt of DMA channel 13
            /// 0: Disabled
            /// 1: Enabled
            DMA13_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 13
            /// 0: Disabled
            /// 1: Enabled
            DMA13_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 13
            /// 0: Disabled
            /// 1: Enabled
            DMA13_QUEUE_IRQ_EN: u1,
            reserved5: u1,
            /// Enable the half package interrupt of DMA channel 14
            /// 0: Disabled
            /// 1: Enabled
            DMA14_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 14
            /// 0: Disabled
            /// 1: Enabled
            DMA14_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 14
            /// 0: Disabled
            /// 1: Enabled
            DMA14_QUEUE_IRQ_EN: u1,
            reserved6: u1,
            /// Enable the half package interrupt of DMA channel 15
            /// 0: Disabled
            /// 1: Enabled
            DMA15_HALF_IRQ_EN: u1,
            /// Enable the package end interrupt of DMA channel 15
            /// 0: Disabled
            /// 1: Enabled
            DMA15_PKG_IRQ_EN: u1,
            /// Enable the queue end interrupt of DMA channel 15
            /// 0: Disabled
            /// 1: Enabled
            DMA15_QUEUE_IRQ_EN: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x3002010
        /// DMAC IRQ Pending Register 0
        pub const DMAC_IRQ_PEND_REG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The IRQ pending bit for the half package interrupt of the DMA channel 0. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA0_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 0. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA0_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 0. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA0_QUEUE_IRQ_PEND: u1,
            reserved0: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 1. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA1_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 1. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA1_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 1. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA1_QUEUE_IRQ_PEND: u1,
            reserved1: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 2. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA2_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 2. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA2_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 2. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA2_QUEUE_IRQ_PEND: u1,
            reserved2: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 3. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA3_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 3. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA3_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 3. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA3_QUEUE_IRQ_PEND: u1,
            reserved3: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 4. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA4_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 4. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA4_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 4. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA4_QUEUE_IRQ_PEND: u1,
            reserved4: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 5. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA5_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 5. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA5_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 5. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA5_QUEUE_IRQ_PEND: u1,
            reserved5: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 6. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA6_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 6. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA6_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 6. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA6_QUEUE_IRQ_PEND: u1,
            reserved6: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 7. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA7_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 7. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA7_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 7. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA7_QUEUE_IRQ_PEND: u1,
            padding0: u1,
        }), base_address + 0x10);

        /// address: 0x3002014
        /// DMAC IRQ Pending Register 1
        pub const DMAC_IRQ_PEND_REG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The IRQ pending bit for the half package interrupt of the DMA channel 8. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA8_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 8. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA8_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 8. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA8_QUEUE_IRQ_PEND: u1,
            reserved0: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 9. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA9_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 9. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA9_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 9. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA9_QUEUE_IRQ_PEND: u1,
            reserved1: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 10. Write
            /// 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA10_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 10. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA10_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 10. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA10_QUEUE_IRQ_PEND: u1,
            reserved2: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 11. Write
            /// 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA11_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 11. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA11_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 11. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA11_QUEUE_IRQ_PEND: u1,
            reserved3: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 12. Write
            /// 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA12_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 12. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA12_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 12. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA12_QUEUE_IRQ_PEND: u1,
            reserved4: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 13. Write
            /// 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA13_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 13. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending.
            DMA13_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 13. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA13_QUEUE_IRQ_PEND: u1,
            reserved5: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 14. Write
            /// 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA14_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 14. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA14_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 14. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA14_QUEUE_IRQ_PEND: u1,
            reserved6: u1,
            /// The IRQ pending bit for the half package interrupt of the DMA channel 15. Write
            /// 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA15_HALF_IRQ_PEND: u1,
            /// The IRQ pending bit for the package end interrupt of the DMA channel 15. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA15_PKG_IRQ_PEND: u1,
            /// The IRQ pending bit for the queue end interrupt of the DMA channel 15. Write 1
            /// to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            DMA15_QUEUE_IRQ_PEND: u1,
            padding0: u1,
        }), base_address + 0x14);

        /// address: 0x3002030
        /// DMAC Status Register
        pub const DMAC_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Channel[15:0] Status The meaning of each bit:
            /// 0: Idle
            /// 1: Busy
            DMA_STATUS: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// FIFO Status
            /// 0: Empty
            /// 1: Not Empty
            MBUS: u1,
        }), base_address + 0x30);

        pub const _N = @ptrCast(*volatile [16]packed struct {
            /// DMAC Channel Byte Counter Left Register N (N = 0 to 15)
            DMAC_BCNT_LEFT_REGN: Mmio(32, packed struct {
                /// DMA Channel Byte Counter Left.
                DMA_BCNT_LEFT: u25,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }),

            /// DMAC_CFG_REGN
            DMAC_CFG_REGN: Mmio(32, packed struct {
                /// DMA Source DRQ Type The details in DRQ Type and Port Corresponding Relation.
                DMA_SRC_DRQ_TYPE: u6,
                /// DMA Source Block Size
                /// 00: 1
                /// 01: 4
                /// 10: 8
                /// 11: 16
                DMA_SRC_BLOCK_SIZE: u2,
                /// DMA Source Address Mode
                /// 0: Linear Mode
                /// 1: IO Mode
                DMA_SRC_ADDR_MODE: u1,
                /// DMA Source Data Width
                /// 00: 8-bit
                /// 01: 16-bit
                /// 10: 32-bit
                /// 11: 64-bit
                DMA_SRC_DATA_WIDTH: u2,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                /// DMA Destination DRQ Type The details in DRQ Type and Port Corresponding
                /// Relation.
                DMA_DEST_DRQ_TYPE: u6,
                /// DMA Destination Block Size
                /// 00: 1
                /// 01: 4
                /// 10: 8
                /// 11: 16
                DMA_DEST_BLOCK_SIZE: u2,
                /// DMA Destination Address Mode
                /// 0: Linear Mode
                /// 1: IO Mode
                DMA_ADDR_MODE: u1,
                /// DMA Destination Data Width
                /// 00: 8-bit
                /// 01: 16-bit
                /// 10: 32-bit
                /// 11: 64-bit
                DMA_DEST_DATA_WIDTH: u2,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// 0: Normal Mode
                /// 1: BMODE
                BMODE_SEL: u1,
                padding0: u1,
            }),

            /// DMAC Channel Current Destination Register N (N = 0 to 15)
            DMAC_CUR_DEST_REGN: Mmio(32, packed struct {
                /// DMA Channel Current Destination Address.
                DMA_CUR_DEST: u32,
            }),

            /// DMAC_CUR_SRC_REGN
            DMAC_CUR_SRC_REGN: Mmio(32, packed struct {
                /// DMA Channel Current Source Address.
                DMA_CUR_SRC: u32,
            }),

            /// DMAC_DESC_ADDR_REGN
            DMAC_DESC_ADDR_REGN: Mmio(32, packed struct {
                /// Higher 2 bits of DMA channel descriptor high address The real address is as
                /// follows. DMA Channel Descriptor Address = {bit[1:0], bit[31:2], 2’b00}
                DMA_DESC_HIGH_ADDR: u2,
                /// Lower 30 bits of DMA channel descriptor address The descriptor address must be
                /// word-aligned.
                DMA_DESC_ADDR: u30,
            }),

            /// DMAC_EN_REGN
            DMAC_EN_REGN: Mmio(32, packed struct {
                /// DMA Channel Enable
                /// 0: Disabled
                /// 1: Enabled
                DMA_EN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
                padding28: u1,
                padding29: u1,
                padding30: u1,
            }),

            /// DMAC_FDESC_ADDR_REGN
            DMAC_FDESC_ADDR_REGN: Mmio(32, packed struct {
                /// This register is used to store the former value of DMA Channel Descriptor
                /// Address Register.
                DMA_FDESC_ADDR: u32,
            }),

            /// DMAC_MODE_REGN
            DMAC_MODE_REGN: Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                /// Source Communication Mode Select
                /// 0: Waiting mode
                /// 1: Handshake mode
                DMA_SRC_MODE: u1,
                /// Destination Communication Mode Select
                /// 0: Waiting mode
                /// 1: Handshake mode
                DMA_DST_MODE: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
            }),

            /// DMAC_PARA_REGN
            DMAC_PARA_REGN: Mmio(32, packed struct {
                /// Wait Clock Cycles
                WAIT_CYC: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }),

            /// DMAC_PAU_REGN
            DMAC_PAU_REGN: Mmio(32, packed struct {
                /// Pause the DMA Channel Transfer Data
                /// 0: Resume Transferring
                /// 1: Pause Transferring
                DMA_PAUSE: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
                padding28: u1,
                padding29: u1,
                padding30: u1,
            }),

            /// DMAC_PKG_NUM_REGN
            DMAC_PKG_NUM_REGN: Mmio(32, packed struct {
                /// This register records the number of packages which has been completed in one
                /// transmission.
                DMA_PKG_NUM: u32,
            }),
            padding0: u64,
            padding1: u64,
        }, base_address + 0x100);
    };

    /// SYS_CFG
    pub const SYS_CFG = struct {
        pub const base_address = 0x3000000;

        /// address: 0x3000008
        /// DSP_BOOT_RAMMAP_REG
        pub const DSP_BOOT_RAMMAP_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// BOOT SRAM REMAP ENABLE
            /// 0: DSP 128K Local SRAM Remap for DSP_SYS
            /// 1: DSP 128K Local SRAM Remap for System Boot After system boots up, this bit
            /// must be set to 0 before using DSP.
            DSP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);

        /// address: 0x3000030
        /// EMAC-EPHY Clock Register 0
        pub const EMAC_EPHY_CLK_REG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EMAC Transmit Clock Source
            /// 00: Transmit clock source for MII
            /// 01: External transmit clock source for GMII and RGMII
            /// 10: Internal transmit clock source for GMII and RGMII
            /// 11: Reserved
            ETCS: u2,
            /// EMAC PHY Interface Type
            /// 0: MII
            /// 1: RGMII
            EPIT: u1,
            /// Enable EMAC Transmit Clock Invertor
            /// 0: Disabled
            /// 1: Enabled
            ETXIE: u1,
            /// Enable EMAC Receive Clock Invertor
            /// 0: Disabled
            /// 1: Enabled
            ERXIE: u1,
            /// Configure EMAC Receive Clock Delay Chain
            ERXDC: u5,
            /// Configure EMAC Transmit Clock Delay Chain
            ETXDC: u3,
            /// 0: Disable RMII Module
            /// 1: Enable RMII Module This bit is prior to bit[2]. When this bit is asserted,
            /// the MII and RGMII interfaces will be both disabled.
            RMII_EN: u1,
            reserved0: u1,
            /// 0: External PHY
            /// 1: Internal PHY
            PHY_SELECT: u1,
            /// 0: Power up
            /// 1: Shut down
            SHUTDOWN: u1,
            /// 0: High active
            /// 1: Low active
            LED_POL: u1,
            /// 0: 25 MHz
            /// 1: 24 MHz
            CLK_SEL: u1,
            reserved1: u1,
            /// PHY Address
            PHY_ADDR: u5,
            /// Operation Mode Selection
            /// 00: Normal Mode
            /// 01: Simulation Mode
            /// 10: AFE Test Mode
            /// 11: Reserved
            EPHY_MODE: u2,
            /// 0: Internal SMI and MII
            /// 1: External SMI and MII
            XMII_SEL: u1,
            BPS_EFUSE: u4,
        }), base_address + 0x30);

        /// address: 0x3000168
        /// 240ohms Resistor Manual Control Register
        pub const RES240_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 240ohms Resistor trimming bit
            DDR_RES240_TRIM: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x168);

        /// address: 0x3000160
        /// Resistor Calibration Control Register
        pub const RESCAL_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto Calibration Enable
            /// 0: Disable
            /// 1: Enable
            CAL_EN: u1,
            /// Calibration Circuits Analog Enable
            /// 0: Disable
            /// 1: Enable
            CAL_ANA_EN: u1,
            /// RESCAL Calibration Mode Select
            /// 0: Auto Calibration
            /// 1: Reserved
            RESCAL_MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// 240ohms Resistor Trimming Source Select
            /// 0: Trimming value from RESCAL
            /// 1: Trimming value from RES240_TRIM
            DDR_RES240_TRIMMING_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x160);

        /// address: 0x300016c
        /// Resistor Calibration Status Register
        pub const RESCAL_STATUS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// RESCAL Calibration Results Output
            RES_CAL_DO: u6,
            reserved0: u1,
            reserved1: u1,
            /// Calibration Circuits Analog Compare Output
            COUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x16c);

        /// address: 0x3000150
        /// System LDO Control Register
        pub const SYS_LDO_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LDOA Trimming Adjust LDOA output, only the low 5-bit is used. 00000:1.593
            /// 00001:1.607 00010:1.627 00011:1.64 00100:1.653 00101:1.667 00110:1.680
            /// 00111:1.693 01000:1.707 01001:1.720 01010:1.733 01011:1.747 01100:1.76
            /// 01101:1.773 01110:1.787 01111:1.8 (default) 10000:1.813 10001:1.827 10010:1.84
            /// 10011:1.853 10100:1.867 10101:1.88 10110:1.893 10111:1.907 11000:1.92
            /// 11001:1.933 11010:1.947 11011:1.96 11100:1.973 11101:1.987 11110:2 11111:2.013
            LDOA_TIM: u8,
            /// LDOB Trimming Adjust LDOB output, only the low 6-bit is used. 000000:1.167
            /// 000001:1.18 000010:1.193 000011:1.207 000100:1.22 000101:1.233 000110:1.247
            /// 000111:1.260 001000:1.273 001001:1.287 001010:1.3 001011:1.313 001100:1.327
            /// 001101:1.340 001110:1.353 (default) 001111:1.367 010000:1.38 010001:1.393
            /// 010010:1.407 010011:1.42 010100:1.433 010101:1.447 010110:1.46 010111:1.473
            /// 011000:1.487 011001:1.5 011010:1.513 011011:1.527 011100:1.54 011101:1.553
            /// 011110:1.567 011111:1.58 100000:1.593 100001:1.607 100010:1.627 100011:1.64
            /// 100100:1.653 100101:1.667 100110:1.680 100111:1.693 101000:1.707 101001:1.720
            /// 101010:1.733 101011:1.747 101100:1.76 101101:1.773 101110:1.787 101111:1.8
            /// 110000:1.813 110001:1.827 110010:1.84 110011:1.853 110100:1.867 110101:1.88
            /// 110110:1.893 110111:1.907 111000:1.92 111001:1.933 111010:1.947 111011:1.96
            /// 111100:1.973 111101:1.987 111110:2 111111:2.013
            LDOB_TRIM: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Reserved spare register
            SPARE: u8,
        }), base_address + 0x150);

        /// address: 0x3000024
        /// Version Register
        pub const VER_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Fel_Select_Pin_Status
            /// 0: Run_FEL
            /// 1: Try Media Boot
            FEL_SEL_PAD_STA: u1,
            reserved8: u1,
            reserved9: u1,
            /// The value of this bit decides the priority order for each medium type to be
            /// selected as the boot media.
            BOOT_SEL_PAD_STA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x24);
    };

    /// EMAC
    pub const EMAC = struct {
        pub const base_address = 0x4500000;

        /// address: 0x4500050
        /// EMAC MAC Address High Register0
        pub const EMAC_ADDR_HIGH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The upper 16 bits of the 1st MAC address.
            MAC_ADDR_HIGH0: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x4500054
        /// EMAC MAC Address Low Register0
        pub const EMAC_ADDR_LOW0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lower 32 bits of 1st MAC address.
            MAC_ADDR_LOW0: u32,
        }), base_address + 0x54);

        /// address: 0x4500000
        /// EMAC Basic Control Register0
        pub const EMAC_BASIC_CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EMAC Transfer Mode
            /// 0: Half-duplex
            /// 1: Full-duplex
            DUPLEX: u1,
            /// EMAC Loopback Mode For Test
            /// 0: Disable
            /// 1: Enable
            LOOPBACK: u1,
            /// EMAC Working Speed
            /// 00: 1000 Mbit/s
            /// 01: Reserved
            /// 10: 10 Mbit/s
            /// 11: 100 Mbit/s
            SPEED: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x0);

        /// address: 0x4500004
        /// EMAC Basic Control Register1
        pub const EMAC_BASIC_CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Soft Reset all Registers and Logic
            /// 0: No valid
            /// 1: Reset All clock inputs must be valid before soft reset. This bit is cleared
            /// internally when the reset operation is completed fully. Before writing any
            /// register, this bit should read a 0.
            SOFT_RST: u1,
            /// RX TX DMA Priority
            /// 0: Same priority
            /// 1: RX priority is over TX
            RX_TX_PRI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// The burst length of RX and TX DMA transfer.
            BURST_LEN: u6,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0x450000c
        /// EMAC Interrupt Enable Register
        pub const EMAC_INT_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt
            /// 0: Disable
            /// 1: Enable
            TX_INT_EN: u1,
            /// Transmit DMA FSM Stopped Interrupt
            /// 0: Disable
            /// 1: Enable
            TX_DMA_STOPPED_INT_EN: u1,
            /// Transmit Buffer Available Interrupt
            /// 0: Disable
            /// 1: Enable
            TX_BUF_UA_INT_EN: u1,
            /// Transmit Timeout Interrupt
            /// 0: Disable
            /// 1: Enable
            TX_TIMEOUT_INT_EN: u1,
            /// Transmit Underflow Interrupt
            /// 0: Disable
            /// 1: Enable
            TX_UNDERFLOW_INT_EN: u1,
            /// Early Transmit Interrupt
            /// 0: Disable
            /// 1: Enable
            TX_EARLY_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Receive Interrupt
            /// 0: Disable
            /// 1: Enable
            RX_INT_EN: u1,
            /// Receive Buffer Unavailable Interrupt
            /// 0: Disable
            /// 1: Enable
            RX_BUF_UA_INT_EN: u1,
            /// Receive DMA FSM Stopped Interrupt
            /// 0: Disable
            /// 1: Enable
            RX_DMA_STOPPED_INT_EN: u1,
            /// Receive Timeout Interrupt
            /// 0: Disable
            /// 1: Enable
            RX_TIMEOUT_INT_EN: u1,
            /// Receive Overflow Interrupt
            /// 0: Disable
            /// 1: Enable
            RX_OVERFLOW_INT_EN: u1,
            /// Early Receive Interrupt
            /// 0: Disable
            /// 1: Enable
            RX_EARLY_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x4500008
        /// EMAC Interrupt Status Register
        pub const EMAC_INT_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame Transmission Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            TX_P: u1,
            /// Transmission DMA Stopped Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            TX_DMA_STOPPED_P: u1,
            /// TX Buffer UA Interrupt Pending
            /// 0: No Pending
            /// 1: Pending When this asserted, the TX DMA can not acquire the next TX descriptor
            /// and the TX DMA FSM is suspended. The ownership of the next TX descriptor should
            /// be changed to TX DMA. The TX DMA FSM will resume when writing to TX_DMA_START
            /// bit.
            TX_BUF_UA_P: u1,
            /// Transmitter Timeout Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            TX_TIMEOUT_P: u1,
            /// TX FIFO Underflow Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            TX_UNDERFLOW_P: u1,
            /// Total interrupt pending which the frame is transmitted to FIFO
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            TX_EARLY_P: u1,
            reserved0: u1,
            reserved1: u1,
            /// Frame RX Completed Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it. When this bit is asserted, a frame
            /// reception is completed. The RX DMA FSM remains running.
            RX_P: u1,
            /// _P RX Buffer UA Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it. When this bit is asserted, the RX DMA
            /// cannot acquire the next RX descriptor and RX DMA FSM is suspended. The ownership
            /// of the next RX descriptor should be changed to RX DMA. The RX DMA FSM will
            /// resume when the RX_DMA_START is written or the next receive frame is coming.
            RX_BUF_UA: u1,
            /// When this bit asserted, the RX DMA FSM is stopped.
            RX_DMA_STOPPED_P: u1,
            /// RX Timeout Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it. When this bit is asserted, the length of
            /// the received frame is greater than 2048 bytes (10240 when JUMBO_FRM_EN is set)
            RX_TIMEOUT_P: u1,
            /// RX FIFO Overflow Error Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            RX_OVERFLOW_P: u1,
            /// RX DMA Filled First Data Buffer of the Receive Frame Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            RX_EARLY_P: u1,
            reserved2: u1,
            reserved3: u1,
            /// RMII Link Status Changed Interrupt Pending
            /// 0: No Pending
            /// 1: Pending Write ‘1’ to clear it.
            RGMII_LINK_STA_P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4500048
        /// EMAC Management Interface Command Register
        pub const EMAC_MII_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// MII Status
            /// 0: Writing 0 is no valid, and reading 0 indicates the read/write operation is
            /// finished
            /// 1: Writing 1 starts the read/write operation, and reading 1 indicates busy.
            MII_BUSY: u1,
            /// MII Write and Read
            /// 0: Read
            /// 1: Write
            MII_WR: u1,
            reserved0: u1,
            reserved1: u1,
            /// PHY Register Address
            PHY_REG_ADDR: u5,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PHY Address
            PHY_ADDR: u5,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// MDC Clock Divider Ratio The MDC Clock is divided from the AHB clock.
            /// 000: 16
            /// 001: 32
            /// 010: 64
            /// 011: 128 Others: Reserved
            MDC_DIV_RATIO_M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x48);

        /// address: 0x450004c
        /// EMAC Management Interface Data Register
        pub const EMAC_MII_DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write to or read from the register in the selected PHY.
            MII_DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x45000d0
        /// EMAC RGMII Status Register
        pub const EMAC_RGMII_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The link mode of the RGMII interface
            /// 0: Half-Duplex
            /// 1: Full-Duplex
            RGMII_LINK_MD: u1,
            /// The link speed of the RGMII interface
            /// 00: 2.5 MHz
            /// 01: 25 MHz
            /// 10: 125 MHz
            /// 11: Reserved
            RGMII_LINK_SPD: u2,
            /// The link status of the RGMII interface
            /// 0: Down
            /// 1: Up
            RGMII_LINK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xd0);

        /// address: 0x4500024
        /// EMAC Receive Control Register0
        pub const EMAC_RX_CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// When set, enable the functionality that decodes the received pause frame and
            /// disable its transmitter for a specified time by pause frame.
            RX_FLOW_CTL_EN: u1,
            /// 0: Only detect multicast pause frame specified in the 802.3x standard.
            /// 1: In addition to detect multicast pause frame specified in the 802.3x standard,
            /// also detect unicast pause frame with the address specified in MAC Address 0 High
            /// Register and MAC address 0 Low Register.
            RX_PAUSE_FRM_MD: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// Check CRC Enable
            /// 0: Disable
            /// 1: Calculate CRC and check the IPv4 Header Checksum
            CHECK_CRC: u1,
            /// When set, strip the Pad/FCS field on received frames only when the length of
            /// field value is less than or equal to 1500 bytes.
            STRIP_FCS: u1,
            /// Jumbo Frame Enable
            /// 0: Disable
            /// 1: Enable Jumbo frames of 9018 bytes without reporting a giant
            JUMBO_FRM_EN: u1,
            /// Frame Receive Length Control
            /// 0: Up to 2048 bytes (JUMBO_FRM_EN==0) Up to 10240 bytes (JUMBO_FRM_EN==1)
            /// 1: Up to 16384 bytes Any bytes after that is cut off.
            RX_FRM_LEN_CTL: u1,
            /// Enable Receiver
            /// 0: Disable receiver after current reception
            /// 1: Enable
            RX_EN: u1,
        }), base_address + 0x24);

        /// address: 0x4500028
        /// EMAC Receive Control Register1
        pub const EMAC_RX_CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flush Receive Frames
            /// 0: Enable when the receive descriptors/buffers are unavailable
            /// 1: Disable
            FLUSH_RX_FRM: u1,
            /// Receive Mode
            /// 0: RX starts to read after the RX DMA FIFO byte is greater than RX_TH
            /// 1: RX starts to read after the RX DMA FIFO is located a full frame
            RX_MD: u1,
            /// When the bit is set to 1, it indicates forward undersized frames with no error
            /// and length less than 64 bytes.
            RX_RUNT_FRM: u1,
            /// 0: RX DMA drops frames with error
            /// 1: RX DMA forwards frames with error
            RX_ERR_FRM: u1,
            /// Threshold for RX DMA FIFO Start
            /// 00: 64
            /// 01: 32
            /// 10: 96
            /// 11: 128 Only valid when RX_MD == 0, the full frames with a length less than the
            /// threshold are transferred automatically.
            RX_TH: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Threshold for Activating Flow Control
            /// 00: Full minus 1 KB
            /// 01: Full minus 2 KB
            /// 10: Full minus 3 KB
            /// 11: Full minus 4 KB Valid in both half-duplex mode and full-duplex mode.
            RX_FLOW_CTL_TH_ACT: u2,
            /// Threshold for Deactivating Flow Control
            /// 00: Full minus 1 KB
            /// 01: Full minus 2 KB
            /// 10: Full minus 3 KB
            /// 11: Full minus 4 KB Valid in both half-duplex mode and full-duplex mode.
            RX_FLOW_CTL_TH_DEACT: u2,
            /// Receive FIFO Flow Control Enable
            /// 0: Disable
            /// 1: Enable, base on RX_FLOW_CTL_TH_DEACT and RX_FLOW_CTL_TH_ACT
            RX_FIFO_FLOW_CTL: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Receive DMA Enable
            /// 0: Stop RX DMA after finishing the received current frame
            /// 1: Start and run RX DMA
            RX_DMA_EN: u1,
            /// When set, the RX DMA will work. It is cleared internally and always read a 0.
            RX_DMA_START: u1,
        }), base_address + 0x28);

        /// address: 0x45000c8
        /// EMAC_RX_DMA_CUR_BUF
        pub const EMAC_RX_DMA_CUR_BUF = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of current receive DMA buffer
            RX_DMA_CUR_BUF: u32,
        }), base_address + 0xc8);

        /// address: 0x45000c4
        /// EMAC_RX_DMA_CUR_DESC
        pub const EMAC_RX_DMA_CUR_DESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of current receive descriptor
            RX_DMA_CUR_DESC: u32,
        }), base_address + 0xc4);

        /// address: 0x4500034
        /// EMAC_RX_DMA_LIST
        pub const EMAC_RX_DMA_LIST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The base address of the received descriptor list It must be 32-bit aligned.
            RX_DESC_LIST: u32,
        }), base_address + 0x34);

        /// address: 0x45000c0
        /// EMAC Receive DMA Status Register
        pub const EMAC_RX_DMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The State of RX DMA FSM
            /// 000: STOP, when reset or disable RX DMA
            /// 001: RUN_FETCH_DESC, fetching RX DMA descriptor
            /// 010: Reserved
            /// 011: RUN_WAIT_FRM, waiting for the frame
            /// 100: SUSPEND, RX descriptor is unavailable
            /// 101: RUN_CLOSE_DESC, closing RX descriptor
            /// 110: Reserved
            /// 111: RUN_TRANS_DATA, passing the frame from host memory to RX DMA FIFO
            RX_DMA_STA: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc0);

        /// address: 0x4500038
        /// EMAC Receive Frame Filter Register
        pub const EMAC_RX_FRM_FLT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive All Frame
            /// 0: Receive the frames that pass the SA/DA address filter
            /// 1: Receive all frames and update the result of address filter (pass or fail) in
            /// the receive status word
            RX_ALL: u1,
            /// 0: If the HASH_MULTICAST or HASH_UNICAST is set, the frame is passed only when
            /// it matches the Hash filter
            /// 1: Receive the frame when it passes the address register filter or the hash
            /// filter (set by HASH_MULTICAST or HASH_UNICAST)
            FLT_MD: u1,
            reserved0: u1,
            reserved1: u1,
            /// 0: Normal filtering of frames is performed
            /// 1: Filter both unicast and multicast frames by comparing DA field in inverse
            /// filtering mode
            DA_INV_FILTER: u1,
            /// Receive SA Invert Filter Set
            /// 0: Pass frames whose SA field matches SA MAC address registers
            /// 1: Pass frames whose SA field does not match SA MAC address registers
            SA_INV_FILTER: u1,
            /// Receive SA Filter Enable
            /// 0: Receive frames and update the result of SA filter
            /// 1: Update the result of the SA filter. In addition, if the SA field of the
            /// received frame does not match the values in SA MAC address registers, drop this
            /// frame.
            SA_FILTER_EN: u1,
            reserved2: u1,
            /// Filter Unicast Frames Set
            /// 0: By comparing the DA field in DA MAC address registers
            /// 1: According to the hash table
            HASH_UNICAST: u1,
            /// Filter Multicast Frames Set
            /// 0: By comparing the DA field in DA MAC address registers
            /// 1: According to the hash table
            HASH_MULTICAST: u1,
            reserved3: u1,
            reserved4: u1,
            /// Receive Control Frames Filter
            /// 00: Drop all control frames
            /// 01: Drop all control frames
            /// 10: Receive all control frames
            /// 11: Receive all control frames when passing the address filter
            CTL_FRM_FILTER: u2,
            reserved5: u1,
            reserved6: u1,
            /// Receive All Multicast Frames Filter
            /// 0: Filter according to HASH_MULTICAST
            /// 1: Receive all
            RX_ALL_MULTICAST: u1,
            /// Disable Receive Broadcast Frames
            /// 0: Receive
            /// 1: Drop
            DIS_BROADCAST: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Disable Address Filter
            /// 0: Enable
            /// 1: Disable
            DIS_ADDR_FILTER: u1,
        }), base_address + 0x38);

        /// address: 0x4500040
        /// EMAC Hash Table Register0
        pub const EMAC_RX_HASH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The upper 32 bits of Hash table for the received frame filter.
            HASH_TAB0: u32,
        }), base_address + 0x40);

        /// address: 0x4500044
        /// EMAC Hash Table Register1
        pub const EMAC_RX_HASH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The lower 32 bits of Hash table for the received frame filter.
            HASH_TAB1: u32,
        }), base_address + 0x44);

        /// address: 0x4500010
        /// EMAC Transmit Control Register0
        pub const EMAC_TX_CTL0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// Frame Transmit Length Control
            /// 0: Up to 2,048 bytes (JUMBO_FRM_EN==0) Up to 10,240 bytes (JUMBO_FRM_EN==1)
            /// 1: Up to 16,384 bytes Any bytes after that is cut off.
            TX_FRM_LEN_CTL: u1,
            /// Enable Transmitter
            /// 0: Disable
            /// 1: Enable When disabled, the transmission will continue until the current
            /// transmission finishes.
            TX_EN: u1,
        }), base_address + 0x10);

        /// address: 0x4500014
        /// EMAC Transmit Control Register1
        pub const EMAC_TX_CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Flush the data in the TX FIFO
            /// 0: Enable
            /// 1: Disable
            FLUSH_TX_FIFO: u1,
            /// Transmission Mode
            /// 0: TX starts after the TX DMA FIFO bytes is greater than the TX_TH
            /// 1: TX starts after the TX DMA FIFO is located a full frame
            TX_MD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Threshold value of TX DMA FIFO When TX_MD is 0, the transmission starts when the
            /// frame size in TX DMA FIFO is greater than the threshold. In addition, the full
            /// frames with a length less than the threshold are transferred automatically.
            /// 000: 64
            /// 001: 128
            /// 010: 192
            /// 011: 256 Others: Reserved
            TX_TH: u3,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// 0: Stop TX DMA after the completion of current frame transmission
            /// 1: Start and run TX DMA
            TX_DMA_EN: u1,
            /// Transmit DMA FSM Start
            /// 0: No valid
            /// 1: Start It is cleared internally and always read a 0.
            TX_DMA_START: u1,
        }), base_address + 0x14);

        /// address: 0x45000b8
        /// EMAC_TX_DMA_CUR_BUF
        pub const EMAC_TX_DMA_CUR_BUF = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of current transmit DMA buffer.
            TX_DMA_CUR_BUF: u32,
        }), base_address + 0xb8);

        /// address: 0x45000b4
        /// EMAC_TX_DMA_CUR_DESC
        pub const EMAC_TX_DMA_CUR_DESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of current transmit descriptor.
            TX_DMA_CUR_DESC: u32,
        }), base_address + 0xb4);

        /// address: 0x4500020
        /// EMAC_TX_DMA_LIST
        pub const EMAC_TX_DMA_LIST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The base address of the transmission descriptor list It must be 32-bit aligned.
            TX_DESC_LIST: u32,
        }), base_address + 0x20);

        /// address: 0x45000b0
        /// EMAC Transmit DMA Status Register
        pub const EMAC_TX_DMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The State of Transmit DMA FSM
            /// 000: STOP, when reset or disable TX DMA
            /// 001: RUN_FETCH_DESC, fetching TX DMA descriptor
            /// 010: RUN_WAIT_STA, waiting for the status of TX frame
            /// 011: RUN_TRANS_DATA, passing the frame from host memory to TX DMA FIFO
            /// 100: Reserved
            /// 101: Reserved
            /// 111: RUN_CLOSE_DESC, closing TX descriptor
            /// 110: SUSPEND, TX descriptor is unavailable or TX DMA FIFO underflow
            TX_DMA_STA: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xb0);

        /// address: 0x450001c
        /// EMAC Transmit Flow Control Register
        pub const EMAC_TX_FLOW_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Flow Control Enable
            /// 0: Disable
            /// 1: Enable When set, enable flow control operation to transmit pause frames in
            /// full-duplex mode, or enable the back-pressure operation in half- duplex mode.
            TX_FLOW_CTL_EN: u1,
            /// 0: Disable
            /// 1: Enable When set, enable the functionality to generate the Zero-Quanta Pause
            /// control frame.
            ZQP_FRM_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// The pause time field in the transmitted control frame.
            PAUSE_TIME: u16,
            /// The threshold of the pause timer at which the input flow control signal is
            /// checked for automatic re-transmission of the pause frame. The threshold values
            /// should be always less than PAUSE_TIME.
            TX_PAUSE_FRM_SLOT: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// This bit indicates a pause frame transmission is in progress. When the
            /// configuration of flow control is ready, set this bit to transmit a pause frame
            /// in full-duplex mode or activate the backpressure function. After the
            /// transmission is completed, this bit will be cleared automatically. Before
            /// writing TX_FLOW_CTRL register, this bit must be read as 0.
            TX_FLOW_CTL_STA: u1,
        }), base_address + 0x1c);
    };

    /// SMHC0
    pub const SMHC0 = struct {
        pub const base_address = 0x4020000;

        /// address: 0x402010c
        /// eMMC4.5 DDR Start Bit Detection Control Register
        pub const EMMC_DDR_SBIT_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control for start bit detection mechanism inside mstorage based on duration of
            /// start bit. For eMMC 4.5, start bit can be:
            /// 0: Full cycle
            /// 1: Less than one full cycle Set HALF_START_BIT = 1 for eMMC 4.5 and above; set
            /// to 0 for SD applications.
            HALF_START_BIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// HS400 Mode Enable
            /// 0: Disabled
            /// 1: Enabled It is required to set this bit to '1' before initiating any data
            /// transfer CMD in HS400 mode.
            HS400_MD_EN: u1,
        }), base_address + 0x10c);

        /// address: 0x4020058
        /// Auto Command 12 Argument Register
        pub const SMHC_A12A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto CMD12 Argument The argument of command 12 automatically sent by the
            /// controller.
            SD_A12A: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x4020108
        /// Auto Command 23 Argument Register
        pub const SMHC_A23A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto CMD23 Argument The argument of command 23 is automatically sent by
            /// controller with this field.
            A23A: u32,
        }), base_address + 0x108);

        /// address: 0x4020010
        /// Block Size Register
        pub const SMHC_BLKSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Block Size
            BLK_SZ: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x4020014
        /// Byte Count Register
        pub const SMHC_BYTCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Byte counter The number of bytes to be transferred. It must be integer multiple
            /// of Block Size (BLK_SZ) for block transfers.
            BYTE_CNT: u32,
        }), base_address + 0x14);

        /// address: 0x4020004
        /// Clock Control Register
        pub const SMHC_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Clock Divider n: Source clock is divided by 2*n. (n = 0 to 255) When
            /// HS400_MD_EN is set, this field must be cleared.
            CCLK_DIV: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Card Clock Enable
            /// 0: Card Clock is off.
            /// 1: Card Clock is on.
            CCLK_ENB: u1,
            /// Card Clock Output Control
            /// 0: Card clock is always on.
            /// 1: Turn off card clock when FSM is in IDLE state.
            CCLK_CTRL: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// 0: Do not mask data0 when update clock
            /// 1: Mask data0 when update clock
            MASK_DATA0: u1,
        }), base_address + 0x4);

        /// address: 0x4020018
        /// Command Register
        pub const SMHC_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// CMD Index Command index value
            CMD_IDX: u6,
            /// Response Receive
            /// 0: Command without response
            /// 1: Command with response
            RESP_RCV: u1,
            /// Response Type
            /// 0: Short Response (48 bits)
            /// 1: Long Response (136 bits)
            LONG_RESP: u1,
            /// Check Response CRC
            /// 0: Do not check response CRC
            /// 1: Check response CRC
            CHK_RESP_CRC: u1,
            /// Data Transfer
            /// 0: Without data transfer
            /// 1: With data transfer
            DATA_TRANS: u1,
            /// Transfer Direction
            /// 0: Read operation
            /// 1: Write operation
            TRANS_DIR: u1,
            /// Transfer Mode
            /// 0: Block data transfer command
            /// 1: Stream data transfer command
            TRANS_MODE: u1,
            /// Send Stop CMD Automatically (CMD12)
            /// 0: Do not send stop command at the end of the data transfer.
            /// 1: Send stop command automatically at the end of the data transfer. If set, the
            /// SMHC_RESP1 will record the response of auto CMD12.
            STOP_CMD_FLAG: u1,
            /// Wait for Data Transfer Over
            /// 0: Send command at once, does not care about data transferring.
            /// 1: Wait for data transfer completion before sending the current command.
            WAIT_PRE_OVER: u1,
            /// Stop Abort Command
            /// 0: Normal command sending
            /// 1: Send or command to stop the current data transfer in progress. (CMD12, CMD52
            /// for writing “I/O Abort” in SDIO CCCR)
            STOP_ABT_CMD: u1,
            /// Send Initialization
            /// 0: Normal command sending
            /// 1: Send initialization sequence before sending this command.
            SEND_INIT_SEQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Change Clock
            /// 0: Normal command
            /// 1: Change Card Clock When this bit is set, the controller will change the clock
            /// domain and clock output. No commands will be sent.
            PRG_CLK: u1,
            reserved5: u1,
            reserved6: u1,
            /// Boot Mode
            /// 00: Normal command
            /// 01: Mandatory Boot operation
            /// 10: Alternate Boot operation
            /// 11: Reserved
            BOOT_MOD: u2,
            /// Expect Boot Acknowledge When the software sets this bit along in mandatory boot
            /// operation, the controller expects a boot acknowledge start pattern of 0-1-0 from
            /// the selected card.
            EXP_BOOT_ACK: u1,
            /// Boot Abort Setting this bit will terminate the boot operation.
            BOOT_ABT: u1,
            /// Voltage Switch
            /// 0: Normal command
            /// 1: Voltage switch command, set for CMD11 only.
            VOL_SW: u1,
            reserved7: u1,
            reserved8: u1,
            /// Start Command This bit is automatically cleared when the current command is
            /// sent. If there is no response error happens, a command complete interrupt bit
            /// (CMD_OVER) will be set in the interrupt register. Do not write any other
            /// commands until this bit is cleared.
            CMD_LOAD: u1,
        }), base_address + 0x18);

        /// address: 0x402001c
        /// Command Argument Register
        pub const SMHC_CMDARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMD_ARG: u32,
        }), base_address + 0x1c);

        /// address: 0x4020054
        /// CRC Status Detect Control Registers
        pub const SMHC_CSDC = @intToPtr(*volatile Mmio(32, packed struct {
            /// 110: HS400 speed mode
            /// 011: Other speed mode Others: Reserved
            CRC_DET_PARA: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x54);

        /// address: 0x4020000
        /// Control Register
        pub const SMHC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            /// 0: No effect
            /// 1: Reset SD/MMC controller This bit is auto-cleared after the completion of
            /// reset operation.
            SOFT_RST: u1,
            /// FIFO Reset
            /// 0: No effect
            /// 1: Reset the FIFO This bit is auto-cleared after the completion of the reset
            /// operation.
            FIFO_RST: u1,
            /// DMA Reset
            DMA_RST: u1,
            reserved0: u1,
            /// Global Interrupt Enable
            /// 0: Disable interrupts
            /// 1: Enable interrupts
            INT_ENB: u1,
            /// DMA Global Enable
            /// 0: Disable DMA to transfer data via AHB bus
            /// 1: Enable DMA to transfer data
            DMA_ENB: u1,
            reserved1: u1,
            reserved2: u1,
            /// Card Detect (Data[3] status) De-bounce Enable
            /// 0: Disable de-bounce
            /// 1: Enable de-bounce
            CD_DBC_ENB: u1,
            reserved3: u1,
            /// DDR Mode Select Although the HS400 speed mode of eMMC is 8-bit DDR, this field
            /// should be cleared when HS400_MD_EN is set.
            /// 0: SDR mode
            /// 1: DDR mode
            DDR_MOD_SEL: u1,
            /// Time unit for data line Time unit is used to calculate the data line time out
            /// value defined in DTO_LMT.
            /// 0: 1 card clock period
            /// 1: 256 card clock period
            TIME_UNIT_DAT: u1,
            /// Time unit for command line The time unit is used to calculate the command line
            /// time out value defined in RTO_LMT.
            /// 0: 1 card clock period
            /// 1: 256 card clock period
            TIME_UNIT_CMD: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// FIFO Access Mode
            /// 0: DMA bus
            /// 1: AHB bus
            FIFO_AC_MOD: u1,
        }), base_address + 0x0);

        /// address: 0x402000c
        /// Bus Width Register
        pub const SMHC_CTYPE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Width
            /// 00: 1-bit width
            /// 01: 4-bit width
            /// 1x: 8-bit width
            CARD_WID: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x4020084
        /// SMHC_DLBA_REG
        pub const SMHC_DLBA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start of Descriptor List Contains the base address of the First Descriptor. It
            /// is a word (4 Byte) address.
            DES_BASE_ADDR: u32,
        }), base_address + 0x84);

        /// address: 0x4020140
        /// Drive Delay Control Register
        pub const SMHC_DRV_DL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Command Drive Phase Select
            /// 0: Command drive phase offset is 90° at SDR mode, 45° at DDR8 mode, and 90°
            /// at DDR4 mode.
            /// 1: Command drive phase offset is 180° at SDR mode, 90° at DDR8 mode, and 180°
            /// at DDR4 mode.
            /// 0: Command drive phase offset is 90° at SDR mode and 45° at DDR mode.
            /// 1: Command drive phase offset is 180° at SDR mode and 90° at DDR mode.
            CMD_DRV_PH_SEL: u1,
            /// Data Drive Phase Select
            /// 0: Data drive phase offset is 90° at SDR mode, 45° at DDR8 mode, and 90° at
            /// DDR4 mode.
            /// 1: Data drive phase offset is 180° at SDR mode, 90° at DDR8 mode, and 0° at
            /// DDR4 mode.
            /// 0: Data drive phase offset is 90° at SDR mode, and 45° at DDR mode.
            /// 1: Data drive phase offset is 180° at SDR mode, and 90° at DDR mode.
            DAT_DRV_PH_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x140);

        /// address: 0x4020148
        /// Data Strobe Delay Control Register
        pub const SMHC_DS_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Strobe Delay Software
            DS_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable
            DS_DL_SW_EN: u1,
            /// Data Strobe Delay It indicates the number of delay cells corresponding to the
            /// current card clock. The delay time generated by these delay cells is equal to
            /// the cycle of SMHC’s clock nearly. This bit is valid only when SAMP_DL_CAL_DONE
            /// is set.
            DS_DL: u6,
            /// Data Strobe Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in DS_DL.
            DS_DL_CAL_DONE: u1,
            /// Data Strobe Delay Calibration Start When set, it means that start sample delay
            /// chain calibration.
            DS_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x148);

        /// address: 0x4020138
        /// Extended Command Register
        pub const SMHC_EXT_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send CMD23 Automatically When setting this bit, send CMD23 automatically before
            /// sending the command specified in the SMHC_CMD register. When SOFT_RST is set,
            /// this field will be cleared.
            AUTO_CMD23_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x138);

        /// address: 0x402013c
        /// Extended Response Register
        pub const SMHC_EXT_RESP = @intToPtr(*volatile u32, base_address + 0x13c);

        /// address: 0x4020200
        /// Read/Write FIFO
        pub const SMHC_FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data FIFO 8 Audio
            /// .......................................................................................................................................................................
            /// 646 8.1
            /// I2S/PCM...........................................................................................................................................................
            /// 646 8.1.1 Overview
            /// .............................................................................................................................................
            /// 646 8.1.2 Block Diagram
            /// .....................................................................................................................................
            /// 647 8.1.3 Functional Description
            /// ........................................................................................................................
            /// 648 8.1.4 Programming Guidelines
            /// .....................................................................................................................
            /// 655 8.1.5 Register List
            /// .........................................................................................................................................
            /// 657 8.1.6 Register Description
            /// ............................................................................................................................
            /// 658 8.2
            /// DMIC................................................................................................................................................................
            /// 706 8.2.1 Overview
            /// .............................................................................................................................................
            /// 706 8.2.2 Block Diagram
            /// .....................................................................................................................................
            /// 706 8.2.3 Functional Description
            /// ........................................................................................................................
            /// 706 8.2.4 Register List
            /// .........................................................................................................................................
            /// 709 8.2.5 Register Description
            /// ............................................................................................................................
            /// 709 8.3 OWA
            /// ................................................................................................................................................................
            /// 724 8.3.1 Overview
            /// .............................................................................................................................................
            /// 724 8.3.2 Block Diagram
            /// .....................................................................................................................................
            /// 725 8.3.3 Functional Description
            /// ........................................................................................................................
            /// 726 8.3.4 Register List
            /// .........................................................................................................................................
            /// 733 8.3.5 Register Description
            /// ............................................................................................................................
            /// 734 8.4 Audio Codec
            /// ....................................................................................................................................................
            /// 757 8.4.1 Overview
            /// .............................................................................................................................................
            /// 757 8.4.2 Block Diagram
            /// .....................................................................................................................................
            /// 758 8.4.3 Functional Description
            /// ........................................................................................................................
            /// 758 8.4.4 Programming Guidelines
            /// .....................................................................................................................
            /// 768 8.4.5 Register List
            /// .........................................................................................................................................
            /// 769 8.4.6 Register Description
            /// ............................................................................................................................
            /// 773 Figure 8-1 I2S/PCM Interface System Block Diagram
            /// .......................................................................................................
            /// 647 Figure 8-2 Typical Application of I2S/PCM Interface
            /// ........................................................................................................
            /// 647 Figure 8-3 I2S Standard Mode Timing
            /// ...............................................................................................................................
            /// 649 Figure 8-4 Left-Justified Mode Timing
            /// ..............................................................................................................................
            /// 650 Figure 8-5 Right-Justified Mode Timing
            /// ............................................................................................................................
            /// 650 Figure 8-6 PCM Long Frame Mode Timing
            /// ........................................................................................................................
            /// 650 Figure 8-7 PCM Short Frame Mode Timing
            /// .......................................................................................................................
            /// 651 Figure 8-8 16-Channel Mapping
            /// Configuration.................................................................................................................
            /// 651 Figure 8-9 Timing Requirements for Inputs
            /// ......................................................................................................................
            /// 653 Figure 8-10 Timing Requirements for Outputs
            /// .................................................................................................................
            /// 653 Figure 8-11 I2S/PCM Operation Flow
            /// ...............................................................................................................................
            /// 654 Figure 8-12 DMIC Block Diagram
            /// ......................................................................................................................................
            /// 706 Figure 8-13 DMIC Operation
            /// Mode...................................................................................................................................
            /// 708 Figure 8-14 OWA Block Diagram
            /// .......................................................................................................................................
            /// 725 Figure 8-15 OWA Biphase-Mark Code
            /// ..............................................................................................................................
            /// 727 Figure 8-16 OWA Sub-Frame Format
            /// ................................................................................................................................
            /// 728 Figure 8-17 OWA Frame/Block Format
            /// .............................................................................................................................
            /// 729 Figure 8-18 Data-Burst Format
            /// .........................................................................................................................................
            /// 730 Figure 8-19 Data-burst Preamble
            /// ......................................................................................................................................
            /// 730 Figure 8-20 Data-burst Preamble words
            /// ...........................................................................................................................
            /// 730 Figure 8-21 Fields of Burst-information
            /// ............................................................................................................................
            /// 731 Figure 8-22 Length of the Burst-Payload Specified by Pd
            /// .................................................................................................
            /// 731 Figure 8-23 OWA Operation Flow
            /// .....................................................................................................................................
            /// 732 Figure 8-24 Audio Codec Block Diagram
            /// ...........................................................................................................................
            /// 758 Figure 8-25 Audio Codec Clock Diagram
            /// ...........................................................................................................................
            /// 760 Figure 8-26 Audio Codec Digital Part Reset System
            /// ..........................................................................................................
            /// 761 Figure 8-27 Audio Codec Analog Part Reset System
            /// .........................................................................................................
            /// 761 Figure 8-28 Audio Codec Data Path Diagram
            /// ....................................................................................................................
            /// 762 Figure 8-29 Headphone Output Application
            /// .....................................................................................................................
            /// 764 Figure 8-30 Audio Codec Interrupt System
            /// .......................................................................................................................
            /// 764 Figure 8-31 DAP Data Flow
            /// ...............................................................................................................................................
            /// 765 Figure 8-32 HPF Logic Structure
            /// ........................................................................................................................................
            /// 765 Figure 8-33 DRC Block Diagram
            /// ........................................................................................................................................
            /// 765 Figure 8-34 DRC Static Curve Parameters
            /// .........................................................................................................................
            /// 766 Figure 8-35 Energy Filter Structure
            /// ...................................................................................................................................
            /// 766 Figure 8-36 Gain Smooth Filter
            /// .........................................................................................................................................
            /// 768 Table 8-1 I2S/PCM External Signals
            /// ..................................................................................................................................
            /// 648 Table 8-2 I2S/PCM Clock
            /// Sources......................................................................................................................................
            /// 648 Table 8-3 DIN Slot ID and Encoder
            /// ....................................................................................................................................
            /// 651 Table 8-4 Proper MCLK Values with Different Fsin and Fsout
            /// ..........................................................................................
            /// 653 Table 8-5 DMIC External Signals
            /// .......................................................................................................................................
            /// 707 Table 8-6 DMIC Clock
            /// Sources...........................................................................................................................................
            /// 707 Table 8-7 OWA Sub-blocks
            /// ................................................................................................................................................
            /// 725 Table 8-8 OWA External Signals
            /// ........................................................................................................................................
            /// 726 Table 8-9 OWA_TX Clock Sources
            /// .....................................................................................................................................
            /// 726 Table 8-10 OWA_RX Clock Sources
            /// ...................................................................................................................................
            /// 726 Table 8-11 Biphase-Mark Encoder
            /// ....................................................................................................................................
            /// 727 Table 8-12 Preamble Codes
            /// ..............................................................................................................................................
            /// 728 Table 8-13 Bit Allocation of Data-Burst in IEC 60958
            /// Subframes......................................................................................
            /// 729 Table 8-14 The Corresponding Relation between Different System Clock and
            /// Sample Ratio .......................................... 732 Table 8-15 Audio
            /// Codec External Signals
            /// ..........................................................................................................................
            /// 758
            @"TX/RX_FIFO": u32,
        }), base_address + 0x200);

        /// address: 0x4020040
        /// FIFO Water Level Register
        pub const SMHC_FIFOTH = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Trigger Level 0x1 to 0xFF: The TX trigger level is 1 to 255.
            /// 0x0: No trigger Indicates the FIFO threshold for the FIFO request host to
            /// transmit data to the FIFO. When the FIFO data level is less than or equal to
            /// this value, the DMA TX request is raised if DMA enabled, or TX request interrupt
            /// bit is set if interrupt enabled. At the end of the packet, if the last transfer
            /// is less than this level, the value is ignored and the relative request will be
            /// raised as usual. Recommended: 240 (means less than or equal to 240)
            TX_TL: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RX Trigger Level 0x0 to 0xFE: The RX trigger level is from 0 to 254.
            /// 0xFF: Reserved Indicates the FIFO threshold for the FIFO request host to receive
            /// data from the FIFO. When the FIFO data level is greater than this value, the DMA
            /// request is raised if DMA enabled, or the RX interrupt bit is set if interrupt
            /// enabled. At the end of the packet, if the last transfer is less than this level,
            /// the value is ignored and the relative request will be raised as usual.
            /// Recommended: 15 (means greater than 15)
            RX_TL: u8,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Burst Size of Multiple Transaction
            /// 000: 1 transfers
            /// 001: 4
            /// 010: 8
            /// 011: 16 Others: Reserved It should be programmed the same as the DMA controller
            /// multiple transaction size. The units for the transfer are the DWORD. A single
            /// transfer would be signaled based on this value. The value should be sub-multiple
            /// of (RX_TL + 1) and (FIFO_DEPTH - TX_TL) Recommended: FIFO_DEPTH = 256, FIFO_SIZE
            /// = 256 * 32 = 1K MSize = 16, TX_TL = 240, RX_TL = 15
            BSIZE_OF_TRANS: u3,
            padding0: u1,
        }), base_address + 0x40);

        /// address: 0x4020044
        /// FIFO Function Select Register
        pub const SMHC_FUNS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host Send MMC IRQ Response
            /// 0: Ignored
            /// 1: Send auto IRQ response When the host is waiting for the MMC card interrupt
            /// response, setting this bit will make the controller cancel the waiting state and
            /// return to the idle state, at which time, the controller will receive the IRQ
            /// response sent by itself. This bit is auto-cleared after the response is sent.
            HOST_SEND_MMC_IRQRESQ: u1,
            /// Read Wait
            /// 0: Clear SDIO read wait
            /// 1: Assert SDIO read wait
            READ_WAIT: u1,
            /// Abort Read Data
            /// 0: Ignored
            /// 1: After the suspend command is issued during the read- transfer, the software
            /// polls card to find when the suspend happens. Once the suspend occurs, the
            /// software sets the bit to reset the data state-machine, which is waiting for the
            /// next block of data. This bit is used in the SDIO card suspends sequence and is
            /// auto- cleared once the controller resets to the idle state.
            ABT_RDATA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x44);

        /// address: 0x402014c
        /// HS400 Delay Control Register
        pub const SMHC_HS400_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// HS400 Delay Software
            HS400_DL_SW: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Sample Delay Software Enable
            HS400_DL_SW_EN: u1,
            /// HS400 Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the SMHC clock nearly. This bit is valid only when HS400_DL_CAL_DONE is set.
            HS400_DL: u4,
            reserved3: u1,
            reserved4: u1,
            /// HS400 Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in HS400_DL.
            HS400_DL_CAL_DONE: u1,
            /// HS400 Delay Calibration Start When set, it means that start sample delay chain
            /// calibration.
            HS400_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14c);

        /// address: 0x4020078
        /// Hardware Reset Register
        pub const SMHC_HWRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Active mode
            /// 0: Reset These bits cause the cards to enter the pre-idle state, which requires
            /// them to be re-initialized.
            HW_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x78);

        /// address: 0x402008c
        /// SMHC_IDIE_REG
        pub const SMHC_IDIE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt Enable. When set with Normal Interrupt Summary Enable,
            /// Transmit Interrupt is enabled. When reset, the Transmit Interrupt is disabled.
            TX_INT_ENB: u1,
            /// Receive Interrupt Enable. When set with Normal Interrupt Summary Enable, Receive
            /// Interrupt is enabled. When reset, the Receive Interrupt is disabled.
            RX_INT_ENB: u1,
            /// Fatal Bus Error Enable When set with Abnormal Interrupt Summary Enable, the
            /// Fatal Bus Error Interrupt is enabled. When reset, the Fatal Bus Error Enable
            /// Interrupt is disabled.
            FERR_INT_ENB: u1,
            reserved0: u1,
            /// Descriptor Unavailable Interrupt. When set along with Abnormal Interrupt Summary
            /// Enable, the Descriptor Unavailable Interrupt is enabled.
            DES_UNAVL_INT_ENB: u1,
            /// Card Error Summary Interrupt Enable. When set, it enables the Card Interrupt
            /// Summary.
            ERR_SUM_INT_ENB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8c);

        /// address: 0x4020080
        /// IDMAC Control Register
        pub const SMHC_IDMAC = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Reset When set, the DMA Controller resets all its internal registers. It is
            /// automatically cleared after 1 clock cycle.
            IDMAC_RST: u1,
            /// Fixed Burst Controls whether the AHB Master interface performs fixed burst
            /// transfers or not. When set, the AHB will use only SINGLE, INCR4, and INCR8
            /// during the start of normal burst transfers. When reset, the AHB will use SINGLE
            /// and INCR burst transfer operations.
            FIX_BUST_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// IDMAC Enable When set, the IDMAC is enabled.
            IDMAC_ENB: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// When IDMAC fetches a descriptor, if the valid bit of a descriptor is not set,
            /// IDMAC FSM will go to the suspend state. Setting this bit will make the IDMAC
            /// refetch descriptor again and do the transfer normally.
            DES_LOAD_CTRL: u1,
        }), base_address + 0x80);

        /// address: 0x4020088
        /// SMHC_IDST_REG
        pub const SMHC_IDST_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt Indicates that data transmission is finished for a
            /// descriptor. Writing 1 clears this bit.
            TX_INT: u1,
            /// Receive Interrupt Indicates the completion of data reception for a descriptor.
            /// Writing 1 clears this bit.
            RX_INT: u1,
            /// Fatal Bus Error Interrupt Indicates that a Bus Error occurred (IDST[12:10]).
            /// When this bit is set, the DMA disables all its bus accesses. Writing 1 clears
            /// this bit.
            FATAL_BERR_INT: u1,
            reserved0: u1,
            /// Descriptor Unavailable Interrupt This bit is set when the descriptor is
            /// unavailable due to OWN bit = 0 (DES0[31] =0). Writing 1 clears this bit.
            DES_UNAVL_INT: u1,
            /// Card Error Summary Indicates the status of the transaction to/from the card;
            /// also present in RINTSTS. Indicates the logical OR of the following bits:
            /// EBE: End Bit Error RTO: Response Timeout RCRC: Response CRC SBE: Start Bit Error
            /// DRTO: Data Read Timeout DCRC: Data CRC for Receive RE: Response Error Writing 1
            /// clears this bit.
            ERR_FLAG_SUM: u1,
            reserved1: u1,
            reserved2: u1,
            /// (NIS) Normal Interrupt Summary Logical OR of the following: IDST[0]: Transmit
            /// Interrupt IDST[1]: Receive Interrupt Only unmasked bits affect this bit. This is
            /// a sticky bit and must be cleared each time a corresponding bit that causes NIS
            /// to be set is cleared.
            NOR_INT_SUM: u1,
            /// (AIS) Abnormal Interrupt Summary Logical OR of the following: IDST[2]: Fatal Bus
            /// Interrupt IDST[4]: Descriptor Unavailable Bit Interrupt IDST[5]: Card Error
            /// Summary Interrupt Only unmasked bits affect this bit. This is a sticky bit and
            /// must be cleared each time a corresponding bit that causes AIS to be set is
            /// cleared.
            ABN_INT_SUM: u1,
            /// Error Bits Indicates the type of error that caused a Bus Error. Valid only with
            /// Fatal Bus Error bit (IDST[2]) set. This field does not generate an interrupt.
            /// 001: Host Abort received during the transmission.
            /// 010: Host Abort received during the reception. Others: Reserved
            IDMAC_ERR_STA: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x88);

        /// address: 0x4020030
        /// Interrupt Mask Register
        pub const SMHC_INTMASK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error Interrupt Enable
            RE_INT_EN: u1,
            /// Command Complete Interrupt Enable
            CC_INT_EN: u1,
            /// Data Transfer Complete Interrupt Enable
            DTC_INT_EN: u1,
            /// Data Transmit Request Interrupt Enable
            DTR_INT_EN: u1,
            /// Data Receive Request Interrupt Enable
            DRR_INT_EN: u1,
            /// Response CRC Error Interrupt Enable
            RCE_INT_EN: u1,
            /// Data CRC Error Interrupt Enable
            DCE_INT_EN: u1,
            /// Response Timeout/Boot ACK Received Interrupt Enable
            RTO_BACK_INT_EN: u1,
            /// Data Timeout/Boot Data Start Interrupt Enable
            DTO_BDS_INT_EN: u1,
            /// Data Starvation Timeout/V1.8 Switch Done Interrupt Enable
            DSTO_VSD_INT_EN: u1,
            /// FIFO Underrun/Overflow Interrupt Enable
            FU_FO_INT_EN: u1,
            /// Command Busy and Illegal Write Interrupt Enable
            CB_IW_INT_EN: u1,
            /// Data Start Error Interrupt Enable
            DSE_BC_INT_EN: u1,
            /// Auto Command Done Interrupt Enable
            ACD_INT_EN: u1,
            /// Data End-bit Error Interrupt Enable
            DEE_INT_EN: u1,
            /// SDIO Interrupt Enable
            SDIO_INT_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted Interrupt Enable
            CARD_INSERT_INT_EN: u1,
            /// Card Removed Interrupt Enable
            CARD_REMOVAL_INT_EN: u1,
        }), base_address + 0x30);

        /// address: 0x4020034
        /// Masked Interrupt Status Register
        pub const SMHC_MINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error When set, Transmit Bit error or End Bit error or CMD Index error
            /// may occurs.
            M_RE_INT: u1,
            /// Command Complete
            M_CC_INT: u1,
            /// Data Transfer Complete
            M_DTC_INT: u1,
            /// Data Transmit Request When set, it means that there is enough space in FIFO
            /// during transmitting data.
            M_DTR_INT: u1,
            /// Data Receive Request When set, it means that there are enough data in FIFO
            /// during receiving data.
            M_DRR_INT: u1,
            /// Response CRC Error
            M_RCE_INT: u1,
            /// Data CRC Error When the bit is set during receiving data, it means that the
            /// received data have data CRC error. When the bit is set during transmitting data,
            /// it means that the received CRC status taken is negative.
            M_DCE_INT: u1,
            /// Response Timeout/Boot ACK Received
            M_RTO_BACK_INT: u1,
            /// Data Timeout/Boot Data Start
            M_DTO_BDS_INT: u1,
            /// Data Starvation Timeout/V1.8 Switch Done
            M_DSTO_VSD_INT: u1,
            /// FIFO Underrun/Overflow
            M_FU_FO_INT: u1,
            /// Command Busy and Illegal Write
            M_CB_IW_INT: u1,
            /// Data Start Error/Busy Clear When set during receiving data, it means that the
            /// host controller found an error start bit. When the bit is set during
            /// transmitting data, it means that the busy signal is cleared after the last
            /// block.
            M_DSE_BC_INT: u1,
            /// Auto Command Done When set, it means auto-stop command (CMD12) completed.
            M_ACD_INT: u1,
            /// Data End-bit Error When the bit is set during receiving data, it means that the
            /// host controller does not receive the valid data end bit. When the bit is set
            /// during transmitting data, it means that the host controller does not receive the
            /// CRC status token. This is a write-1-to-clear bit.
            M_DEE_INT: u1,
            /// SDIO Interrupt
            M_SDIO_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted
            M_CARD_INSERT: u1,
            /// Card Removed
            M_CARD_REMOVAL_INT: u1,
        }), base_address + 0x34);

        /// address: 0x402005c
        /// SD New Timing Set Register
        pub const SMHC_NTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable hs400 new sample method
            /// 1: Enable hs400 new sample method
            HS400_NEW_SAMPLE_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// 00: Sample timing phase offset 90
            /// 01: Sample timing phase offset 180
            /// 10: Sample timing phase offset 270
            /// 11: Ignore
            CMD_SAMPLE_TIMING_PHASE: u2,
            reserved3: u1,
            reserved4: u1,
            /// 00: Sample timing phase offset 90
            /// 01: Sample timing phase offset 180
            /// 10: Sample timing phase offset 270
            /// 11: Sample timing phase offset 0 (only for SD2 hs400 mode)
            DAT_SAMPLE_TIMING_PHASE: u2,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Clear command rx phase before sending the command.
            /// 0: Disabled
            /// 1: Enabled
            CMD_SEND_RX_PHASE_CLR: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the input phase of data lines before receiving the data.
            /// 0: Disabled
            /// 1: Enabled
            DAT_RECV_RX_PHASE_CLR: u1,
            /// Clear the input phase of data lines before transferring the data.
            /// 0: Disabled
            /// 1: Enabled
            DAT_TRANS_RX_PHASE_CLR: u1,
            /// Clear the input phase of data lines before receiving the CRC status.
            /// 0: Disabled
            /// 1: Enabled
            DAT_CRC_STATUS_RX_PHASE_CLR: u1,
            reserved14: u1,
            /// Clear the input phase of command lines and data lines during the update clock
            /// operation.
            /// 0: Disabled
            /// 1: Enabled
            CMD_DAT_RX_PHASE_CLR: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// 0: Old mode of Sample/Output Timing
            /// 1: New mode of Sample/Output Timing
            MODE_SELECT: u1,
        }), base_address + 0x5c);

        /// address: 0x4020020
        /// Response 0 Register
        pub const SMHC_RESP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 0 Bit[31:0] of response
            CMD_RESP0: u32,
        }), base_address + 0x20);

        /// address: 0x4020024
        /// Response 1 Register
        pub const SMHC_RESP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 1 Bit[63:31] of response
            CMD_RESP1: u32,
        }), base_address + 0x24);

        /// address: 0x4020028
        /// Response 2 Register
        pub const SMHC_RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 2 Bit[95:64] of response
            CMD_RESP2: u32,
        }), base_address + 0x28);

        /// address: 0x402002c
        /// Response 3 Register
        pub const SMHC_RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 3 Bit[127:96] of response
            CMD_RESP3: u32,
        }), base_address + 0x2c);

        /// address: 0x4020038
        /// Raw Interrupt Status Register
        pub const SMHC_RINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error When set, it means that the transmit bit error, end bit error, or
            /// CMD index error may occur. Write 1 to clear this bit.
            RE: u1,
            /// Command Complete When set, it means that the current command completes even
            /// through error occurs. Write 1 to clear this bit.
            CC: u1,
            /// Data Transfer Complete When set, it means that the current command completes
            /// even through error occurs. Write 1 to clear this bit.
            DTC: u1,
            /// Data Transmit Request When set, it means that there is enough space in FIFO
            /// during transmitting data. Write 1 to clear this bit.
            DTR: u1,
            /// Data Receive Request When set, it means that there are enough data in FIFO
            /// during receiving data. Write 1 to clear this bit.
            DRR: u1,
            /// Response CRC Error Write 1 to clear this bit.
            RCE: u1,
            /// Data CRC Error When the bit is set during receiving data, it means that the
            /// received data have data CRC error. When the bit is set during transmitting data,
            /// it means that the received CRC status taken is negative. Write 1 to clear this
            /// bit.
            DCE: u1,
            /// Response Timeout/Boot ACK Received Write 1 to clear this bit.
            RTO_BACK: u1,
            /// Data Timeout/Boot Data Start When the bit is set during receiving data, it means
            /// that some of the channel of DATA[3:0] lack of the start bit. Write 1 to clear
            /// this bit.
            DTO_BDS: u1,
            /// Data Starvation Timeout/V1.8 Switch Done Write 1 to clear this bit.
            DSTO_VSD: u1,
            /// FIFO Underrun/Overflow Write 1 to clear this bit.
            FU_FO: u1,
            /// Command Busy and Illegal Write Write 1 to clear this bit.
            CB_IW: u1,
            /// Data Start Error/Busy Clear When the bit is set during receiving data, it means
            /// that the host controller found an error start bit. When the bit is set during
            /// transmitting data, it means that the busy signal is cleared after the last
            /// block. Write 1 to clear this bit.
            DSE_BC: u1,
            /// Auto Command Done When set, it means that the auto-stop command (CMD12) is
            /// completed. Write 1 to clear this bit.
            ACD: u1,
            /// Data End-bit Error When the bit is set during receiving data, it means that the
            /// host controller does not receive the valid data end bit. When the bit is set
            /// during transmitting data, it means that the host controller does not receive the
            /// CRC status token. Write 1 to clear this bit.
            DEE: u1,
            /// SDIO Interrupt Write 1 to clear this bit.
            SDIOI_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted Write 1 to clear this bit.
            CARD_INSERT: u1,
            /// Card Removed Write 1 to clear this bit.
            CARD_REMOVAL: u1,
        }), base_address + 0x38);

        /// address: 0x4020144
        /// SMHC_SAMP_DL
        pub const SMHC_SAMP_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Delay Software The relative delay between the clock line and command
            /// line, data line. It can be determined according to the value of SAMP_DL, the
            /// cycle of the card clock and the input timing requirement of the device.
            SAMP_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable When set, it means that enable the sample delay
            /// specified at SAMP_DL_SW.
            SAMP_DL_SW_EN: u1,
            /// Sample Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the card clock nearly. Generally, it is necessary to do drive delay
            /// calibration when the card clock is changed. This bit is valid only when
            /// SAMP_DL_CAL_DONE is set.
            SAMP_DL: u6,
            /// Sample Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in SAMP_DL.
            SAMP_DL_CAL_DONE: u1,
            /// Sample Delay Calibration Start When set, it means that start sample delay chain
            /// calibration.
            SAMP_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x144);

        /// address: 0x4020104
        /// Sample FIFO Control Register
        pub const SMHC_SFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bypass enable When set, sample FIFO will be bypassed.
            BYPASS_EN: u1,
            /// Stop Clock Control When receiving data, if CARD_RD_THLD_ENB is set and
            /// CARD_RD_THLD is set the same with BLK_SZ, the device clock may stop at the block
            /// gap during data receiving. This field is used to control the position of the
            /// stopping clock. The value can be changed between 0x0 and 0xF, but actually, the
            /// available value and the position of the stopping clock must be decided by the
            /// actual situation. The value increases one in this field is linked to one cycle
            /// (two cycles in DDR mode) that the position of the stopping clock moved up.
            STOP_CLK_CTRL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x104);

        /// address: 0x402003c
        /// Status Register
        pub const SMHC_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO RX Water Level Flag
            /// 0: FIFO does not reach the receive trigger level.
            /// 1: FIFO reaches the receive trigger level.
            FIFO_RX_LEVEL: u1,
            /// FIFO TX Water Level Flag
            /// 0: FIFO does not reach the transmit trigger level
            /// 1: FIFO reaches the transmit trigger level
            FIFO_TX_LEVEL: u1,
            /// FIFO Empty
            /// 0: FIFO is not empty
            /// 1: FIFO is empty
            FIFO_EMPTY: u1,
            /// FIFO Full
            /// 0: FIFO is not full
            /// 1: FIFO is full
            FIFO_FULL: u1,
            /// Command FSM States
            /// 0000: Idle
            /// 0001: Send init sequence
            /// 0010: TX CMD start bit
            /// 0011: TX CMD TX bit
            /// 0100: TX CMD index + argument
            /// 0101: TX CMD CRC7
            /// 0110: TX CMD end bit
            /// 0111: RX response start bit
            /// 1000: RX response IRQ response
            /// 1001: RX response TX bit
            /// 1010: RX response CMD index
            /// 1011: RX response data
            /// 1100: RX response CRC7
            /// 1101: RX response end bit
            /// 1110: CMD path wait NCC
            /// 1111: Wait; CMD-to-response turn around
            FSM_STA: u4,
            /// Data[3] Status The level of DATA[3], checks whether the card is present.
            /// 0: The card is not present.
            /// 1: The card is present.
            CARD_PRESENT: u1,
            /// Card Data Busy Inverted version of DATA[0]
            /// 0: Card data is not busy.
            /// 1: Card data is busy.
            CARD_BUSY: u1,
            /// Data FSM Busy Data transmit or receive state-machine is busy.
            FSM_BUSY: u1,
            /// Response Index Index of previous response, including any auto-stop sent by the
            /// controller.
            RESP_IDX: u6,
            /// FIFO Level Number of filled locations in FIFO
            FIFO_LEVEL: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DMA Request DMA request signal state
            DMA_REQ: u1,
        }), base_address + 0x3c);

        /// address: 0x4020048
        /// SMHC_TBC0
        pub const SMHC_TBC0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transferred Count 0 The number of bytes transferred between the card and
            /// internal FIFO. The register should be accessed in full to avoid read-coherency
            /// problems and read only after the data transfer completes.
            TBC0: u32,
        }), base_address + 0x48);

        /// address: 0x402004c
        /// SMHC_TBC1
        pub const SMHC_TBC1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transferred Count 1 The number of bytes transferred between the Host/DMA memory
            /// and internal FIFO. The register should be accessed in full to avoid
            /// read-coherency problems and read only after the data transfer completes.
            TBC1: u32,
        }), base_address + 0x4c);

        /// address: 0x4020100
        /// Card Threshold Control Register
        pub const SMHC_THLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Read Threshold Enable
            /// 0: Card read threshold disabled
            /// 1: Card read threshold enabled Host controller initiates Read Transfer only if
            /// the CARD_RD_THLD amount of space is available in receive FIFO.
            CARD_RD_THLD_ENB: u1,
            /// Busy Clear Interrupt Generation
            /// 0: Busy clear interrupt disabled
            /// 1: Busy clear interrupt enabled The application can disable this feature if it
            /// does not want to wait for a Busy Clear Interrupt.
            BCIG: u1,
            /// Card Write Threshold Enable
            /// 0: Card write threshold disabled
            /// 1: Card write threshold enabled Host controller initiates write transfer only if
            /// the card threshold amount of data is available in transmit FIFO.
            CARD_WR_THLD_ENB: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Card Read/Write Threshold Size
            CARD_WR_THLD: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x100);

        /// address: 0x4020008
        /// Time Out Register
        pub const SMHC_TMOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response Timeout Limit
            RTO_LMT: u8,
            /// Data Timeout Limit This field can set the time that the host waits for the data
            /// from the device. Ensure to communicate with the device, this field must be set
            /// to the maximum that is greater than the time . About the , the explanation is as
            /// follows: When Host read data, data transmission from the Device starts after the
            /// access time delay beginning from the end bit of the read command (ACMD51, CMD8,
            /// CMD17, and CMD18). When the host reads multiple block (CMD18), a next block’s
            /// data transmission from the Device starts after the access time delay beginning
            /// from the end bit of the previous block. When the host writes data, the value is
            /// no effect.
            DTO_LMT: u24,
        }), base_address + 0x8);
    };

    /// SMHC1
    pub const SMHC1 = struct {
        pub const base_address = 0x4021000;

        /// address: 0x402110c
        /// eMMC4.5 DDR Start Bit Detection Control Register
        pub const EMMC_DDR_SBIT_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control for start bit detection mechanism inside mstorage based on duration of
            /// start bit. For eMMC 4.5, start bit can be:
            /// 0: Full cycle
            /// 1: Less than one full cycle Set HALF_START_BIT = 1 for eMMC 4.5 and above; set
            /// to 0 for SD applications.
            HALF_START_BIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// HS400 Mode Enable
            /// 0: Disabled
            /// 1: Enabled It is required to set this bit to '1' before initiating any data
            /// transfer CMD in HS400 mode.
            HS400_MD_EN: u1,
        }), base_address + 0x10c);

        /// address: 0x4021058
        /// Auto Command 12 Argument Register
        pub const SMHC_A12A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto CMD12 Argument The argument of command 12 automatically sent by the
            /// controller.
            SD_A12A: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x4021108
        /// Auto Command 23 Argument Register
        pub const SMHC_A23A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto CMD23 Argument The argument of command 23 is automatically sent by
            /// controller with this field.
            A23A: u32,
        }), base_address + 0x108);

        /// address: 0x4021010
        /// Block Size Register
        pub const SMHC_BLKSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Block Size
            BLK_SZ: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x4021014
        /// Byte Count Register
        pub const SMHC_BYTCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Byte counter The number of bytes to be transferred. It must be integer multiple
            /// of Block Size (BLK_SZ) for block transfers.
            BYTE_CNT: u32,
        }), base_address + 0x14);

        /// address: 0x4021004
        /// Clock Control Register
        pub const SMHC_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Clock Divider n: Source clock is divided by 2*n. (n = 0 to 255) When
            /// HS400_MD_EN is set, this field must be cleared.
            CCLK_DIV: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Card Clock Enable
            /// 0: Card Clock is off.
            /// 1: Card Clock is on.
            CCLK_ENB: u1,
            /// Card Clock Output Control
            /// 0: Card clock is always on.
            /// 1: Turn off card clock when FSM is in IDLE state.
            CCLK_CTRL: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// 0: Do not mask data0 when update clock
            /// 1: Mask data0 when update clock
            MASK_DATA0: u1,
        }), base_address + 0x4);

        /// address: 0x4021018
        /// Command Register
        pub const SMHC_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// CMD Index Command index value
            CMD_IDX: u6,
            /// Response Receive
            /// 0: Command without response
            /// 1: Command with response
            RESP_RCV: u1,
            /// Response Type
            /// 0: Short Response (48 bits)
            /// 1: Long Response (136 bits)
            LONG_RESP: u1,
            /// Check Response CRC
            /// 0: Do not check response CRC
            /// 1: Check response CRC
            CHK_RESP_CRC: u1,
            /// Data Transfer
            /// 0: Without data transfer
            /// 1: With data transfer
            DATA_TRANS: u1,
            /// Transfer Direction
            /// 0: Read operation
            /// 1: Write operation
            TRANS_DIR: u1,
            /// Transfer Mode
            /// 0: Block data transfer command
            /// 1: Stream data transfer command
            TRANS_MODE: u1,
            /// Send Stop CMD Automatically (CMD12)
            /// 0: Do not send stop command at the end of the data transfer.
            /// 1: Send stop command automatically at the end of the data transfer. If set, the
            /// SMHC_RESP1 will record the response of auto CMD12.
            STOP_CMD_FLAG: u1,
            /// Wait for Data Transfer Over
            /// 0: Send command at once, does not care about data transferring.
            /// 1: Wait for data transfer completion before sending the current command.
            WAIT_PRE_OVER: u1,
            /// Stop Abort Command
            /// 0: Normal command sending
            /// 1: Send or command to stop the current data transfer in progress. (CMD12, CMD52
            /// for writing “I/O Abort” in SDIO CCCR)
            STOP_ABT_CMD: u1,
            /// Send Initialization
            /// 0: Normal command sending
            /// 1: Send initialization sequence before sending this command.
            SEND_INIT_SEQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Change Clock
            /// 0: Normal command
            /// 1: Change Card Clock When this bit is set, the controller will change the clock
            /// domain and clock output. No commands will be sent.
            PRG_CLK: u1,
            reserved5: u1,
            reserved6: u1,
            /// Boot Mode
            /// 00: Normal command
            /// 01: Mandatory Boot operation
            /// 10: Alternate Boot operation
            /// 11: Reserved
            BOOT_MOD: u2,
            /// Expect Boot Acknowledge When the software sets this bit along in mandatory boot
            /// operation, the controller expects a boot acknowledge start pattern of 0-1-0 from
            /// the selected card.
            EXP_BOOT_ACK: u1,
            /// Boot Abort Setting this bit will terminate the boot operation.
            BOOT_ABT: u1,
            /// Voltage Switch
            /// 0: Normal command
            /// 1: Voltage switch command, set for CMD11 only.
            VOL_SW: u1,
            reserved7: u1,
            reserved8: u1,
            /// Start Command This bit is automatically cleared when the current command is
            /// sent. If there is no response error happens, a command complete interrupt bit
            /// (CMD_OVER) will be set in the interrupt register. Do not write any other
            /// commands until this bit is cleared.
            CMD_LOAD: u1,
        }), base_address + 0x18);

        /// address: 0x402101c
        /// Command Argument Register
        pub const SMHC_CMDARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMD_ARG: u32,
        }), base_address + 0x1c);

        /// address: 0x4021054
        /// CRC Status Detect Control Registers
        pub const SMHC_CSDC = @intToPtr(*volatile Mmio(32, packed struct {
            /// 110: HS400 speed mode
            /// 011: Other speed mode Others: Reserved
            CRC_DET_PARA: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x54);

        /// address: 0x4021000
        /// Control Register
        pub const SMHC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            /// 0: No effect
            /// 1: Reset SD/MMC controller This bit is auto-cleared after the completion of
            /// reset operation.
            SOFT_RST: u1,
            /// FIFO Reset
            /// 0: No effect
            /// 1: Reset the FIFO This bit is auto-cleared after the completion of the reset
            /// operation.
            FIFO_RST: u1,
            /// DMA Reset
            DMA_RST: u1,
            reserved0: u1,
            /// Global Interrupt Enable
            /// 0: Disable interrupts
            /// 1: Enable interrupts
            INT_ENB: u1,
            /// DMA Global Enable
            /// 0: Disable DMA to transfer data via AHB bus
            /// 1: Enable DMA to transfer data
            DMA_ENB: u1,
            reserved1: u1,
            reserved2: u1,
            /// Card Detect (Data[3] status) De-bounce Enable
            /// 0: Disable de-bounce
            /// 1: Enable de-bounce
            CD_DBC_ENB: u1,
            reserved3: u1,
            /// DDR Mode Select Although the HS400 speed mode of eMMC is 8-bit DDR, this field
            /// should be cleared when HS400_MD_EN is set.
            /// 0: SDR mode
            /// 1: DDR mode
            DDR_MOD_SEL: u1,
            /// Time unit for data line Time unit is used to calculate the data line time out
            /// value defined in DTO_LMT.
            /// 0: 1 card clock period
            /// 1: 256 card clock period
            TIME_UNIT_DAT: u1,
            /// Time unit for command line The time unit is used to calculate the command line
            /// time out value defined in RTO_LMT.
            /// 0: 1 card clock period
            /// 1: 256 card clock period
            TIME_UNIT_CMD: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// FIFO Access Mode
            /// 0: DMA bus
            /// 1: AHB bus
            FIFO_AC_MOD: u1,
        }), base_address + 0x0);

        /// address: 0x402100c
        /// Bus Width Register
        pub const SMHC_CTYPE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Width
            /// 00: 1-bit width
            /// 01: 4-bit width
            /// 1x: 8-bit width
            CARD_WID: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x4021084
        /// SMHC_DLBA_REG
        pub const SMHC_DLBA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start of Descriptor List Contains the base address of the First Descriptor. It
            /// is a word (4 Byte) address.
            DES_BASE_ADDR: u32,
        }), base_address + 0x84);

        /// address: 0x4021140
        /// Drive Delay Control Register
        pub const SMHC_DRV_DL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Command Drive Phase Select
            /// 0: Command drive phase offset is 90° at SDR mode, 45° at DDR8 mode, and 90°
            /// at DDR4 mode.
            /// 1: Command drive phase offset is 180° at SDR mode, 90° at DDR8 mode, and 180°
            /// at DDR4 mode.
            /// 0: Command drive phase offset is 90° at SDR mode and 45° at DDR mode.
            /// 1: Command drive phase offset is 180° at SDR mode and 90° at DDR mode.
            CMD_DRV_PH_SEL: u1,
            /// Data Drive Phase Select
            /// 0: Data drive phase offset is 90° at SDR mode, 45° at DDR8 mode, and 90° at
            /// DDR4 mode.
            /// 1: Data drive phase offset is 180° at SDR mode, 90° at DDR8 mode, and 0° at
            /// DDR4 mode.
            /// 0: Data drive phase offset is 90° at SDR mode, and 45° at DDR mode.
            /// 1: Data drive phase offset is 180° at SDR mode, and 90° at DDR mode.
            DAT_DRV_PH_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x140);

        /// address: 0x4021148
        /// Data Strobe Delay Control Register
        pub const SMHC_DS_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Strobe Delay Software
            DS_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable
            DS_DL_SW_EN: u1,
            /// Data Strobe Delay It indicates the number of delay cells corresponding to the
            /// current card clock. The delay time generated by these delay cells is equal to
            /// the cycle of SMHC’s clock nearly. This bit is valid only when SAMP_DL_CAL_DONE
            /// is set.
            DS_DL: u6,
            /// Data Strobe Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in DS_DL.
            DS_DL_CAL_DONE: u1,
            /// Data Strobe Delay Calibration Start When set, it means that start sample delay
            /// chain calibration.
            DS_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x148);

        /// address: 0x4021138
        /// Extended Command Register
        pub const SMHC_EXT_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send CMD23 Automatically When setting this bit, send CMD23 automatically before
            /// sending the command specified in the SMHC_CMD register. When SOFT_RST is set,
            /// this field will be cleared.
            AUTO_CMD23_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x138);

        /// address: 0x402113c
        /// Extended Response Register
        pub const SMHC_EXT_RESP = @intToPtr(*volatile u32, base_address + 0x13c);

        /// address: 0x4021200
        /// Read/Write FIFO
        pub const SMHC_FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data FIFO 8 Audio
            /// .......................................................................................................................................................................
            /// 646 8.1
            /// I2S/PCM...........................................................................................................................................................
            /// 646 8.1.1 Overview
            /// .............................................................................................................................................
            /// 646 8.1.2 Block Diagram
            /// .....................................................................................................................................
            /// 647 8.1.3 Functional Description
            /// ........................................................................................................................
            /// 648 8.1.4 Programming Guidelines
            /// .....................................................................................................................
            /// 655 8.1.5 Register List
            /// .........................................................................................................................................
            /// 657 8.1.6 Register Description
            /// ............................................................................................................................
            /// 658 8.2
            /// DMIC................................................................................................................................................................
            /// 706 8.2.1 Overview
            /// .............................................................................................................................................
            /// 706 8.2.2 Block Diagram
            /// .....................................................................................................................................
            /// 706 8.2.3 Functional Description
            /// ........................................................................................................................
            /// 706 8.2.4 Register List
            /// .........................................................................................................................................
            /// 709 8.2.5 Register Description
            /// ............................................................................................................................
            /// 709 8.3 OWA
            /// ................................................................................................................................................................
            /// 724 8.3.1 Overview
            /// .............................................................................................................................................
            /// 724 8.3.2 Block Diagram
            /// .....................................................................................................................................
            /// 725 8.3.3 Functional Description
            /// ........................................................................................................................
            /// 726 8.3.4 Register List
            /// .........................................................................................................................................
            /// 733 8.3.5 Register Description
            /// ............................................................................................................................
            /// 734 8.4 Audio Codec
            /// ....................................................................................................................................................
            /// 757 8.4.1 Overview
            /// .............................................................................................................................................
            /// 757 8.4.2 Block Diagram
            /// .....................................................................................................................................
            /// 758 8.4.3 Functional Description
            /// ........................................................................................................................
            /// 758 8.4.4 Programming Guidelines
            /// .....................................................................................................................
            /// 768 8.4.5 Register List
            /// .........................................................................................................................................
            /// 769 8.4.6 Register Description
            /// ............................................................................................................................
            /// 773 Figure 8-1 I2S/PCM Interface System Block Diagram
            /// .......................................................................................................
            /// 647 Figure 8-2 Typical Application of I2S/PCM Interface
            /// ........................................................................................................
            /// 647 Figure 8-3 I2S Standard Mode Timing
            /// ...............................................................................................................................
            /// 649 Figure 8-4 Left-Justified Mode Timing
            /// ..............................................................................................................................
            /// 650 Figure 8-5 Right-Justified Mode Timing
            /// ............................................................................................................................
            /// 650 Figure 8-6 PCM Long Frame Mode Timing
            /// ........................................................................................................................
            /// 650 Figure 8-7 PCM Short Frame Mode Timing
            /// .......................................................................................................................
            /// 651 Figure 8-8 16-Channel Mapping
            /// Configuration.................................................................................................................
            /// 651 Figure 8-9 Timing Requirements for Inputs
            /// ......................................................................................................................
            /// 653 Figure 8-10 Timing Requirements for Outputs
            /// .................................................................................................................
            /// 653 Figure 8-11 I2S/PCM Operation Flow
            /// ...............................................................................................................................
            /// 654 Figure 8-12 DMIC Block Diagram
            /// ......................................................................................................................................
            /// 706 Figure 8-13 DMIC Operation
            /// Mode...................................................................................................................................
            /// 708 Figure 8-14 OWA Block Diagram
            /// .......................................................................................................................................
            /// 725 Figure 8-15 OWA Biphase-Mark Code
            /// ..............................................................................................................................
            /// 727 Figure 8-16 OWA Sub-Frame Format
            /// ................................................................................................................................
            /// 728 Figure 8-17 OWA Frame/Block Format
            /// .............................................................................................................................
            /// 729 Figure 8-18 Data-Burst Format
            /// .........................................................................................................................................
            /// 730 Figure 8-19 Data-burst Preamble
            /// ......................................................................................................................................
            /// 730 Figure 8-20 Data-burst Preamble words
            /// ...........................................................................................................................
            /// 730 Figure 8-21 Fields of Burst-information
            /// ............................................................................................................................
            /// 731 Figure 8-22 Length of the Burst-Payload Specified by Pd
            /// .................................................................................................
            /// 731 Figure 8-23 OWA Operation Flow
            /// .....................................................................................................................................
            /// 732 Figure 8-24 Audio Codec Block Diagram
            /// ...........................................................................................................................
            /// 758 Figure 8-25 Audio Codec Clock Diagram
            /// ...........................................................................................................................
            /// 760 Figure 8-26 Audio Codec Digital Part Reset System
            /// ..........................................................................................................
            /// 761 Figure 8-27 Audio Codec Analog Part Reset System
            /// .........................................................................................................
            /// 761 Figure 8-28 Audio Codec Data Path Diagram
            /// ....................................................................................................................
            /// 762 Figure 8-29 Headphone Output Application
            /// .....................................................................................................................
            /// 764 Figure 8-30 Audio Codec Interrupt System
            /// .......................................................................................................................
            /// 764 Figure 8-31 DAP Data Flow
            /// ...............................................................................................................................................
            /// 765 Figure 8-32 HPF Logic Structure
            /// ........................................................................................................................................
            /// 765 Figure 8-33 DRC Block Diagram
            /// ........................................................................................................................................
            /// 765 Figure 8-34 DRC Static Curve Parameters
            /// .........................................................................................................................
            /// 766 Figure 8-35 Energy Filter Structure
            /// ...................................................................................................................................
            /// 766 Figure 8-36 Gain Smooth Filter
            /// .........................................................................................................................................
            /// 768 Table 8-1 I2S/PCM External Signals
            /// ..................................................................................................................................
            /// 648 Table 8-2 I2S/PCM Clock
            /// Sources......................................................................................................................................
            /// 648 Table 8-3 DIN Slot ID and Encoder
            /// ....................................................................................................................................
            /// 651 Table 8-4 Proper MCLK Values with Different Fsin and Fsout
            /// ..........................................................................................
            /// 653 Table 8-5 DMIC External Signals
            /// .......................................................................................................................................
            /// 707 Table 8-6 DMIC Clock
            /// Sources...........................................................................................................................................
            /// 707 Table 8-7 OWA Sub-blocks
            /// ................................................................................................................................................
            /// 725 Table 8-8 OWA External Signals
            /// ........................................................................................................................................
            /// 726 Table 8-9 OWA_TX Clock Sources
            /// .....................................................................................................................................
            /// 726 Table 8-10 OWA_RX Clock Sources
            /// ...................................................................................................................................
            /// 726 Table 8-11 Biphase-Mark Encoder
            /// ....................................................................................................................................
            /// 727 Table 8-12 Preamble Codes
            /// ..............................................................................................................................................
            /// 728 Table 8-13 Bit Allocation of Data-Burst in IEC 60958
            /// Subframes......................................................................................
            /// 729 Table 8-14 The Corresponding Relation between Different System Clock and
            /// Sample Ratio .......................................... 732 Table 8-15 Audio
            /// Codec External Signals
            /// ..........................................................................................................................
            /// 758
            @"TX/RX_FIFO": u32,
        }), base_address + 0x200);

        /// address: 0x4021040
        /// FIFO Water Level Register
        pub const SMHC_FIFOTH = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Trigger Level 0x1 to 0xFF: The TX trigger level is 1 to 255.
            /// 0x0: No trigger Indicates the FIFO threshold for the FIFO request host to
            /// transmit data to the FIFO. When the FIFO data level is less than or equal to
            /// this value, the DMA TX request is raised if DMA enabled, or TX request interrupt
            /// bit is set if interrupt enabled. At the end of the packet, if the last transfer
            /// is less than this level, the value is ignored and the relative request will be
            /// raised as usual. Recommended: 240 (means less than or equal to 240)
            TX_TL: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RX Trigger Level 0x0 to 0xFE: The RX trigger level is from 0 to 254.
            /// 0xFF: Reserved Indicates the FIFO threshold for the FIFO request host to receive
            /// data from the FIFO. When the FIFO data level is greater than this value, the DMA
            /// request is raised if DMA enabled, or the RX interrupt bit is set if interrupt
            /// enabled. At the end of the packet, if the last transfer is less than this level,
            /// the value is ignored and the relative request will be raised as usual.
            /// Recommended: 15 (means greater than 15)
            RX_TL: u8,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Burst Size of Multiple Transaction
            /// 000: 1 transfers
            /// 001: 4
            /// 010: 8
            /// 011: 16 Others: Reserved It should be programmed the same as the DMA controller
            /// multiple transaction size. The units for the transfer are the DWORD. A single
            /// transfer would be signaled based on this value. The value should be sub-multiple
            /// of (RX_TL + 1) and (FIFO_DEPTH - TX_TL) Recommended: FIFO_DEPTH = 256, FIFO_SIZE
            /// = 256 * 32 = 1K MSize = 16, TX_TL = 240, RX_TL = 15
            BSIZE_OF_TRANS: u3,
            padding0: u1,
        }), base_address + 0x40);

        /// address: 0x4021044
        /// FIFO Function Select Register
        pub const SMHC_FUNS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host Send MMC IRQ Response
            /// 0: Ignored
            /// 1: Send auto IRQ response When the host is waiting for the MMC card interrupt
            /// response, setting this bit will make the controller cancel the waiting state and
            /// return to the idle state, at which time, the controller will receive the IRQ
            /// response sent by itself. This bit is auto-cleared after the response is sent.
            HOST_SEND_MMC_IRQRESQ: u1,
            /// Read Wait
            /// 0: Clear SDIO read wait
            /// 1: Assert SDIO read wait
            READ_WAIT: u1,
            /// Abort Read Data
            /// 0: Ignored
            /// 1: After the suspend command is issued during the read- transfer, the software
            /// polls card to find when the suspend happens. Once the suspend occurs, the
            /// software sets the bit to reset the data state-machine, which is waiting for the
            /// next block of data. This bit is used in the SDIO card suspends sequence and is
            /// auto- cleared once the controller resets to the idle state.
            ABT_RDATA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x44);

        /// address: 0x402114c
        /// HS400 Delay Control Register
        pub const SMHC_HS400_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// HS400 Delay Software
            HS400_DL_SW: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Sample Delay Software Enable
            HS400_DL_SW_EN: u1,
            /// HS400 Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the SMHC clock nearly. This bit is valid only when HS400_DL_CAL_DONE is set.
            HS400_DL: u4,
            reserved3: u1,
            reserved4: u1,
            /// HS400 Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in HS400_DL.
            HS400_DL_CAL_DONE: u1,
            /// HS400 Delay Calibration Start When set, it means that start sample delay chain
            /// calibration.
            HS400_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14c);

        /// address: 0x4021078
        /// Hardware Reset Register
        pub const SMHC_HWRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Active mode
            /// 0: Reset These bits cause the cards to enter the pre-idle state, which requires
            /// them to be re-initialized.
            HW_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x78);

        /// address: 0x402108c
        /// SMHC_IDIE_REG
        pub const SMHC_IDIE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt Enable. When set with Normal Interrupt Summary Enable,
            /// Transmit Interrupt is enabled. When reset, the Transmit Interrupt is disabled.
            TX_INT_ENB: u1,
            /// Receive Interrupt Enable. When set with Normal Interrupt Summary Enable, Receive
            /// Interrupt is enabled. When reset, the Receive Interrupt is disabled.
            RX_INT_ENB: u1,
            /// Fatal Bus Error Enable When set with Abnormal Interrupt Summary Enable, the
            /// Fatal Bus Error Interrupt is enabled. When reset, the Fatal Bus Error Enable
            /// Interrupt is disabled.
            FERR_INT_ENB: u1,
            reserved0: u1,
            /// Descriptor Unavailable Interrupt. When set along with Abnormal Interrupt Summary
            /// Enable, the Descriptor Unavailable Interrupt is enabled.
            DES_UNAVL_INT_ENB: u1,
            /// Card Error Summary Interrupt Enable. When set, it enables the Card Interrupt
            /// Summary.
            ERR_SUM_INT_ENB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8c);

        /// address: 0x4021080
        /// IDMAC Control Register
        pub const SMHC_IDMAC = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Reset When set, the DMA Controller resets all its internal registers. It is
            /// automatically cleared after 1 clock cycle.
            IDMAC_RST: u1,
            /// Fixed Burst Controls whether the AHB Master interface performs fixed burst
            /// transfers or not. When set, the AHB will use only SINGLE, INCR4, and INCR8
            /// during the start of normal burst transfers. When reset, the AHB will use SINGLE
            /// and INCR burst transfer operations.
            FIX_BUST_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// IDMAC Enable When set, the IDMAC is enabled.
            IDMAC_ENB: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// When IDMAC fetches a descriptor, if the valid bit of a descriptor is not set,
            /// IDMAC FSM will go to the suspend state. Setting this bit will make the IDMAC
            /// refetch descriptor again and do the transfer normally.
            DES_LOAD_CTRL: u1,
        }), base_address + 0x80);

        /// address: 0x4021088
        /// SMHC_IDST_REG
        pub const SMHC_IDST_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt Indicates that data transmission is finished for a
            /// descriptor. Writing 1 clears this bit.
            TX_INT: u1,
            /// Receive Interrupt Indicates the completion of data reception for a descriptor.
            /// Writing 1 clears this bit.
            RX_INT: u1,
            /// Fatal Bus Error Interrupt Indicates that a Bus Error occurred (IDST[12:10]).
            /// When this bit is set, the DMA disables all its bus accesses. Writing 1 clears
            /// this bit.
            FATAL_BERR_INT: u1,
            reserved0: u1,
            /// Descriptor Unavailable Interrupt This bit is set when the descriptor is
            /// unavailable due to OWN bit = 0 (DES0[31] =0). Writing 1 clears this bit.
            DES_UNAVL_INT: u1,
            /// Card Error Summary Indicates the status of the transaction to/from the card;
            /// also present in RINTSTS. Indicates the logical OR of the following bits:
            /// EBE: End Bit Error RTO: Response Timeout RCRC: Response CRC SBE: Start Bit Error
            /// DRTO: Data Read Timeout DCRC: Data CRC for Receive RE: Response Error Writing 1
            /// clears this bit.
            ERR_FLAG_SUM: u1,
            reserved1: u1,
            reserved2: u1,
            /// (NIS) Normal Interrupt Summary Logical OR of the following: IDST[0]: Transmit
            /// Interrupt IDST[1]: Receive Interrupt Only unmasked bits affect this bit. This is
            /// a sticky bit and must be cleared each time a corresponding bit that causes NIS
            /// to be set is cleared.
            NOR_INT_SUM: u1,
            /// (AIS) Abnormal Interrupt Summary Logical OR of the following: IDST[2]: Fatal Bus
            /// Interrupt IDST[4]: Descriptor Unavailable Bit Interrupt IDST[5]: Card Error
            /// Summary Interrupt Only unmasked bits affect this bit. This is a sticky bit and
            /// must be cleared each time a corresponding bit that causes AIS to be set is
            /// cleared.
            ABN_INT_SUM: u1,
            /// Error Bits Indicates the type of error that caused a Bus Error. Valid only with
            /// Fatal Bus Error bit (IDST[2]) set. This field does not generate an interrupt.
            /// 001: Host Abort received during the transmission.
            /// 010: Host Abort received during the reception. Others: Reserved
            IDMAC_ERR_STA: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x88);

        /// address: 0x4021030
        /// Interrupt Mask Register
        pub const SMHC_INTMASK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error Interrupt Enable
            RE_INT_EN: u1,
            /// Command Complete Interrupt Enable
            CC_INT_EN: u1,
            /// Data Transfer Complete Interrupt Enable
            DTC_INT_EN: u1,
            /// Data Transmit Request Interrupt Enable
            DTR_INT_EN: u1,
            /// Data Receive Request Interrupt Enable
            DRR_INT_EN: u1,
            /// Response CRC Error Interrupt Enable
            RCE_INT_EN: u1,
            /// Data CRC Error Interrupt Enable
            DCE_INT_EN: u1,
            /// Response Timeout/Boot ACK Received Interrupt Enable
            RTO_BACK_INT_EN: u1,
            /// Data Timeout/Boot Data Start Interrupt Enable
            DTO_BDS_INT_EN: u1,
            /// Data Starvation Timeout/V1.8 Switch Done Interrupt Enable
            DSTO_VSD_INT_EN: u1,
            /// FIFO Underrun/Overflow Interrupt Enable
            FU_FO_INT_EN: u1,
            /// Command Busy and Illegal Write Interrupt Enable
            CB_IW_INT_EN: u1,
            /// Data Start Error Interrupt Enable
            DSE_BC_INT_EN: u1,
            /// Auto Command Done Interrupt Enable
            ACD_INT_EN: u1,
            /// Data End-bit Error Interrupt Enable
            DEE_INT_EN: u1,
            /// SDIO Interrupt Enable
            SDIO_INT_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted Interrupt Enable
            CARD_INSERT_INT_EN: u1,
            /// Card Removed Interrupt Enable
            CARD_REMOVAL_INT_EN: u1,
        }), base_address + 0x30);

        /// address: 0x4021034
        /// Masked Interrupt Status Register
        pub const SMHC_MINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error When set, Transmit Bit error or End Bit error or CMD Index error
            /// may occurs.
            M_RE_INT: u1,
            /// Command Complete
            M_CC_INT: u1,
            /// Data Transfer Complete
            M_DTC_INT: u1,
            /// Data Transmit Request When set, it means that there is enough space in FIFO
            /// during transmitting data.
            M_DTR_INT: u1,
            /// Data Receive Request When set, it means that there are enough data in FIFO
            /// during receiving data.
            M_DRR_INT: u1,
            /// Response CRC Error
            M_RCE_INT: u1,
            /// Data CRC Error When the bit is set during receiving data, it means that the
            /// received data have data CRC error. When the bit is set during transmitting data,
            /// it means that the received CRC status taken is negative.
            M_DCE_INT: u1,
            /// Response Timeout/Boot ACK Received
            M_RTO_BACK_INT: u1,
            /// Data Timeout/Boot Data Start
            M_DTO_BDS_INT: u1,
            /// Data Starvation Timeout/V1.8 Switch Done
            M_DSTO_VSD_INT: u1,
            /// FIFO Underrun/Overflow
            M_FU_FO_INT: u1,
            /// Command Busy and Illegal Write
            M_CB_IW_INT: u1,
            /// Data Start Error/Busy Clear When set during receiving data, it means that the
            /// host controller found an error start bit. When the bit is set during
            /// transmitting data, it means that the busy signal is cleared after the last
            /// block.
            M_DSE_BC_INT: u1,
            /// Auto Command Done When set, it means auto-stop command (CMD12) completed.
            M_ACD_INT: u1,
            /// Data End-bit Error When the bit is set during receiving data, it means that the
            /// host controller does not receive the valid data end bit. When the bit is set
            /// during transmitting data, it means that the host controller does not receive the
            /// CRC status token. This is a write-1-to-clear bit.
            M_DEE_INT: u1,
            /// SDIO Interrupt
            M_SDIO_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted
            M_CARD_INSERT: u1,
            /// Card Removed
            M_CARD_REMOVAL_INT: u1,
        }), base_address + 0x34);

        /// address: 0x402105c
        /// SD New Timing Set Register
        pub const SMHC_NTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable hs400 new sample method
            /// 1: Enable hs400 new sample method
            HS400_NEW_SAMPLE_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// 00: Sample timing phase offset 90
            /// 01: Sample timing phase offset 180
            /// 10: Sample timing phase offset 270
            /// 11: Ignore
            CMD_SAMPLE_TIMING_PHASE: u2,
            reserved3: u1,
            reserved4: u1,
            /// 00: Sample timing phase offset 90
            /// 01: Sample timing phase offset 180
            /// 10: Sample timing phase offset 270
            /// 11: Sample timing phase offset 0 (only for SD2 hs400 mode)
            DAT_SAMPLE_TIMING_PHASE: u2,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Clear command rx phase before sending the command.
            /// 0: Disabled
            /// 1: Enabled
            CMD_SEND_RX_PHASE_CLR: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the input phase of data lines before receiving the data.
            /// 0: Disabled
            /// 1: Enabled
            DAT_RECV_RX_PHASE_CLR: u1,
            /// Clear the input phase of data lines before transferring the data.
            /// 0: Disabled
            /// 1: Enabled
            DAT_TRANS_RX_PHASE_CLR: u1,
            /// Clear the input phase of data lines before receiving the CRC status.
            /// 0: Disabled
            /// 1: Enabled
            DAT_CRC_STATUS_RX_PHASE_CLR: u1,
            reserved14: u1,
            /// Clear the input phase of command lines and data lines during the update clock
            /// operation.
            /// 0: Disabled
            /// 1: Enabled
            CMD_DAT_RX_PHASE_CLR: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// 0: Old mode of Sample/Output Timing
            /// 1: New mode of Sample/Output Timing
            MODE_SELECT: u1,
        }), base_address + 0x5c);

        /// address: 0x4021020
        /// Response 0 Register
        pub const SMHC_RESP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 0 Bit[31:0] of response
            CMD_RESP0: u32,
        }), base_address + 0x20);

        /// address: 0x4021024
        /// Response 1 Register
        pub const SMHC_RESP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 1 Bit[63:31] of response
            CMD_RESP1: u32,
        }), base_address + 0x24);

        /// address: 0x4021028
        /// Response 2 Register
        pub const SMHC_RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 2 Bit[95:64] of response
            CMD_RESP2: u32,
        }), base_address + 0x28);

        /// address: 0x402102c
        /// Response 3 Register
        pub const SMHC_RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 3 Bit[127:96] of response
            CMD_RESP3: u32,
        }), base_address + 0x2c);

        /// address: 0x4021038
        /// Raw Interrupt Status Register
        pub const SMHC_RINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error When set, it means that the transmit bit error, end bit error, or
            /// CMD index error may occur. Write 1 to clear this bit.
            RE: u1,
            /// Command Complete When set, it means that the current command completes even
            /// through error occurs. Write 1 to clear this bit.
            CC: u1,
            /// Data Transfer Complete When set, it means that the current command completes
            /// even through error occurs. Write 1 to clear this bit.
            DTC: u1,
            /// Data Transmit Request When set, it means that there is enough space in FIFO
            /// during transmitting data. Write 1 to clear this bit.
            DTR: u1,
            /// Data Receive Request When set, it means that there are enough data in FIFO
            /// during receiving data. Write 1 to clear this bit.
            DRR: u1,
            /// Response CRC Error Write 1 to clear this bit.
            RCE: u1,
            /// Data CRC Error When the bit is set during receiving data, it means that the
            /// received data have data CRC error. When the bit is set during transmitting data,
            /// it means that the received CRC status taken is negative. Write 1 to clear this
            /// bit.
            DCE: u1,
            /// Response Timeout/Boot ACK Received Write 1 to clear this bit.
            RTO_BACK: u1,
            /// Data Timeout/Boot Data Start When the bit is set during receiving data, it means
            /// that some of the channel of DATA[3:0] lack of the start bit. Write 1 to clear
            /// this bit.
            DTO_BDS: u1,
            /// Data Starvation Timeout/V1.8 Switch Done Write 1 to clear this bit.
            DSTO_VSD: u1,
            /// FIFO Underrun/Overflow Write 1 to clear this bit.
            FU_FO: u1,
            /// Command Busy and Illegal Write Write 1 to clear this bit.
            CB_IW: u1,
            /// Data Start Error/Busy Clear When the bit is set during receiving data, it means
            /// that the host controller found an error start bit. When the bit is set during
            /// transmitting data, it means that the busy signal is cleared after the last
            /// block. Write 1 to clear this bit.
            DSE_BC: u1,
            /// Auto Command Done When set, it means that the auto-stop command (CMD12) is
            /// completed. Write 1 to clear this bit.
            ACD: u1,
            /// Data End-bit Error When the bit is set during receiving data, it means that the
            /// host controller does not receive the valid data end bit. When the bit is set
            /// during transmitting data, it means that the host controller does not receive the
            /// CRC status token. Write 1 to clear this bit.
            DEE: u1,
            /// SDIO Interrupt Write 1 to clear this bit.
            SDIOI_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted Write 1 to clear this bit.
            CARD_INSERT: u1,
            /// Card Removed Write 1 to clear this bit.
            CARD_REMOVAL: u1,
        }), base_address + 0x38);

        /// address: 0x4021144
        /// SMHC_SAMP_DL
        pub const SMHC_SAMP_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Delay Software The relative delay between the clock line and command
            /// line, data line. It can be determined according to the value of SAMP_DL, the
            /// cycle of the card clock and the input timing requirement of the device.
            SAMP_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable When set, it means that enable the sample delay
            /// specified at SAMP_DL_SW.
            SAMP_DL_SW_EN: u1,
            /// Sample Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the card clock nearly. Generally, it is necessary to do drive delay
            /// calibration when the card clock is changed. This bit is valid only when
            /// SAMP_DL_CAL_DONE is set.
            SAMP_DL: u6,
            /// Sample Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in SAMP_DL.
            SAMP_DL_CAL_DONE: u1,
            /// Sample Delay Calibration Start When set, it means that start sample delay chain
            /// calibration.
            SAMP_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x144);

        /// address: 0x4021104
        /// Sample FIFO Control Register
        pub const SMHC_SFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bypass enable When set, sample FIFO will be bypassed.
            BYPASS_EN: u1,
            /// Stop Clock Control When receiving data, if CARD_RD_THLD_ENB is set and
            /// CARD_RD_THLD is set the same with BLK_SZ, the device clock may stop at the block
            /// gap during data receiving. This field is used to control the position of the
            /// stopping clock. The value can be changed between 0x0 and 0xF, but actually, the
            /// available value and the position of the stopping clock must be decided by the
            /// actual situation. The value increases one in this field is linked to one cycle
            /// (two cycles in DDR mode) that the position of the stopping clock moved up.
            STOP_CLK_CTRL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x104);

        /// address: 0x402103c
        /// Status Register
        pub const SMHC_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO RX Water Level Flag
            /// 0: FIFO does not reach the receive trigger level.
            /// 1: FIFO reaches the receive trigger level.
            FIFO_RX_LEVEL: u1,
            /// FIFO TX Water Level Flag
            /// 0: FIFO does not reach the transmit trigger level
            /// 1: FIFO reaches the transmit trigger level
            FIFO_TX_LEVEL: u1,
            /// FIFO Empty
            /// 0: FIFO is not empty
            /// 1: FIFO is empty
            FIFO_EMPTY: u1,
            /// FIFO Full
            /// 0: FIFO is not full
            /// 1: FIFO is full
            FIFO_FULL: u1,
            /// Command FSM States
            /// 0000: Idle
            /// 0001: Send init sequence
            /// 0010: TX CMD start bit
            /// 0011: TX CMD TX bit
            /// 0100: TX CMD index + argument
            /// 0101: TX CMD CRC7
            /// 0110: TX CMD end bit
            /// 0111: RX response start bit
            /// 1000: RX response IRQ response
            /// 1001: RX response TX bit
            /// 1010: RX response CMD index
            /// 1011: RX response data
            /// 1100: RX response CRC7
            /// 1101: RX response end bit
            /// 1110: CMD path wait NCC
            /// 1111: Wait; CMD-to-response turn around
            FSM_STA: u4,
            /// Data[3] Status The level of DATA[3], checks whether the card is present.
            /// 0: The card is not present.
            /// 1: The card is present.
            CARD_PRESENT: u1,
            /// Card Data Busy Inverted version of DATA[0]
            /// 0: Card data is not busy.
            /// 1: Card data is busy.
            CARD_BUSY: u1,
            /// Data FSM Busy Data transmit or receive state-machine is busy.
            FSM_BUSY: u1,
            /// Response Index Index of previous response, including any auto-stop sent by the
            /// controller.
            RESP_IDX: u6,
            /// FIFO Level Number of filled locations in FIFO
            FIFO_LEVEL: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DMA Request DMA request signal state
            DMA_REQ: u1,
        }), base_address + 0x3c);

        /// address: 0x4021048
        /// SMHC_TBC0
        pub const SMHC_TBC0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transferred Count 0 The number of bytes transferred between the card and
            /// internal FIFO. The register should be accessed in full to avoid read-coherency
            /// problems and read only after the data transfer completes.
            TBC0: u32,
        }), base_address + 0x48);

        /// address: 0x402104c
        /// SMHC_TBC1
        pub const SMHC_TBC1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transferred Count 1 The number of bytes transferred between the Host/DMA memory
            /// and internal FIFO. The register should be accessed in full to avoid
            /// read-coherency problems and read only after the data transfer completes.
            TBC1: u32,
        }), base_address + 0x4c);

        /// address: 0x4021100
        /// Card Threshold Control Register
        pub const SMHC_THLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Read Threshold Enable
            /// 0: Card read threshold disabled
            /// 1: Card read threshold enabled Host controller initiates Read Transfer only if
            /// the CARD_RD_THLD amount of space is available in receive FIFO.
            CARD_RD_THLD_ENB: u1,
            /// Busy Clear Interrupt Generation
            /// 0: Busy clear interrupt disabled
            /// 1: Busy clear interrupt enabled The application can disable this feature if it
            /// does not want to wait for a Busy Clear Interrupt.
            BCIG: u1,
            /// Card Write Threshold Enable
            /// 0: Card write threshold disabled
            /// 1: Card write threshold enabled Host controller initiates write transfer only if
            /// the card threshold amount of data is available in transmit FIFO.
            CARD_WR_THLD_ENB: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Card Read/Write Threshold Size
            CARD_WR_THLD: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x100);

        /// address: 0x4021008
        /// Time Out Register
        pub const SMHC_TMOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response Timeout Limit
            RTO_LMT: u8,
            /// Data Timeout Limit This field can set the time that the host waits for the data
            /// from the device. Ensure to communicate with the device, this field must be set
            /// to the maximum that is greater than the time . About the , the explanation is as
            /// follows: When Host read data, data transmission from the Device starts after the
            /// access time delay beginning from the end bit of the read command (ACMD51, CMD8,
            /// CMD17, and CMD18). When the host reads multiple block (CMD18), a next block’s
            /// data transmission from the Device starts after the access time delay beginning
            /// from the end bit of the previous block. When the host writes data, the value is
            /// no effect.
            DTO_LMT: u24,
        }), base_address + 0x8);
    };

    /// SMHC2
    pub const SMHC2 = struct {
        pub const base_address = 0x4022000;

        /// address: 0x402210c
        /// eMMC4.5 DDR Start Bit Detection Control Register
        pub const EMMC_DDR_SBIT_DET = @intToPtr(*volatile Mmio(32, packed struct {
            /// Control for start bit detection mechanism inside mstorage based on duration of
            /// start bit. For eMMC 4.5, start bit can be:
            /// 0: Full cycle
            /// 1: Less than one full cycle Set HALF_START_BIT = 1 for eMMC 4.5 and above; set
            /// to 0 for SD applications.
            HALF_START_BIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// HS400 Mode Enable
            /// 0: Disabled
            /// 1: Enabled It is required to set this bit to '1' before initiating any data
            /// transfer CMD in HS400 mode.
            HS400_MD_EN: u1,
        }), base_address + 0x10c);

        /// address: 0x4022058
        /// Auto Command 12 Argument Register
        pub const SMHC_A12A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto CMD12 Argument The argument of command 12 automatically sent by the
            /// controller.
            SD_A12A: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x4022108
        /// Auto Command 23 Argument Register
        pub const SMHC_A23A = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto CMD23 Argument The argument of command 23 is automatically sent by
            /// controller with this field.
            A23A: u32,
        }), base_address + 0x108);

        /// address: 0x4022010
        /// Block Size Register
        pub const SMHC_BLKSIZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Block Size
            BLK_SZ: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x4022014
        /// Byte Count Register
        pub const SMHC_BYTCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Byte counter The number of bytes to be transferred. It must be integer multiple
            /// of Block Size (BLK_SZ) for block transfers.
            BYTE_CNT: u32,
        }), base_address + 0x14);

        /// address: 0x4022004
        /// Clock Control Register
        pub const SMHC_CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Clock Divider n: Source clock is divided by 2*n. (n = 0 to 255) When
            /// HS400_MD_EN is set, this field must be cleared.
            CCLK_DIV: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Card Clock Enable
            /// 0: Card Clock is off.
            /// 1: Card Clock is on.
            CCLK_ENB: u1,
            /// Card Clock Output Control
            /// 0: Card clock is always on.
            /// 1: Turn off card clock when FSM is in IDLE state.
            CCLK_CTRL: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// 0: Do not mask data0 when update clock
            /// 1: Mask data0 when update clock
            MASK_DATA0: u1,
        }), base_address + 0x4);

        /// address: 0x4022018
        /// Command Register
        pub const SMHC_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// CMD Index Command index value
            CMD_IDX: u6,
            /// Response Receive
            /// 0: Command without response
            /// 1: Command with response
            RESP_RCV: u1,
            /// Response Type
            /// 0: Short Response (48 bits)
            /// 1: Long Response (136 bits)
            LONG_RESP: u1,
            /// Check Response CRC
            /// 0: Do not check response CRC
            /// 1: Check response CRC
            CHK_RESP_CRC: u1,
            /// Data Transfer
            /// 0: Without data transfer
            /// 1: With data transfer
            DATA_TRANS: u1,
            /// Transfer Direction
            /// 0: Read operation
            /// 1: Write operation
            TRANS_DIR: u1,
            /// Transfer Mode
            /// 0: Block data transfer command
            /// 1: Stream data transfer command
            TRANS_MODE: u1,
            /// Send Stop CMD Automatically (CMD12)
            /// 0: Do not send stop command at the end of the data transfer.
            /// 1: Send stop command automatically at the end of the data transfer. If set, the
            /// SMHC_RESP1 will record the response of auto CMD12.
            STOP_CMD_FLAG: u1,
            /// Wait for Data Transfer Over
            /// 0: Send command at once, does not care about data transferring.
            /// 1: Wait for data transfer completion before sending the current command.
            WAIT_PRE_OVER: u1,
            /// Stop Abort Command
            /// 0: Normal command sending
            /// 1: Send or command to stop the current data transfer in progress. (CMD12, CMD52
            /// for writing “I/O Abort” in SDIO CCCR)
            STOP_ABT_CMD: u1,
            /// Send Initialization
            /// 0: Normal command sending
            /// 1: Send initialization sequence before sending this command.
            SEND_INIT_SEQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Change Clock
            /// 0: Normal command
            /// 1: Change Card Clock When this bit is set, the controller will change the clock
            /// domain and clock output. No commands will be sent.
            PRG_CLK: u1,
            reserved5: u1,
            reserved6: u1,
            /// Boot Mode
            /// 00: Normal command
            /// 01: Mandatory Boot operation
            /// 10: Alternate Boot operation
            /// 11: Reserved
            BOOT_MOD: u2,
            /// Expect Boot Acknowledge When the software sets this bit along in mandatory boot
            /// operation, the controller expects a boot acknowledge start pattern of 0-1-0 from
            /// the selected card.
            EXP_BOOT_ACK: u1,
            /// Boot Abort Setting this bit will terminate the boot operation.
            BOOT_ABT: u1,
            /// Voltage Switch
            /// 0: Normal command
            /// 1: Voltage switch command, set for CMD11 only.
            VOL_SW: u1,
            reserved7: u1,
            reserved8: u1,
            /// Start Command This bit is automatically cleared when the current command is
            /// sent. If there is no response error happens, a command complete interrupt bit
            /// (CMD_OVER) will be set in the interrupt register. Do not write any other
            /// commands until this bit is cleared.
            CMD_LOAD: u1,
        }), base_address + 0x18);

        /// address: 0x402201c
        /// Command Argument Register
        pub const SMHC_CMDARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMD_ARG: u32,
        }), base_address + 0x1c);

        /// address: 0x4022054
        /// CRC Status Detect Control Registers
        pub const SMHC_CSDC = @intToPtr(*volatile Mmio(32, packed struct {
            /// 110: HS400 speed mode
            /// 011: Other speed mode Others: Reserved
            CRC_DET_PARA: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x54);

        /// address: 0x4022000
        /// Control Register
        pub const SMHC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Reset
            /// 0: No effect
            /// 1: Reset SD/MMC controller This bit is auto-cleared after the completion of
            /// reset operation.
            SOFT_RST: u1,
            /// FIFO Reset
            /// 0: No effect
            /// 1: Reset the FIFO This bit is auto-cleared after the completion of the reset
            /// operation.
            FIFO_RST: u1,
            /// DMA Reset
            DMA_RST: u1,
            reserved0: u1,
            /// Global Interrupt Enable
            /// 0: Disable interrupts
            /// 1: Enable interrupts
            INT_ENB: u1,
            /// DMA Global Enable
            /// 0: Disable DMA to transfer data via AHB bus
            /// 1: Enable DMA to transfer data
            DMA_ENB: u1,
            reserved1: u1,
            reserved2: u1,
            /// Card Detect (Data[3] status) De-bounce Enable
            /// 0: Disable de-bounce
            /// 1: Enable de-bounce
            CD_DBC_ENB: u1,
            reserved3: u1,
            /// DDR Mode Select Although the HS400 speed mode of eMMC is 8-bit DDR, this field
            /// should be cleared when HS400_MD_EN is set.
            /// 0: SDR mode
            /// 1: DDR mode
            DDR_MOD_SEL: u1,
            /// Time unit for data line Time unit is used to calculate the data line time out
            /// value defined in DTO_LMT.
            /// 0: 1 card clock period
            /// 1: 256 card clock period
            TIME_UNIT_DAT: u1,
            /// Time unit for command line The time unit is used to calculate the command line
            /// time out value defined in RTO_LMT.
            /// 0: 1 card clock period
            /// 1: 256 card clock period
            TIME_UNIT_CMD: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// FIFO Access Mode
            /// 0: DMA bus
            /// 1: AHB bus
            FIFO_AC_MOD: u1,
        }), base_address + 0x0);

        /// address: 0x402200c
        /// Bus Width Register
        pub const SMHC_CTYPE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Width
            /// 00: 1-bit width
            /// 01: 4-bit width
            /// 1x: 8-bit width
            CARD_WID: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x4022084
        /// SMHC_DLBA_REG
        pub const SMHC_DLBA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start of Descriptor List Contains the base address of the First Descriptor. It
            /// is a word (4 Byte) address.
            DES_BASE_ADDR: u32,
        }), base_address + 0x84);

        /// address: 0x4022140
        /// Drive Delay Control Register
        pub const SMHC_DRV_DL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Command Drive Phase Select
            /// 0: Command drive phase offset is 90° at SDR mode, 45° at DDR8 mode, and 90°
            /// at DDR4 mode.
            /// 1: Command drive phase offset is 180° at SDR mode, 90° at DDR8 mode, and 180°
            /// at DDR4 mode.
            /// 0: Command drive phase offset is 90° at SDR mode and 45° at DDR mode.
            /// 1: Command drive phase offset is 180° at SDR mode and 90° at DDR mode.
            CMD_DRV_PH_SEL: u1,
            /// Data Drive Phase Select
            /// 0: Data drive phase offset is 90° at SDR mode, 45° at DDR8 mode, and 90° at
            /// DDR4 mode.
            /// 1: Data drive phase offset is 180° at SDR mode, 90° at DDR8 mode, and 0° at
            /// DDR4 mode.
            /// 0: Data drive phase offset is 90° at SDR mode, and 45° at DDR mode.
            /// 1: Data drive phase offset is 180° at SDR mode, and 90° at DDR mode.
            DAT_DRV_PH_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x140);

        /// address: 0x4022148
        /// Data Strobe Delay Control Register
        pub const SMHC_DS_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Strobe Delay Software
            DS_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable
            DS_DL_SW_EN: u1,
            /// Data Strobe Delay It indicates the number of delay cells corresponding to the
            /// current card clock. The delay time generated by these delay cells is equal to
            /// the cycle of SMHC’s clock nearly. This bit is valid only when SAMP_DL_CAL_DONE
            /// is set.
            DS_DL: u6,
            /// Data Strobe Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in DS_DL.
            DS_DL_CAL_DONE: u1,
            /// Data Strobe Delay Calibration Start When set, it means that start sample delay
            /// chain calibration.
            DS_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x148);

        /// address: 0x4022138
        /// Extended Command Register
        pub const SMHC_EXT_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Send CMD23 Automatically When setting this bit, send CMD23 automatically before
            /// sending the command specified in the SMHC_CMD register. When SOFT_RST is set,
            /// this field will be cleared.
            AUTO_CMD23_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x138);

        /// address: 0x402213c
        /// Extended Response Register
        pub const SMHC_EXT_RESP = @intToPtr(*volatile u32, base_address + 0x13c);

        /// address: 0x4022200
        /// Read/Write FIFO
        pub const SMHC_FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data FIFO 8 Audio
            /// .......................................................................................................................................................................
            /// 646 8.1
            /// I2S/PCM...........................................................................................................................................................
            /// 646 8.1.1 Overview
            /// .............................................................................................................................................
            /// 646 8.1.2 Block Diagram
            /// .....................................................................................................................................
            /// 647 8.1.3 Functional Description
            /// ........................................................................................................................
            /// 648 8.1.4 Programming Guidelines
            /// .....................................................................................................................
            /// 655 8.1.5 Register List
            /// .........................................................................................................................................
            /// 657 8.1.6 Register Description
            /// ............................................................................................................................
            /// 658 8.2
            /// DMIC................................................................................................................................................................
            /// 706 8.2.1 Overview
            /// .............................................................................................................................................
            /// 706 8.2.2 Block Diagram
            /// .....................................................................................................................................
            /// 706 8.2.3 Functional Description
            /// ........................................................................................................................
            /// 706 8.2.4 Register List
            /// .........................................................................................................................................
            /// 709 8.2.5 Register Description
            /// ............................................................................................................................
            /// 709 8.3 OWA
            /// ................................................................................................................................................................
            /// 724 8.3.1 Overview
            /// .............................................................................................................................................
            /// 724 8.3.2 Block Diagram
            /// .....................................................................................................................................
            /// 725 8.3.3 Functional Description
            /// ........................................................................................................................
            /// 726 8.3.4 Register List
            /// .........................................................................................................................................
            /// 733 8.3.5 Register Description
            /// ............................................................................................................................
            /// 734 8.4 Audio Codec
            /// ....................................................................................................................................................
            /// 757 8.4.1 Overview
            /// .............................................................................................................................................
            /// 757 8.4.2 Block Diagram
            /// .....................................................................................................................................
            /// 758 8.4.3 Functional Description
            /// ........................................................................................................................
            /// 758 8.4.4 Programming Guidelines
            /// .....................................................................................................................
            /// 768 8.4.5 Register List
            /// .........................................................................................................................................
            /// 769 8.4.6 Register Description
            /// ............................................................................................................................
            /// 773 Figure 8-1 I2S/PCM Interface System Block Diagram
            /// .......................................................................................................
            /// 647 Figure 8-2 Typical Application of I2S/PCM Interface
            /// ........................................................................................................
            /// 647 Figure 8-3 I2S Standard Mode Timing
            /// ...............................................................................................................................
            /// 649 Figure 8-4 Left-Justified Mode Timing
            /// ..............................................................................................................................
            /// 650 Figure 8-5 Right-Justified Mode Timing
            /// ............................................................................................................................
            /// 650 Figure 8-6 PCM Long Frame Mode Timing
            /// ........................................................................................................................
            /// 650 Figure 8-7 PCM Short Frame Mode Timing
            /// .......................................................................................................................
            /// 651 Figure 8-8 16-Channel Mapping
            /// Configuration.................................................................................................................
            /// 651 Figure 8-9 Timing Requirements for Inputs
            /// ......................................................................................................................
            /// 653 Figure 8-10 Timing Requirements for Outputs
            /// .................................................................................................................
            /// 653 Figure 8-11 I2S/PCM Operation Flow
            /// ...............................................................................................................................
            /// 654 Figure 8-12 DMIC Block Diagram
            /// ......................................................................................................................................
            /// 706 Figure 8-13 DMIC Operation
            /// Mode...................................................................................................................................
            /// 708 Figure 8-14 OWA Block Diagram
            /// .......................................................................................................................................
            /// 725 Figure 8-15 OWA Biphase-Mark Code
            /// ..............................................................................................................................
            /// 727 Figure 8-16 OWA Sub-Frame Format
            /// ................................................................................................................................
            /// 728 Figure 8-17 OWA Frame/Block Format
            /// .............................................................................................................................
            /// 729 Figure 8-18 Data-Burst Format
            /// .........................................................................................................................................
            /// 730 Figure 8-19 Data-burst Preamble
            /// ......................................................................................................................................
            /// 730 Figure 8-20 Data-burst Preamble words
            /// ...........................................................................................................................
            /// 730 Figure 8-21 Fields of Burst-information
            /// ............................................................................................................................
            /// 731 Figure 8-22 Length of the Burst-Payload Specified by Pd
            /// .................................................................................................
            /// 731 Figure 8-23 OWA Operation Flow
            /// .....................................................................................................................................
            /// 732 Figure 8-24 Audio Codec Block Diagram
            /// ...........................................................................................................................
            /// 758 Figure 8-25 Audio Codec Clock Diagram
            /// ...........................................................................................................................
            /// 760 Figure 8-26 Audio Codec Digital Part Reset System
            /// ..........................................................................................................
            /// 761 Figure 8-27 Audio Codec Analog Part Reset System
            /// .........................................................................................................
            /// 761 Figure 8-28 Audio Codec Data Path Diagram
            /// ....................................................................................................................
            /// 762 Figure 8-29 Headphone Output Application
            /// .....................................................................................................................
            /// 764 Figure 8-30 Audio Codec Interrupt System
            /// .......................................................................................................................
            /// 764 Figure 8-31 DAP Data Flow
            /// ...............................................................................................................................................
            /// 765 Figure 8-32 HPF Logic Structure
            /// ........................................................................................................................................
            /// 765 Figure 8-33 DRC Block Diagram
            /// ........................................................................................................................................
            /// 765 Figure 8-34 DRC Static Curve Parameters
            /// .........................................................................................................................
            /// 766 Figure 8-35 Energy Filter Structure
            /// ...................................................................................................................................
            /// 766 Figure 8-36 Gain Smooth Filter
            /// .........................................................................................................................................
            /// 768 Table 8-1 I2S/PCM External Signals
            /// ..................................................................................................................................
            /// 648 Table 8-2 I2S/PCM Clock
            /// Sources......................................................................................................................................
            /// 648 Table 8-3 DIN Slot ID and Encoder
            /// ....................................................................................................................................
            /// 651 Table 8-4 Proper MCLK Values with Different Fsin and Fsout
            /// ..........................................................................................
            /// 653 Table 8-5 DMIC External Signals
            /// .......................................................................................................................................
            /// 707 Table 8-6 DMIC Clock
            /// Sources...........................................................................................................................................
            /// 707 Table 8-7 OWA Sub-blocks
            /// ................................................................................................................................................
            /// 725 Table 8-8 OWA External Signals
            /// ........................................................................................................................................
            /// 726 Table 8-9 OWA_TX Clock Sources
            /// .....................................................................................................................................
            /// 726 Table 8-10 OWA_RX Clock Sources
            /// ...................................................................................................................................
            /// 726 Table 8-11 Biphase-Mark Encoder
            /// ....................................................................................................................................
            /// 727 Table 8-12 Preamble Codes
            /// ..............................................................................................................................................
            /// 728 Table 8-13 Bit Allocation of Data-Burst in IEC 60958
            /// Subframes......................................................................................
            /// 729 Table 8-14 The Corresponding Relation between Different System Clock and
            /// Sample Ratio .......................................... 732 Table 8-15 Audio
            /// Codec External Signals
            /// ..........................................................................................................................
            /// 758
            @"TX/RX_FIFO": u32,
        }), base_address + 0x200);

        /// address: 0x4022040
        /// FIFO Water Level Register
        pub const SMHC_FIFOTH = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Trigger Level 0x1 to 0xFF: The TX trigger level is 1 to 255.
            /// 0x0: No trigger Indicates the FIFO threshold for the FIFO request host to
            /// transmit data to the FIFO. When the FIFO data level is less than or equal to
            /// this value, the DMA TX request is raised if DMA enabled, or TX request interrupt
            /// bit is set if interrupt enabled. At the end of the packet, if the last transfer
            /// is less than this level, the value is ignored and the relative request will be
            /// raised as usual. Recommended: 240 (means less than or equal to 240)
            TX_TL: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RX Trigger Level 0x0 to 0xFE: The RX trigger level is from 0 to 254.
            /// 0xFF: Reserved Indicates the FIFO threshold for the FIFO request host to receive
            /// data from the FIFO. When the FIFO data level is greater than this value, the DMA
            /// request is raised if DMA enabled, or the RX interrupt bit is set if interrupt
            /// enabled. At the end of the packet, if the last transfer is less than this level,
            /// the value is ignored and the relative request will be raised as usual.
            /// Recommended: 15 (means greater than 15)
            RX_TL: u8,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Burst Size of Multiple Transaction
            /// 000: 1 transfers
            /// 001: 4
            /// 010: 8
            /// 011: 16 Others: Reserved It should be programmed the same as the DMA controller
            /// multiple transaction size. The units for the transfer are the DWORD. A single
            /// transfer would be signaled based on this value. The value should be sub-multiple
            /// of (RX_TL + 1) and (FIFO_DEPTH - TX_TL) Recommended: FIFO_DEPTH = 256, FIFO_SIZE
            /// = 256 * 32 = 1K MSize = 16, TX_TL = 240, RX_TL = 15
            BSIZE_OF_TRANS: u3,
            padding0: u1,
        }), base_address + 0x40);

        /// address: 0x4022044
        /// FIFO Function Select Register
        pub const SMHC_FUNS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Host Send MMC IRQ Response
            /// 0: Ignored
            /// 1: Send auto IRQ response When the host is waiting for the MMC card interrupt
            /// response, setting this bit will make the controller cancel the waiting state and
            /// return to the idle state, at which time, the controller will receive the IRQ
            /// response sent by itself. This bit is auto-cleared after the response is sent.
            HOST_SEND_MMC_IRQRESQ: u1,
            /// Read Wait
            /// 0: Clear SDIO read wait
            /// 1: Assert SDIO read wait
            READ_WAIT: u1,
            /// Abort Read Data
            /// 0: Ignored
            /// 1: After the suspend command is issued during the read- transfer, the software
            /// polls card to find when the suspend happens. Once the suspend occurs, the
            /// software sets the bit to reset the data state-machine, which is waiting for the
            /// next block of data. This bit is used in the SDIO card suspends sequence and is
            /// auto- cleared once the controller resets to the idle state.
            ABT_RDATA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x44);

        /// address: 0x402214c
        /// HS400 Delay Control Register
        pub const SMHC_HS400_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// HS400 Delay Software
            HS400_DL_SW: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Sample Delay Software Enable
            HS400_DL_SW_EN: u1,
            /// HS400 Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the SMHC clock nearly. This bit is valid only when HS400_DL_CAL_DONE is set.
            HS400_DL: u4,
            reserved3: u1,
            reserved4: u1,
            /// HS400 Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in HS400_DL.
            HS400_DL_CAL_DONE: u1,
            /// HS400 Delay Calibration Start When set, it means that start sample delay chain
            /// calibration.
            HS400_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14c);

        /// address: 0x4022078
        /// Hardware Reset Register
        pub const SMHC_HWRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Active mode
            /// 0: Reset These bits cause the cards to enter the pre-idle state, which requires
            /// them to be re-initialized.
            HW_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x78);

        /// address: 0x402208c
        /// SMHC_IDIE_REG
        pub const SMHC_IDIE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt Enable. When set with Normal Interrupt Summary Enable,
            /// Transmit Interrupt is enabled. When reset, the Transmit Interrupt is disabled.
            TX_INT_ENB: u1,
            /// Receive Interrupt Enable. When set with Normal Interrupt Summary Enable, Receive
            /// Interrupt is enabled. When reset, the Receive Interrupt is disabled.
            RX_INT_ENB: u1,
            /// Fatal Bus Error Enable When set with Abnormal Interrupt Summary Enable, the
            /// Fatal Bus Error Interrupt is enabled. When reset, the Fatal Bus Error Enable
            /// Interrupt is disabled.
            FERR_INT_ENB: u1,
            reserved0: u1,
            /// Descriptor Unavailable Interrupt. When set along with Abnormal Interrupt Summary
            /// Enable, the Descriptor Unavailable Interrupt is enabled.
            DES_UNAVL_INT_ENB: u1,
            /// Card Error Summary Interrupt Enable. When set, it enables the Card Interrupt
            /// Summary.
            ERR_SUM_INT_ENB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8c);

        /// address: 0x4022080
        /// IDMAC Control Register
        pub const SMHC_IDMAC = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA Reset When set, the DMA Controller resets all its internal registers. It is
            /// automatically cleared after 1 clock cycle.
            IDMAC_RST: u1,
            /// Fixed Burst Controls whether the AHB Master interface performs fixed burst
            /// transfers or not. When set, the AHB will use only SINGLE, INCR4, and INCR8
            /// during the start of normal burst transfers. When reset, the AHB will use SINGLE
            /// and INCR burst transfer operations.
            FIX_BUST_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// IDMAC Enable When set, the IDMAC is enabled.
            IDMAC_ENB: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// When IDMAC fetches a descriptor, if the valid bit of a descriptor is not set,
            /// IDMAC FSM will go to the suspend state. Setting this bit will make the IDMAC
            /// refetch descriptor again and do the transfer normally.
            DES_LOAD_CTRL: u1,
        }), base_address + 0x80);

        /// address: 0x4022088
        /// SMHC_IDST_REG
        pub const SMHC_IDST_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Interrupt Indicates that data transmission is finished for a
            /// descriptor. Writing 1 clears this bit.
            TX_INT: u1,
            /// Receive Interrupt Indicates the completion of data reception for a descriptor.
            /// Writing 1 clears this bit.
            RX_INT: u1,
            /// Fatal Bus Error Interrupt Indicates that a Bus Error occurred (IDST[12:10]).
            /// When this bit is set, the DMA disables all its bus accesses. Writing 1 clears
            /// this bit.
            FATAL_BERR_INT: u1,
            reserved0: u1,
            /// Descriptor Unavailable Interrupt This bit is set when the descriptor is
            /// unavailable due to OWN bit = 0 (DES0[31] =0). Writing 1 clears this bit.
            DES_UNAVL_INT: u1,
            /// Card Error Summary Indicates the status of the transaction to/from the card;
            /// also present in RINTSTS. Indicates the logical OR of the following bits:
            /// EBE: End Bit Error RTO: Response Timeout RCRC: Response CRC SBE: Start Bit Error
            /// DRTO: Data Read Timeout DCRC: Data CRC for Receive RE: Response Error Writing 1
            /// clears this bit.
            ERR_FLAG_SUM: u1,
            reserved1: u1,
            reserved2: u1,
            /// (NIS) Normal Interrupt Summary Logical OR of the following: IDST[0]: Transmit
            /// Interrupt IDST[1]: Receive Interrupt Only unmasked bits affect this bit. This is
            /// a sticky bit and must be cleared each time a corresponding bit that causes NIS
            /// to be set is cleared.
            NOR_INT_SUM: u1,
            /// (AIS) Abnormal Interrupt Summary Logical OR of the following: IDST[2]: Fatal Bus
            /// Interrupt IDST[4]: Descriptor Unavailable Bit Interrupt IDST[5]: Card Error
            /// Summary Interrupt Only unmasked bits affect this bit. This is a sticky bit and
            /// must be cleared each time a corresponding bit that causes AIS to be set is
            /// cleared.
            ABN_INT_SUM: u1,
            /// Error Bits Indicates the type of error that caused a Bus Error. Valid only with
            /// Fatal Bus Error bit (IDST[2]) set. This field does not generate an interrupt.
            /// 001: Host Abort received during the transmission.
            /// 010: Host Abort received during the reception. Others: Reserved
            IDMAC_ERR_STA: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x88);

        /// address: 0x4022030
        /// Interrupt Mask Register
        pub const SMHC_INTMASK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error Interrupt Enable
            RE_INT_EN: u1,
            /// Command Complete Interrupt Enable
            CC_INT_EN: u1,
            /// Data Transfer Complete Interrupt Enable
            DTC_INT_EN: u1,
            /// Data Transmit Request Interrupt Enable
            DTR_INT_EN: u1,
            /// Data Receive Request Interrupt Enable
            DRR_INT_EN: u1,
            /// Response CRC Error Interrupt Enable
            RCE_INT_EN: u1,
            /// Data CRC Error Interrupt Enable
            DCE_INT_EN: u1,
            /// Response Timeout/Boot ACK Received Interrupt Enable
            RTO_BACK_INT_EN: u1,
            /// Data Timeout/Boot Data Start Interrupt Enable
            DTO_BDS_INT_EN: u1,
            /// Data Starvation Timeout/V1.8 Switch Done Interrupt Enable
            DSTO_VSD_INT_EN: u1,
            /// FIFO Underrun/Overflow Interrupt Enable
            FU_FO_INT_EN: u1,
            /// Command Busy and Illegal Write Interrupt Enable
            CB_IW_INT_EN: u1,
            /// Data Start Error Interrupt Enable
            DSE_BC_INT_EN: u1,
            /// Auto Command Done Interrupt Enable
            ACD_INT_EN: u1,
            /// Data End-bit Error Interrupt Enable
            DEE_INT_EN: u1,
            /// SDIO Interrupt Enable
            SDIO_INT_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted Interrupt Enable
            CARD_INSERT_INT_EN: u1,
            /// Card Removed Interrupt Enable
            CARD_REMOVAL_INT_EN: u1,
        }), base_address + 0x30);

        /// address: 0x4022034
        /// Masked Interrupt Status Register
        pub const SMHC_MINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error When set, Transmit Bit error or End Bit error or CMD Index error
            /// may occurs.
            M_RE_INT: u1,
            /// Command Complete
            M_CC_INT: u1,
            /// Data Transfer Complete
            M_DTC_INT: u1,
            /// Data Transmit Request When set, it means that there is enough space in FIFO
            /// during transmitting data.
            M_DTR_INT: u1,
            /// Data Receive Request When set, it means that there are enough data in FIFO
            /// during receiving data.
            M_DRR_INT: u1,
            /// Response CRC Error
            M_RCE_INT: u1,
            /// Data CRC Error When the bit is set during receiving data, it means that the
            /// received data have data CRC error. When the bit is set during transmitting data,
            /// it means that the received CRC status taken is negative.
            M_DCE_INT: u1,
            /// Response Timeout/Boot ACK Received
            M_RTO_BACK_INT: u1,
            /// Data Timeout/Boot Data Start
            M_DTO_BDS_INT: u1,
            /// Data Starvation Timeout/V1.8 Switch Done
            M_DSTO_VSD_INT: u1,
            /// FIFO Underrun/Overflow
            M_FU_FO_INT: u1,
            /// Command Busy and Illegal Write
            M_CB_IW_INT: u1,
            /// Data Start Error/Busy Clear When set during receiving data, it means that the
            /// host controller found an error start bit. When the bit is set during
            /// transmitting data, it means that the busy signal is cleared after the last
            /// block.
            M_DSE_BC_INT: u1,
            /// Auto Command Done When set, it means auto-stop command (CMD12) completed.
            M_ACD_INT: u1,
            /// Data End-bit Error When the bit is set during receiving data, it means that the
            /// host controller does not receive the valid data end bit. When the bit is set
            /// during transmitting data, it means that the host controller does not receive the
            /// CRC status token. This is a write-1-to-clear bit.
            M_DEE_INT: u1,
            /// SDIO Interrupt
            M_SDIO_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted
            M_CARD_INSERT: u1,
            /// Card Removed
            M_CARD_REMOVAL_INT: u1,
        }), base_address + 0x34);

        /// address: 0x402205c
        /// SD New Timing Set Register
        pub const SMHC_NTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable hs400 new sample method
            /// 1: Enable hs400 new sample method
            HS400_NEW_SAMPLE_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// 00: Sample timing phase offset 90
            /// 01: Sample timing phase offset 180
            /// 10: Sample timing phase offset 270
            /// 11: Ignore
            CMD_SAMPLE_TIMING_PHASE: u2,
            reserved3: u1,
            reserved4: u1,
            /// 00: Sample timing phase offset 90
            /// 01: Sample timing phase offset 180
            /// 10: Sample timing phase offset 270
            /// 11: Sample timing phase offset 0 (only for SD2 hs400 mode)
            DAT_SAMPLE_TIMING_PHASE: u2,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Clear command rx phase before sending the command.
            /// 0: Disabled
            /// 1: Enabled
            CMD_SEND_RX_PHASE_CLR: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the input phase of data lines before receiving the data.
            /// 0: Disabled
            /// 1: Enabled
            DAT_RECV_RX_PHASE_CLR: u1,
            /// Clear the input phase of data lines before transferring the data.
            /// 0: Disabled
            /// 1: Enabled
            DAT_TRANS_RX_PHASE_CLR: u1,
            /// Clear the input phase of data lines before receiving the CRC status.
            /// 0: Disabled
            /// 1: Enabled
            DAT_CRC_STATUS_RX_PHASE_CLR: u1,
            reserved14: u1,
            /// Clear the input phase of command lines and data lines during the update clock
            /// operation.
            /// 0: Disabled
            /// 1: Enabled
            CMD_DAT_RX_PHASE_CLR: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// 0: Old mode of Sample/Output Timing
            /// 1: New mode of Sample/Output Timing
            MODE_SELECT: u1,
        }), base_address + 0x5c);

        /// address: 0x4022020
        /// Response 0 Register
        pub const SMHC_RESP0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 0 Bit[31:0] of response
            CMD_RESP0: u32,
        }), base_address + 0x20);

        /// address: 0x4022024
        /// Response 1 Register
        pub const SMHC_RESP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 1 Bit[63:31] of response
            CMD_RESP1: u32,
        }), base_address + 0x24);

        /// address: 0x4022028
        /// Response 2 Register
        pub const SMHC_RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 2 Bit[95:64] of response
            CMD_RESP2: u32,
        }), base_address + 0x28);

        /// address: 0x402202c
        /// Response 3 Register
        pub const SMHC_RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response 3 Bit[127:96] of response
            CMD_RESP3: u32,
        }), base_address + 0x2c);

        /// address: 0x4022038
        /// Raw Interrupt Status Register
        pub const SMHC_RINTSTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Response Error When set, it means that the transmit bit error, end bit error, or
            /// CMD index error may occur. Write 1 to clear this bit.
            RE: u1,
            /// Command Complete When set, it means that the current command completes even
            /// through error occurs. Write 1 to clear this bit.
            CC: u1,
            /// Data Transfer Complete When set, it means that the current command completes
            /// even through error occurs. Write 1 to clear this bit.
            DTC: u1,
            /// Data Transmit Request When set, it means that there is enough space in FIFO
            /// during transmitting data. Write 1 to clear this bit.
            DTR: u1,
            /// Data Receive Request When set, it means that there are enough data in FIFO
            /// during receiving data. Write 1 to clear this bit.
            DRR: u1,
            /// Response CRC Error Write 1 to clear this bit.
            RCE: u1,
            /// Data CRC Error When the bit is set during receiving data, it means that the
            /// received data have data CRC error. When the bit is set during transmitting data,
            /// it means that the received CRC status taken is negative. Write 1 to clear this
            /// bit.
            DCE: u1,
            /// Response Timeout/Boot ACK Received Write 1 to clear this bit.
            RTO_BACK: u1,
            /// Data Timeout/Boot Data Start When the bit is set during receiving data, it means
            /// that some of the channel of DATA[3:0] lack of the start bit. Write 1 to clear
            /// this bit.
            DTO_BDS: u1,
            /// Data Starvation Timeout/V1.8 Switch Done Write 1 to clear this bit.
            DSTO_VSD: u1,
            /// FIFO Underrun/Overflow Write 1 to clear this bit.
            FU_FO: u1,
            /// Command Busy and Illegal Write Write 1 to clear this bit.
            CB_IW: u1,
            /// Data Start Error/Busy Clear When the bit is set during receiving data, it means
            /// that the host controller found an error start bit. When the bit is set during
            /// transmitting data, it means that the busy signal is cleared after the last
            /// block. Write 1 to clear this bit.
            DSE_BC: u1,
            /// Auto Command Done When set, it means that the auto-stop command (CMD12) is
            /// completed. Write 1 to clear this bit.
            ACD: u1,
            /// Data End-bit Error When the bit is set during receiving data, it means that the
            /// host controller does not receive the valid data end bit. When the bit is set
            /// during transmitting data, it means that the host controller does not receive the
            /// CRC status token. Write 1 to clear this bit.
            DEE: u1,
            /// SDIO Interrupt Write 1 to clear this bit.
            SDIOI_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Card Inserted Write 1 to clear this bit.
            CARD_INSERT: u1,
            /// Card Removed Write 1 to clear this bit.
            CARD_REMOVAL: u1,
        }), base_address + 0x38);

        /// address: 0x4022144
        /// SMHC_SAMP_DL
        pub const SMHC_SAMP_DL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Delay Software The relative delay between the clock line and command
            /// line, data line. It can be determined according to the value of SAMP_DL, the
            /// cycle of the card clock and the input timing requirement of the device.
            SAMP_DL_SW: u6,
            reserved0: u1,
            /// Sample Delay Software Enable When set, it means that enable the sample delay
            /// specified at SAMP_DL_SW.
            SAMP_DL_SW_EN: u1,
            /// Sample Delay It indicates the number of delay cells corresponding to the current
            /// card clock. The delay time generated by these delay cells is equal to the cycle
            /// of the card clock nearly. Generally, it is necessary to do drive delay
            /// calibration when the card clock is changed. This bit is valid only when
            /// SAMP_DL_CAL_DONE is set.
            SAMP_DL: u6,
            /// Sample Delay Calibration Done When set, it means that sample delay chain
            /// calibration is done and the result of calibration is shown in SAMP_DL.
            SAMP_DL_CAL_DONE: u1,
            /// Sample Delay Calibration Start When set, it means that start sample delay chain
            /// calibration.
            SAMP_DL_CAL_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x144);

        /// address: 0x4022104
        /// Sample FIFO Control Register
        pub const SMHC_SFC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bypass enable When set, sample FIFO will be bypassed.
            BYPASS_EN: u1,
            /// Stop Clock Control When receiving data, if CARD_RD_THLD_ENB is set and
            /// CARD_RD_THLD is set the same with BLK_SZ, the device clock may stop at the block
            /// gap during data receiving. This field is used to control the position of the
            /// stopping clock. The value can be changed between 0x0 and 0xF, but actually, the
            /// available value and the position of the stopping clock must be decided by the
            /// actual situation. The value increases one in this field is linked to one cycle
            /// (two cycles in DDR mode) that the position of the stopping clock moved up.
            STOP_CLK_CTRL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x104);

        /// address: 0x402203c
        /// Status Register
        pub const SMHC_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO RX Water Level Flag
            /// 0: FIFO does not reach the receive trigger level.
            /// 1: FIFO reaches the receive trigger level.
            FIFO_RX_LEVEL: u1,
            /// FIFO TX Water Level Flag
            /// 0: FIFO does not reach the transmit trigger level
            /// 1: FIFO reaches the transmit trigger level
            FIFO_TX_LEVEL: u1,
            /// FIFO Empty
            /// 0: FIFO is not empty
            /// 1: FIFO is empty
            FIFO_EMPTY: u1,
            /// FIFO Full
            /// 0: FIFO is not full
            /// 1: FIFO is full
            FIFO_FULL: u1,
            /// Command FSM States
            /// 0000: Idle
            /// 0001: Send init sequence
            /// 0010: TX CMD start bit
            /// 0011: TX CMD TX bit
            /// 0100: TX CMD index + argument
            /// 0101: TX CMD CRC7
            /// 0110: TX CMD end bit
            /// 0111: RX response start bit
            /// 1000: RX response IRQ response
            /// 1001: RX response TX bit
            /// 1010: RX response CMD index
            /// 1011: RX response data
            /// 1100: RX response CRC7
            /// 1101: RX response end bit
            /// 1110: CMD path wait NCC
            /// 1111: Wait; CMD-to-response turn around
            FSM_STA: u4,
            /// Data[3] Status The level of DATA[3], checks whether the card is present.
            /// 0: The card is not present.
            /// 1: The card is present.
            CARD_PRESENT: u1,
            /// Card Data Busy Inverted version of DATA[0]
            /// 0: Card data is not busy.
            /// 1: Card data is busy.
            CARD_BUSY: u1,
            /// Data FSM Busy Data transmit or receive state-machine is busy.
            FSM_BUSY: u1,
            /// Response Index Index of previous response, including any auto-stop sent by the
            /// controller.
            RESP_IDX: u6,
            /// FIFO Level Number of filled locations in FIFO
            FIFO_LEVEL: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DMA Request DMA request signal state
            DMA_REQ: u1,
        }), base_address + 0x3c);

        /// address: 0x4022048
        /// SMHC_TBC0
        pub const SMHC_TBC0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transferred Count 0 The number of bytes transferred between the card and
            /// internal FIFO. The register should be accessed in full to avoid read-coherency
            /// problems and read only after the data transfer completes.
            TBC0: u32,
        }), base_address + 0x48);

        /// address: 0x402204c
        /// SMHC_TBC1
        pub const SMHC_TBC1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transferred Count 1 The number of bytes transferred between the Host/DMA memory
            /// and internal FIFO. The register should be accessed in full to avoid
            /// read-coherency problems and read only after the data transfer completes.
            TBC1: u32,
        }), base_address + 0x4c);

        /// address: 0x4022100
        /// Card Threshold Control Register
        pub const SMHC_THLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Card Read Threshold Enable
            /// 0: Card read threshold disabled
            /// 1: Card read threshold enabled Host controller initiates Read Transfer only if
            /// the CARD_RD_THLD amount of space is available in receive FIFO.
            CARD_RD_THLD_ENB: u1,
            /// Busy Clear Interrupt Generation
            /// 0: Busy clear interrupt disabled
            /// 1: Busy clear interrupt enabled The application can disable this feature if it
            /// does not want to wait for a Busy Clear Interrupt.
            BCIG: u1,
            /// Card Write Threshold Enable
            /// 0: Card write threshold disabled
            /// 1: Card write threshold enabled Host controller initiates write transfer only if
            /// the card threshold amount of data is available in transmit FIFO.
            CARD_WR_THLD_ENB: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Card Read/Write Threshold Size
            CARD_WR_THLD: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x100);

        /// address: 0x4022008
        /// Time Out Register
        pub const SMHC_TMOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Response Timeout Limit
            RTO_LMT: u8,
            /// Data Timeout Limit This field can set the time that the host waits for the data
            /// from the device. Ensure to communicate with the device, this field must be set
            /// to the maximum that is greater than the time . About the , the explanation is as
            /// follows: When Host read data, data transmission from the Device starts after the
            /// access time delay beginning from the end bit of the read command (ACMD51, CMD8,
            /// CMD17, and CMD18). When the host reads multiple block (CMD18), a next block’s
            /// data transmission from the Device starts after the access time delay beginning
            /// from the end bit of the previous block. When the host writes data, the value is
            /// no effect.
            DTO_LMT: u24,
        }), base_address + 0x8);
    };

    /// TCON_LCD0
    pub const TCON_LCD0 = struct {
        pub const base_address = 0x5461000;

        /// address: 0x5461228
        /// FSYNC_GEN_CTRL_REG
        pub const FSYNC_GEN_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Fsync Generate Enable
            /// 0: Disable
            /// 1: Enable
            FSYNC_GEN_EN: u1,
            /// Select Vsync Enable
            /// 0: Select vsync falling edge to start state machine
            /// 1: Select vsync rising edge to start state machine
            SEL_VSYNC_EN: u1,
            /// Hsync Polarity Select
            /// 0: Normal
            /// 1: Opposite hsync to hysnc counter
            HSYNC_POL_SEL: u1,
            reserved0: u1,
            /// Sensor Disable Value
            /// 0: Fsync disable period output 0
            /// 1: Fsync disable period output 1
            SENSOR_DIS_VALUE: u1,
            /// Sensor Active0 Value
            /// 0: Fsync active_0 period output 0
            /// 1: Fsync active_0 period output 1
            SENSOR_ACT0_VALUE: u1,
            /// Sensor Active1 Value
            /// 0: Fsync active_1 period output 0
            /// 1: Fsync active_1 period output 1
            SENSOR_ACT1_VALUE: u1,
            reserved1: u1,
            /// Delay 0–2047 Hsync Period When hsync_pol_sel is 0, the actual delay is
            /// sensor_dis_time-1. When hsync_pol_sel is 1, the actual delay is sensor_dis_time.
            SENSOR_DIS_TIME: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x228);

        /// address: 0x546122c
        /// FSYNC_GEN_DLY_REG
        pub const FSYNC_GEN_DLY_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delay 0–4095 Pixel clk Period The actual delay is sensor_act1_time+1.
            SENSOR_ACT1_TIME: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Delay 0–4095 Pixel clk Period The actual delay is sensor_act0_time+1.
            SENSOR_ACT0_TIME: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x22c);

        /// address: 0x546103c
        /// LCD 3D FIFO Register
        pub const LCD_3D_FIFO_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the work mode of 3D FIFO
            /// 00: Bypass
            /// 01: Used as normal FIFO
            /// 10: Used as 3D interlace FIFO
            /// 11: Reserved
            @"3D_FIFO": u2,
            reserved0: u1,
            reserved1: u1,
            /// The number of data in half line=3D_FIFO_HALF_LINE_SIZE+1, only valid when
            /// 3D_FIFO_SETTING is set as 2.
            @"3D_FIFO_HALF_LINE_SIZE": u10,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Enable the 3D fifo bist test function
            /// 0: Disable
            /// 1: Enable
            @"3D_FIFO_BIST_EN": u1,
        }), base_address + 0x3c);

        /// address: 0x5461048
        /// LCD Basic Timing Register0
        pub const LCD_BASIC0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Panel height is Y+1
            HEIGHT_Y: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Panel width is X+1
            WIDTH_X: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x48);

        /// address: 0x546104c
        /// LCD Basic Timing Register1
        pub const LCD_BASIC1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal back porch (in dclk) Thbp = (HBP +1) * Tdclk
            HBP: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Thcycle = (HT+1) * Tdclk Computation: 1) parallel: HT = X + BLANK Limitation: 1)
            /// parallel: HT >= (HBP +1) + (X+1) +2 2) serial 1: HT >= (HBP +1) + (X+1) *3+2 3)
            /// serial 2: HT >= (HBP +1) + (X+1) *3/2+2
            HT: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4c);

        /// address: 0x5461050
        /// LCD Basic Timing Register2
        pub const LCD_BASIC2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tvbp = (VBP +1) * Thsync
            VBP: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TVT = (VT)/2 * Thsync VT/2 >= (VBP+1 ) + (Y+1) +2
            VT: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x50);

        /// address: 0x5461054
        /// LCD Basic Timing Register3
        pub const LCD_BASIC3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tvspw = (VSPW+1) * Thsync VT/2 > (VSPW+1)
            VSPW: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Thspw = (HSPW+1) * Tdclk HT > (HSPW+1)
            HSPW: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x54);

        /// address: 0x5461110
        /// LCD CEU Coefficient Register0 (N=0–10)
        pub const LCD_CEU_COEF_MUL_REG = @intToPtr(*volatile [11]Mmio(32, packed struct {
            /// Signed 13-bit value, range of (-16,16). N=0: Rr N=1: Rg N=2: Rb N=4: Gr N=5: Gg
            /// N=6: Gb N=8: Br N=9: Bg N=10: Bb
            CEU_COEF_MUL_VALUE: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x110);

        /// address: 0x5461100
        /// LCD CEU Control Register
        pub const LCD_CEU_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// BT656 F Mask Value
            BT656_F_MASK_VALUE: u1,
            /// BT656 F Mask
            /// 0: Disable
            /// 1: Enable
            BT656_F_MASK: u1,
            /// Enable CEU function
            /// 0: Bypass
            /// 1: Enable
            CEU_EN: u1,
        }), base_address + 0x100);

        /// address: 0x5461180
        /// LCD Color Map Control Register
        pub const LCD_CMAP_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the pixel output format in color map function.
            /// 0: 4 pixel output mode: Out0 -> Out1 -> Out2 -> Out3
            /// 1: 2 pixel output mode: Out0 -> Out1
            OUT_FORMAT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// Enable the color map function. This module only works when X is divided by 4.
            /// 0: Bypass
            /// 1: Enable
            COLOR_MAP_EN: u1,
        }), base_address + 0x180);

        /// address: 0x5461198
        /// LCD Color Map Even Line Register0
        pub const LCD_CMAP_EVEN0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_EVEN0: u16,
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_EVEN1: u16,
        }), base_address + 0x198);

        /// address: 0x546119c
        /// LCD Color Map Even Line Register1
        pub const LCD_CMAP_EVEN1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1
            /// 0111: Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_EVEN2: u16,
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_EVEN3: u16,
        }), base_address + 0x19c);

        /// address: 0x5461190
        /// LCD Color Map Odd Line Register0
        pub const LCD_CMAP_ODD0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_ODD0: u16,
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_ODD1: u16,
        }), base_address + 0x190);

        /// address: 0x5461194
        /// LCD Color Map Odd Line Register1
        pub const LCD_CMAP_ODD1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_ODD2: u16,
            /// Indicates the output order of components. bit15-12: Reserved bit11-08:
            /// Out_Odd0[23:16] bit07-04: Out_Odd0[15:8] bit03-00: Out_Odd0[7:0]
            /// 0000: in_b0
            /// 0001: in_g0
            /// 0010: in_r0
            /// 0011: Reserved
            /// 0100: in_b1
            /// 0101: in_g1
            /// 0110: in_r1 0111:Reserved
            /// 1000: in_b2
            /// 1001: in_g2
            /// 1010: in_r2
            /// 1011: Reserved
            /// 1100: in_b3
            /// 1101: in_g3
            /// 1110: in_r3
            /// 1111: Reserved
            OUT_ODD3: u16,
        }), base_address + 0x194);

        /// address: 0x5461060
        /// LCD CPU Panel Interface Register
        pub const LCD_CPU_IF_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable trigger mode
            /// 0: Trigger mode disable
            /// 1: Trigger mode enable
            TRI_EN: u1,
            /// Software must make sure that write ‘1’ only when this flag is ‘0’.
            /// Writing ‘1’ starts a frame flush and writing ’0’ has no effect. This
            /// flag indicates the frame flush is running.
            TRI_START: u1,
            /// Enable the trigger FIFO
            /// 0: Disable
            /// 1: Enable
            TRI_FIFO_EN: u1,
            /// Entry address is 0xFF8
            /// 0: Disable
            /// 1: Enable
            TRI_FIFO_BIST_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Direct transfer mode If it is enabled, FIFO1 is regardless of the HV timing, the
            /// pixels data keep being transferred unless the input FIFO was empty. Data output
            /// rate is controlled by DCLK.
            FLUSH: u1,
            /// Auto transfer mode If it is 1, all the valid data during this frame are written
            /// to panel. Note: This bit is sampled by Vsync.
            AUTO: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// The status of read operation.
            /// 0: Read operation is finishing
            /// 1: Read operation is pending
            RD_FLAG: u1,
            /// The status of write operation.
            /// 0: Write operation is finishing
            /// 1: Write operation is pending
            WR_FLAG: u1,
            reserved16: u1,
            /// Pin A1 value in 8080 mode WR/RD execute
            CA: u1,
            /// Pin A1 value in 8080 mode auto/flash states
            DA: u1,
            reserved17: u1,
            /// Set the cpu interface work mode
            /// 0000: 18-bit/256K mode
            /// 0010: 16-bit mode0
            /// 0100: 16-bit mode1
            /// 0110: 16-bit mode2
            /// 1000: 16-bit mode3
            /// 1010: 9-bit mode
            /// 1100: 8-bit 256K mode
            /// 1110: 8-bit 65K mode
            /// xxx1: 24-bit for DSI
            CPU_MODE: u4,
        }), base_address + 0x60);

        /// address: 0x5461068
        /// LCD CPU Panel Read Data Register0
        pub const LCD_CPU_RD0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data read on 8080 bus, launch a new read operation on 8080 bus.
            DATA_RD0: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x68);

        /// address: 0x546106c
        /// LCD CPU Panel Read Data Register1
        pub const LCD_CPU_RD1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data read on 8080 bus, without a new read operation on 8080 bus.
            DATA_RD1: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x5461160
        /// LCD CPU Panel Trigger Register0
        pub const LCD_CPU_TRI0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The size of data block. It is usually set as X.
            BLOCK_SIZE: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// The spaces between data blocks. It should be set >20*pixel.
            BLOCK_SPACE: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x160);

        /// address: 0x5461164
        /// LCD CPU Panel Trigger Register1
        pub const LCD_CPU_TRI1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The number of data blocks. It is usually set as Y.
            BLOCK_NUM: u16,
            /// Shows the current data block transmitting to panel.
            BLOCK_CURRENT_NUM: u16,
        }), base_address + 0x164);

        /// address: 0x5461168
        /// LCD CPU Panel Trigger Register2
        pub const LCD_CPU_TRI2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Usual set as the length of a line.
            TRANS_START_SET: u13,
            /// Set the sync mode in CPU interface.
            /// 0x: Auto
            /// 10: 0
            /// 11: 1
            SYNC_MODE: u2,
            /// Select the FIFOs used in CPU mode.
            /// 0: ECC_FIFO+TRI_FIFO
            /// 1: TRI_FIFO
            TRANS_START_MODE: u1,
            /// T = (Start_Delay +1) * be_clk*8.
            START_DLY: u16,
        }), base_address + 0x168);

        /// address: 0x546116c
        /// LCD CPU Panel Trigger Register3
        pub const LCD_CPU_TRI3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of counter factor
            COUNTER_M: u8,
            /// The value of counter factor
            COUNTER_N: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// When set as 01, the Tri_Counter_Int occurs in cycle of
            /// (Count_N+1)×(Count_M+1)×4 dclk. When set as 10 or 11, the io0 is map as TE
            /// input.
            /// 00: Disable
            /// 01: Counter mode
            /// 10: Te rising mode
            /// 11: Te falling mode
            TRI_INT_MODE: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x16c);

        /// address: 0x5461170
        /// LCD CPU Panel Trigger Register4
        pub const LCD_CPU_TRI4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Valid in first Block.
            D23_TO_D0_FIRST_VALID: u24,
            /// Valid in first Block.
            A1_FIRST_VALID: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Enable the plug mode used in dsi command mode.
            /// 0: Disable
            /// 1: Enable
            PLUG_MODE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x170);

        /// address: 0x5461174
        /// LCD CPU Panel Trigger Register5
        pub const LCD_CPU_TRI5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Valid in Block except first.
            D23_TO_D0_NON_FIRST_VALID: u24,
            /// Valid in Block except first.
            A1_NON_FIRST_VALID: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x174);

        /// address: 0x5461064
        /// LCD CPU Panel Write Data Register
        pub const LCD_CPU_WR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data write on 8080 bus, launch a write operation on 8080 bus.
            DATA_WR: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x64);

        /// address: 0x5461040
        /// LCD Control Register
        pub const LCD_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LCD Source Select
            /// 000: DE
            /// 001: Color Check
            /// 010: Grayscale Check
            /// 011: Black by White Check
            /// 100: Test Data all 0
            /// 101: Test Data all 1
            /// 110: Reversed
            /// 111: Gridding Check
            LCD_SRC_SEL: u3,
            reserved0: u1,
            /// The unit of delay is T . Note: Valid only when LCD_EN == 1
            LCD_START_DLY: u5,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// This flag is valid only when LCD_EN == 1
            /// 0: Disable
            /// 1: Enable
            LCD_INTERLACE_EN: u1,
            /// Writing 1 and then 0 to this bit will reset FIFO 1 Note: 1 holding time must
            /// more than 1 DCLK
            LCD_FIFO1_RST: u1,
            reserved12: u1,
            /// Enable the function to swap red data and blue data in fifo1.
            /// 0: Default
            /// 1: Swap RED and BLUE data at FIFO1
            LCD_RB_SWAP: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// It executes at the beginning of the first blank line of LCD timing.
            /// 0: Disable
            /// 1: Enable
            LCD_EN: u1,
        }), base_address + 0x40);

        /// address: 0x5461044
        /// LCD Data Clock Register
        pub const LCD_DCLK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tdclk = Tsclk/DCLKDIV Note: 1.If dclk1&dclk2 are used, DCLKDIV >=6 2.If only
            /// dclk is used, DCLKDIV >=1
            LCD_DCLK_DIV: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// LCD clock enable
            /// 0000: dclk_en = 0; dclk1_en = 0; dclk2_en = 0; dclkm2_en = 0;
            /// 0001: dclk_en = 1; dclk1_en = 0; dclk2_en = 0; dclkm2_en = 0;
            /// 0010: dclk_en = 1; dclk1_en = 0; dclk2_en = 0; dclkm2_en = 1;
            /// 0011: dclk_en = 1; dclk1_en = 1; dclk2_en = 0; dclkm2_en = 0;
            /// 0101: dclk_en = 1; dclk1_en = 0; dclk2_en = 1; dclkm2_en = 0;
            /// 1111: dclk_en = 1; dclk1_en = 1; dclk2_en = 1; dclkm2_en = 1; Others:Reversed
            LCD_DCLK_EN: u4,
        }), base_address + 0x44);

        /// address: 0x54610fc
        /// LCD Debug Register
        pub const LCD_DEBUG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// The current scan line
            LCD_CURRENT_LINE: u12,
            reserved16: u1,
            /// The flag indicates the current field polarity
            /// 0: Second field
            /// 1: First field
            LCD_FIELD_POL: u1,
            reserved17: u1,
            /// The flag shows whether the fifos in underflow status
            /// 0: Not underflow
            /// 1: Underflow
            LCD_FIFO_UNDERFLOW: u1,
        }), base_address + 0xfc);

        /// address: 0x5461010
        /// LCD FRM Control Register
        pub const LCD_FRM_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the test mode of dither function
            /// 00: FRM
            /// 01: Half 5-/6-bit, half FRM
            /// 10: Half 8-bit, half FRM
            /// 11: Half 8-bit, half 5-/6-bit
            LCD_FRM_TEST: u2,
            reserved0: u1,
            reserved1: u1,
            /// The B component output bits in dither function
            /// 0: 6-bit frm output
            /// 1: 5-bit frm output
            LCD_FRM_MODE_B: u1,
            /// The G component output bits in dither function
            /// 0: 6-bit frm output
            /// 1: 5-bit frm output
            LCD_FRM_MODE_G: u1,
            /// The R component output bits in dither function
            /// 0: 6-bit frm output
            /// 1: 5-bit frm output
            LCD_FRM_MODE_R: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// Enable the dither function
            /// 0: Disable
            /// 1: Enable
            LCD_FRM_EN: u1,
        }), base_address + 0x10);

        /// address: 0x546102c
        /// LCD FRM Table Register (N=0,1,2,3)
        pub const LCD_FRM_TAB_REG = @intToPtr(*volatile [4]Mmio(32, packed struct {
            /// Set the data used in dither function Usually set as follows: Table0 = 0x01010000
            /// Table1 = 0x15151111 Table2 = 0x57575555 Table3 = 0x7f7f7777
            FRM_TABLE_VALUE: u32,
        }), base_address + 0x2c);

        /// address: 0x5461400
        /// LCD Gamma Table Register
        pub const LCD_GAMMA_TABLE_REG = @intToPtr(*volatile [256]Mmio(32, packed struct {
            /// Blue Component
            BLUE_COMP: u8,
            /// Green Component
            GREEN_COMP: u8,
            /// Red Component
            RED_COMP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x400);

        /// address: 0x5461000
        /// LCD Global Control Register
        pub const LCD_GCTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// Enable the Gamma correction function.
            /// 0: Disable
            /// 1: Enable
            LCD_GAMMA_EN: u1,
            /// When it is disabled, the module will be reset to idle state.
            /// 0: Disable
            /// 1: Enable
            LCD_EN: u1,
        }), base_address + 0x0);

        /// address: 0x5461004
        /// LCD Global Interrupt Register0
        pub const LCD_GINT0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Asserted at the fsync signal in every frame Write 0 to clear it.
            FSYNC_INT_FLAG: u1,
            /// Asserted at the first valid line in every frame Write 0 to clear it.
            DE_INT_FLAG: u1,
            /// Enable the fsync interrupt to set signal inverse polarity. When FSYNC is
            /// positive, this bit must be 1. And vice versa.
            FSYNC_INT_INV: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Only used in dsi video mode, tri when sync by dsi but not finish Write 0 to
            /// clear it.
            LCD_TRI_UNDERFLOW_FLAG: u1,
            /// Trigger when tri counter reaches this value Write 0 to clear it.
            LCD_TRI_COUNTER_INT_FLAG: u1,
            /// Trigger when cpu trigger mode finished Write 0 to clear it.
            LCD_TRI_FINISH_INT_FLAG: u1,
            reserved6: u1,
            /// Trigger when SY0 match the current LCD scan line Write 0 to clear it.
            LCD_LINE_INT_FLAG: u1,
            reserved7: u1,
            /// Asserted during vertical no-display period every frame Write 0 to clear it.
            LCD_VB_INT_FLAG: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Enable the trigger counter interrupt
            /// 0: Disable
            /// 1: Enable
            LCD_TRI_COUNTER_INT_EN: u1,
            /// Enable the trigger finish interrupt
            /// 0: Disable
            /// 1: Enable
            LCD_TRI_FINISH_INT_EN: u1,
            reserved18: u1,
            /// Enable the line interrupt
            /// 0: Disable
            /// 1: Enable
            LCD_LINE_INT_EN: u1,
            reserved19: u1,
            /// Enable the Vb interrupt
            /// 0: Disable
            /// 1: Enable
            LCD_VB_INT_EN: u1,
        }), base_address + 0x4);

        /// address: 0x5461008
        /// LCD Global Interrupt Register1
        pub const LCD_GINT1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Scan line for LCD line trigger (including inactive lines). Setting it for the
            /// specified line for trigger0. Note: SY0 is writable only when LINE_TRG0 is
            /// disabled.
            LCD_LINE_INT_NUM: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x8);

        /// address: 0x5461058
        /// LCD HV Panel Interface Register
        pub const LCD_HV_IF_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// LCD convert source from RGB to YUV.
            /// 0: Enable
            /// 1: Disable Only valid when HV mode is “1100”.
            CCIR_CSC_DIS: u1,
            /// Set the delay line mode.
            /// 00: F toggle right after active video line
            /// 01: delay 2 line (CCIR PAL)
            /// 10: delay 3 line (CCIR NTSC)
            /// 11: reserved
            YUV_EAV_SAV_F_LINE_DLY: u2,
            /// Serial YUV mode Output sequence 2-pixel-pair of every scan line.
            /// 00: YUYV
            /// 01: YVYU
            /// 10: UYVY
            /// 11: VYUY
            YUV_SM: u2,
            /// Serial RGB888 mode Output sequence at even lines of the panel (line 2, 4, 6,
            /// 8…).
            /// 00: R→G→B
            /// 01: B→R→G
            /// 10: G→B→R
            /// 11: R→G→B
            RGB888_EVEN_ORDER: u2,
            /// Serial RGB888 mode Output sequence at odd lines of the panel (line 1, 3, 5,
            /// 7…).
            /// 00: R→G→B
            /// 01: B→R→G
            /// 10: G→B→R
            /// 11: R→G→B
            RGB888_ODD_ORDER: u2,
            /// Set the HV mode of LCD controller
            /// 0000: 24-bit/1-cycle parallel mode
            /// 1000: 8-bit/3-cycle RGB serial mode (RGB888)
            /// 1010: 8-bit/4-cycle Dummy RGB (DRGB)
            /// 1011: 8-bit/4-cycle RGB Dummy (RGBD)
            /// 1100: 8-bit/2-cycle YUV serial mode (CCIR656)
            HV_MODE: u4,
        }), base_address + 0x58);

        /// address: 0x5461088
        /// LCD IO Polarity Register
        pub const LCD_IO_POL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LCD output port D[23:0] polarity control, with independent bit control.
            /// 0: Normal polarity
            /// 1: Invert the specify output
            DATA_INV: u24,
            /// Enable invert function of IO0
            /// 0: Not invert
            /// 1: Invert
            IO0_INV: u1,
            /// Enable invert function of IO1
            /// 0: Not invert
            /// 1: Invert
            IO1_INV: u1,
            /// Enable invert function of IO2
            /// 0: Not invert
            /// 1: Invert
            IO2_INV: u1,
            /// Enable invert function of IO3
            /// 0: Not invert
            /// 1: Invert
            IO3_INV: u1,
            /// Set the phase offset of clock and data in hv mode.
            /// 000: Used DCLK0 (normal phase offset)
            /// 001: Used DCLK1 (1/3 phase offset)
            /// 010: Used DCLK2 (2/3 phase offset)
            /// 100: DCLK0/2 phase 0
            /// 101: DCLK0/2 phase 90 Others: Reserved
            DCLK_SEL: u3,
            /// When it is set as ‘1’, the d[23:0], io0, io1, io3 are sync to dclk.
            /// 0: Normal output
            /// 1: Register output
            IO_OUTPUT_SEL: u1,
        }), base_address + 0x88);

        /// address: 0x546108c
        /// LCD IO Control Register
        pub const LCD_IO_TRI_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LCD output port D[23:0] output enable, with independent bit control.
            /// 1: Disable
            /// 0: Enable
            DATA_OUTPUT_TRI_EN: u24,
            /// Enable the output of IO0
            /// 1: Disable
            /// 0: Enable
            IO0_OUTPUT_TRI_EN: u1,
            /// Enable the output of IO1
            /// 1: Disable
            /// 0: Enable
            IO1_OUTPUR_TRI_EN: u1,
            /// Enable the output of IO2
            /// 1: Disable
            /// 0: Enable
            IO2_OUTPUT_TRI_EN: u1,
            /// Enable the output of IO3
            /// 1: Disable
            /// 0: Enable
            IO3_OUTPUT_TRI_EN: u1,
            /// Set the endian of data bits
            /// 0: Normal
            /// 1: Bits_invert
            RGB_ENDIAN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x8c);

        /// address: 0x5461220
        /// LCD_LVDS_ANA0_REG
        pub const LCD_LVDS_ANA0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LVDS data channel [3:0] direction.
            /// 0: Normal
            /// 1: Reverse
            LVDS_REG_PLR: u4,
            /// LVDS clock channel direction.
            /// 0: Normal
            /// 1: Reverse
            LVDS_REG_PLRC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Adjust current flowing through R of R to change the common signals amplitude.
            /// 000: 0.925 V
            /// 001: 0.950 V
            /// 010: 0.975 V
            /// 011: 1.000 V
            /// 100: 1.025 V
            /// 101: 1.050 V
            /// 110: 1.075 V
            /// 111: 1.100 V
            LVDS_REG_R: u3,
            reserved3: u1,
            /// Choose data output or PLL test clock output in LVDS_tx.
            LVDS_REG_DEN: u4,
            /// Choose data output or PLL test clock output in LVDS_tx.
            LVDS_REG_DENC: u1,
            /// Adjust current flowing through Rload of Rx to change the differential signals
            /// amplitude.
            /// 000: 216 mV
            /// 001: 252 mV
            /// 010: 276 mV
            /// 011: 312 mV
            /// 100: 336 mV
            /// 101: 372 mV
            /// 110: 395 mV
            /// 111: 432 mV
            LVDS_REG_C: u3,
            /// Enable data channel[3:0] drive
            /// 0: Disable
            /// 1: Enable
            LVDS_HPREN_DRV: u4,
            /// Enable clock channel drive
            /// 0: Disable
            /// 1: Enable
            LVDS_HPREN_DRVC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Enable the 24M clock
            EN_24M: u1,
            /// Enable LVDS
            EN_LVDS: u1,
            reserved7: u1,
            /// Enable the bias circuit of the LVDS_Ana module.
            /// 0: Disable
            /// 1: Enable
            LVDS_EN_MB: u1,
        }), base_address + 0x220);

        /// address: 0x5461084
        /// LCD LVDS Configure Register
        pub const LCD_LVDS_IF_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the data polarity of LVDS
            /// 0: Reverse
            /// 1: Normal
            LCD_LVDS_DATA_POL: u4,
            /// Set the clock polarity of LVDS
            /// 0: Reverse
            /// 1: Normal
            LCD_LVDS_CLK_POL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Select the clock source of LVDS
            /// 0: Reserved
            /// 1: LCD CLK
            LCD_LVDS_CLK_SEL: u1,
            reserved15: u1,
            reserved16: u1,
            /// Set the LVDS correct mode
            /// 0: Mode0
            /// 1: Mode1
            LCD_LVDS_CORRECT_MODE: u1,
            /// Set the output signal in debug mode
            /// 0: Mode0—Random data
            /// 1: Mode1—Output CLK period=7/2 LVDS CLK period
            LCD_LVDS_DEBUG_MODE: u1,
            /// Enable LVDS debug function
            /// 0: Disable
            /// 1: Enable
            LCD_LVDS_DEBUG_EN: u1,
            /// Set the bit width of data
            /// 0: 24-bit
            /// 1: 18-bit
            LCD_LVDS_BITWIDTH: u1,
            /// Set the LVDS data mode
            /// 0: NS mode
            /// 1: JEIDA mode
            LCD_LVDS_MODE: u1,
            /// Set the LVDS direction
            /// 0: Normal
            /// 1: Reverse
            LCD_LVDS_DIR: u1,
            /// Set the order of even field and odd field
            /// 0: normal
            /// 1: reverse
            LCD_LVDS_EVEN_ODD_DIR: u1,
            /// Select work in single link mode or dual link mode
            /// 0: Single link
            /// 1: Dual link
            LCD_LVDS_LINK: u1,
            /// Enable LVDS interface
            /// 0: Disable
            /// 1: Enable
            LCD_LVDS_EN: u1,
        }), base_address + 0x84);

        /// address: 0x54611f0
        /// LCD Safe Period Register
        pub const LCD_SAFE_PERIOD_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Select the save mode
            /// 000: unsafe
            /// 001: safe
            /// 010: safe at FIFO_CURR_NUM > SAFE_PERIOD_FIFO_NUM
            /// 011: safe at 2 and safe at sync active
            /// 100: safe at line
            SAFE_PERIOD_MODE: u3,
            reserved0: u1,
            /// Set a fixed line and during the line time, the LCD controller allow dram
            /// controller to change frequency. The fixed line should be set in the blanking
            /// area.
            SAFE_PERIOD_LINE: u12,
            /// When the data length in line buffer is more than SAFE_PERIOD_FIFO_NUM, the LCD
            /// controller will allow dram controller to stop working to change frequency.
            SAFE_PERIOD_FIFO_NUM: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x1f0);

        /// address: 0x5461238
        /// LCD Slave Stop Position Register
        pub const LCD_SLAVE_STOP_POS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the stop position of the slave LCD. This value is the number of pixels
            /// between the stop position and the end of the HFP. Stop_pos = HFP - Stop_val.
            /// 0<Stop_pos<HFP-2 Note: Only use in Single DSI mode.
            STOP_VAL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x238);

        /// address: 0x5461230
        /// LCD Sync Control Register
        pub const LCD_SYNC_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LCD Controller Sync Mode
            /// 0: Sync in the first time
            /// 1: Sync every frame Note: Only use in Single DSI mode.
            LCD_CTRL_SYNC_MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// LCD Controller Sync Master Slave
            /// 0: Master
            /// 1: Slave Note: Only use in Single DSI mode.
            LCD_CYRL_SYNC_MASTER_SLAVE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LCD Controller Work mode
            /// 0: Single DSI mode
            /// 1: Dual DSI mode
            LCD_CTRL_WORK_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x230);

        /// address: 0x5461234
        /// LCD Sync Position Register
        pub const LCD_SYNC_POS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the line number of master LCD controller which is used to trigger the slave
            /// LCD controller to start working. Note:It is only set in master LCD controller.It
            /// is not necessarily to set in slave LCD controller. Tri pos =
            /// Tline*LCD_Sync_Line_Num+Tpixel*(HT-LCD_Sync_Pixel_Num) Note: Only use in Single
            /// DSI mode.
            LCD_SYNC_LINE_NUM: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Set the pixel number of master LCD controller which is used to trigger the slave
            /// LCD controller to start working.This value is the number of pixels between the
            /// trigger point and the end of the line. Tri pos =
            /// Tline*LCD_Sync_Line_Num+Tpixel*(HT-LCD_Sync_Pixel_Num) Note: Only use in Single
            /// DSI mode.
            LCD_SYNC_PIXEL_NUM: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x234);

        /// address: 0x5461014
        /// xNx[%s]
        pub const xNx = @intToPtr(*volatile [6]Mmio(32, packed struct {
            /// Set the seed used in dither function N=0: Pixel_Seed_R N=1: Pixel_Seed_G N=2:
            /// Pixel_Seed_B N=3: Line_Seed_R N=4: Line_Seed_G N=5: Line_Seed_B Note: Avoid
            /// setting it to 0.
            SEED_VALUE: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x14);

        pub const _N = @ptrCast(*volatile [3]packed struct {
            /// LCD CEU Coefficient Register1 (N=0,1,2)
            LCD_CEU_COEF_ADD_REG: Mmio(32, packed struct {
                /// Signed 19-bit value, range of (-16384, 16384). N=0: Rc N=1: Gc N=2: Bc
                CEU_COEF_ADD_VALUE: u19,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
            }),

            /// LCD CEU Coefficient Register2 (N=0,1,2)
            LCD_CEU_COEF_RANG_REG: Mmio(32, packed struct {
                /// Unsigned 8-bit value, range of [0, 255].
                CEU_COEF_RANGE_MAX: u8,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                /// Unsigned 8-bit value, range of [0, 255].
                CEU_COEF_RANGE_MIN: u8,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }),
            padding0: u64,
        }, base_address + 0x11c);
    };

    /// GPADC
    pub const GPADC = struct {
        pub const base_address = 0x2009000;

        /// address: 0x2009018
        /// GPADC Calibration Data Register
        pub const GP_CDATA = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x18);

        /// address: 0x2009040
        /// GPADC CH0 Compare Data Register
        pub const GP_CH0_CMP_DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Voltage Low Value
            CH0_CMP_LOW_DATA: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel 0 Voltage High Value
            CH0_CMP_HIG_DATA: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x40);

        /// address: 0x2009080
        /// GPADC CH0 Data Register
        pub const GP_CH0_DATA = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x80);

        /// address: 0x2009044
        /// GPADC CH1 Compare Data Register
        pub const GP_CH1_CMP_DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 1 Voltage Low Value
            CH1_CMP_LOW_DATA: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Channel 1 Voltage High Value
            CH1_CMP_HIG_DATA: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x44);

        /// address: 0x2009084
        /// GPADC CH1 Data Register
        pub const GP_CH1_DATA = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x84);

        /// address: 0x2009008
        /// GPADC Compare and Select Enable Register
        pub const GP_CS_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog Input Channel 0 Select
            /// 0: Disable
            /// 1: Enable
            ADC_CH0_SELECT: u1,
            /// Analog Input Channel 1 Select
            /// 0: Disable
            /// 1: Enable
            ADC_CH1_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Channel 0 Compare Enable
            /// 0: Disable
            /// 1: Enable
            ADC_CH0_CMP_EN: u1,
            /// Channel 1 Compare Enable
            /// 0: Disable
            /// 1: Enable
            ADC_CH1_CMP_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x8);

        /// address: 0x2009004
        /// GPADC Control Register
        pub const GP_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// ADC Function Enable Before the bit is enabled, configure ADC parameters
            /// including the work mode and channel number, etc.
            /// 0: Disable
            /// 1: Enable
            ADC_EN: u1,
            /// ADC Calibration
            /// 1: Start Calibration, it is cleared to 0 after calibration
            ADC_CALI_EN: u1,
            /// Work Mode
            /// 00: Single conversion mode
            /// 01: Reserved
            /// 10: Continuous conversion mode
            /// 11: Burst conversion mode
            GPADC: u2,
            /// ADC OP Bias Adjust the bandwidth of the ADC amplifier
            ADC_OP_BIAS: u2,
            reserved16: u1,
            /// ADC Auto Calibration
            ADC_AUTOCALI_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x2009024
        /// GPADC Data High Interrupt Configure Register
        pub const GP_DATAH_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Voltage High Available Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            CH0_HIG_IRQ_EN: u1,
            /// Channel 1 Voltage High Available Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            CH1_HIG_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x24);

        /// address: 0x2009034
        /// GPADC Data High Interrupt Status Register
        pub const GP_DATAH_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: No Pending IRQ
            /// 1: Channel 0 Voltage High Available Pending IRQ Write ‘1’ to clear this
            /// interrupt or automatically clear if the interrupt condition fails.
            CH0_HIG_PENGDING: u1,
            /// 0: No Pending IRQ
            /// 1: Channel 1 Voltage High Available Pending IRQ Write ‘1’ to clear this
            /// interrupt or automatically clear if the interrupt condition fails.
            CH1_HIG_PENGDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x34);

        /// address: 0x2009020
        /// GPADC Data Low Interrupt Configure Register
        pub const GP_DATAL_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Voltage Low Available Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            CH0_LOW_IRQ_EN: u1,
            /// Channel 1 Voltage Low Available Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            CH1_LOW_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x20);

        /// address: 0x2009030
        /// GPADC Data Low Interrupt Status Register
        pub const GP_DATAL_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Voltage Low Available Interrupt Status
            /// 0: NO Pending IRQ
            /// 1: Channel 0 Voltage Low Available Pending IRQ Write ‘1’ to clear this
            /// interrupt or automatically clear if the interrupt condition fails.
            CH0_LOW_PENGDING: u1,
            /// Channel 1 Voltage Low Available Interrupt Status
            /// 0: NO Pending IRQ
            /// 1: Channel 1 Voltage Low Available Pending IRQ Write ‘1’ to clear this
            /// interrupt or automatically clear if the interrupt condition fails.
            CH1_LOW_PENGDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x30);

        /// address: 0x2009028
        /// GPADC Data Interrupt Configure Register
        pub const GP_DATA_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable
            /// 1: Enable
            CH0_DATA_IRQ_EN: u1,
            /// 0: Disable
            /// 1: Enable
            CH1_DATA_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x28);

        /// address: 0x2009038
        /// GPADC Data Interrupt Status Register
        pub const GP_DATA_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel 0 Data Available Interrupt Status
            /// 0: No Pending IRQ
            /// 1: Channel 0 Data Available Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            CH0_DATA_PENGDING: u1,
            /// Channel 1 Data Available Interrupt Status
            /// 0: No Pending IRQ
            /// 1: Channel 1 Data Available Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            CH1_DATA_PENGDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x38);

        /// address: 0x2009014
        /// GPADC FIFO Data Register
        pub const GP_FIFO_DATA = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x14);

        /// address: 0x200900c
        /// GPADC FIFO Interrupt Control Register
        pub const GP_FIFO_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC FIFO Flush Write ‘1’ to flush TX FIFO, clear automatically to ‘0’.
            FIFO_FLUSH: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Interrupt trigger level for ADC Trigger Level = TXTL + 1
            FIFO_TRIG_LEVEL: u6,
            reserved7: u1,
            reserved8: u1,
            /// ADC FIFO Data Available IRQ Enable
            /// 0: Disable
            /// 1: Enable
            FIFO_DATA_IRQ_EN: u1,
            /// ADC FIFO Overrun IRQ Enable
            /// 0: Disable
            /// 1: Enable
            FIFO_OVERRUN_IRQ_EN: u1,
            /// ADC FIFO Date DRQ Enable
            /// 0: Disable
            /// 1: Enable
            FIFO_DATA_DRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x2009010
        /// GPADC FIFO Interrupt Status Register
        pub const GP_FIFO_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// ADC FIFO available sample word counter
            RXA_CNT: u6,
            reserved8: u1,
            reserved9: u1,
            /// ADC FIFO Data Available Pending Bit
            /// 0: NO Pending IRQ
            /// 1: FIFO Available Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            FIFO_DATA_PENDING: u1,
            /// ADC FIFO Overrun IRQ Pending
            /// 0: No Pending IRQ
            /// 1: FIFO Overrun Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            FIFO_OVERRUN_PENDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);

        /// address: 0x2009000
        /// GPADC Sample Rate Configure Register
        pub const GP_SR_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC acquire time (n+1)/CLK_IN Default value: 2 us
            TACQ: u16,
            /// ADC sample frequency divider CLK_IN/(n+1) Default value: 50K
            FS_DIV: u16,
        }), base_address + 0x0);
    };

    /// HSTimer
    pub const HSTimer = struct {
        pub const base_address = 0x3008000;

        /// address: 0x3008020
        /// HS Timer0 Control Register
        pub const HS_TMR0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSTimer0 Enable
            /// 0: Stop/Pause
            /// 1: Start By setting the bit to 1, the timer will be started. It reloads the
            /// interval value register and then counts from the interval value to 0. By setting
            /// the bit to 0 before the timer counts to 0, the timer will be paused. The bit
            /// will be locked to 0 for at least 2 cycles. Within the 2 cycles, you cannot set
            /// the bit to 1 to restart the timer. The timer supports updating the interval
            /// value in the pause state. To start from the updated interval value, set both the
            /// reload bit and enable bit to 1. Additionally, in the one-shot mode, after the
            /// count value reaches 0, the system will automatically change the bit to 0 to stop
            /// the timer.
            HS_TMR0_EN: u1,
            /// HSTimer0 Reload
            /// 0: No effect
            /// 1: Reload the interval value of the HSTimer0
            HS_TMR0_RELOAD: u1,
            reserved0: u1,
            reserved1: u1,
            /// Select the pre-scale for the HSTimer0 clock sources
            /// 000: /1
            /// 001: /2
            /// 010: /4
            /// 011: /8
            /// 100: /16
            /// 101: /
            /// 110: /
            /// 111: /
            HS_TMR0_CLK: u3,
            /// Select the timing mode for HSTimer0
            /// 0: Periodic mode. When the count value is decreased to 0, the timer will restart
            /// another round of counting automatically.
            /// 1: One-shot mode. When the count value is decreased to 0, the timer will stop
            /// counting.
            HS_TMR0_MODE: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// Select the operating mode for HSTimer0
            /// 0: Normal mode
            /// 1: Test mode In the test mode, the must be set to 0x1, and acts as the initial
            /// value for HSTimer0.
            HS_TMR0_TEST: u1,
        }), base_address + 0x20);

        /// address: 0x3008030
        /// HS Timer0 Current Value High Register
        pub const HS_TMR0_CURNT_HI_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[55:32] of the HSTimer0 current value.
            HS_TMR0_CUR_VALUE_HI: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x30);

        /// address: 0x300802c
        /// HS Timer0 Current Value Low Register
        pub const HS_TMR0_CURNT_LO_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[31:0] of the HSTimer0 current value.
            HS_TMR0_CUR_VALUE_LO: u32,
        }), base_address + 0x2c);

        /// address: 0x3008028
        /// HS Timer0 Interval Value High Register
        pub const HS_TMR0_INTV_HI_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[55:32] of the HSTimer0 interval value.
            HS_TMR0_INTV_VALUE_HI: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x3008024
        /// HS Timer0 Interval Value Low Register
        pub const HS_TMR0_INTV_LO_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[31:0] of the HSTimer0 interval value.
            HS_TMR0_INTV_VALUE_LO: u32,
        }), base_address + 0x24);

        /// address: 0x3008040
        /// HS Timer1 Control Register
        pub const HS_TMR1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSTimer1 Enable
            /// 0: Stop/Pause
            /// 1: Start By setting the bit to 1, the timer will be started. It reloads the
            /// interval value register and then counts from the interval value to 0. By setting
            /// the bit to 0 before the timer counts to 0, the timer will be paused. The bit
            /// will be locked to 0 for at least 2 cycles. Within the 2 cycles, you cannot set
            /// the bit to 1 to restart the timer. The timer supports updating the interval
            /// value in the pause state. To start from the updated interval value, set both the
            /// reload bit and enable bit to 1. Additionally, in the one-shot mode, after the
            /// count value reaches 0, the system will automatically change the bit to 0 to stop
            /// the timer.
            HS_TMR1_EN: u1,
            /// HSTimer1 Reload
            /// 0: No effect
            /// 1: Reload the HSTimer1 interval value.
            HS_TMR1_RELOAD: u1,
            reserved0: u1,
            reserved1: u1,
            /// Select the pre-scale of the HSTimer1 clock sources.
            /// 000: /1
            /// 001: /2
            /// 010: /4
            /// 011: /8
            /// 100: /16
            /// 101: /
            /// 110: /
            /// 111: /
            HS_TMR1_CLK: u3,
            /// Select the timing mode for HSTimer1.
            /// 0: Periodic mode. When the count value is decreased to 0, the timer will restart
            /// another round of counting automatically.
            /// 1: One-shot mode. When the count value is decreased to 0, the timer will stop
            /// counting.
            HS_TMR1_MODE: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// Select the operating mode for HSTimer1.
            /// 0: Normal mode
            /// 1: Test mode In the test mode, the must be set to 0x1, and acts as the interval
            /// value for HSTimer1.
            HS_TMR1_TEST: u1,
        }), base_address + 0x40);

        /// address: 0x3008050
        /// HS Timer1 Current Value High Register
        pub const HS_TMR1_CURNT_HI_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[55:32] of the HSTimer1 current value
            HS_TMR1_CUR_VALUE_HI: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x50);

        /// address: 0x300804c
        /// HS Timer1 Current Value Low Register
        pub const HS_TMR1_CURNT_LO_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[31:0] of the HSTimer1 current value
            HS_TMR1_CUR_VALUE_LO: u32,
        }), base_address + 0x4c);

        /// address: 0x3008048
        /// HS Timer1 Interval Value High Register
        pub const HS_TMR1_INTV_HI_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[55:32] of the HSTimer1 interval value
            HS_TMR1_INTV_VALUE_HI: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x3008044
        /// HS Timer1 Interval Value Low Register
        pub const HS_TMR1_INTV_LO_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bit[31:0] of the HSTimer1 interval value
            HS_TMR1_INTV_VALUE_LO: u32,
        }), base_address + 0x44);

        /// address: 0x3008000
        /// HS Timer IRQ Enable Register
        pub const HS_TMR_IRQ_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSTimer0 Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            HS_TMR0_INT_EN: u1,
            /// HSTimer1 Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            HS_TMR1_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x3008004
        /// HS Timer Status Register
        pub const HS_TMR_IRQ_STAS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSTimer0 IRQ Pending The IRQ pending bit for HSTimer0. Write 1 to clear the
            /// pending status.
            /// 0: No effect
            /// 1: Pending, indicates that the initial value of the HSTimer is reached.
            HS_TMR0_IRQ_PEND: u1,
            /// HSTimer1 IRQ Pending The IRQ pending bit for HSTimer1. Write 1 to clear the
            /// pending status.
            /// 0: No effect
            /// 1: Pending, indicates that the initial value of the HSTimer is reached.
            HS_TMR1_IRQ_PEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);
    };

    /// IOMMU
    pub const IOMMU = struct {
        pub const base_address = 0x2010000;

        /// address: 0x201004c
        /// IOMMU 4KB Boundary Protect Control Register
        pub const IOMMU_4KB_BDY_PRT_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect
            M0_4KB_BDY_PRT_CTRL: u1,
            /// Master1 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect
            M1_4KB_BDY_PRT_CTRL: u1,
            /// Master2 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect
            M2_4KB_BDY_PRT_CTRL: u1,
            /// Master3 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect
            M3_4KB_BDY_PRT_CTRL: u1,
            /// Master4 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect
            M4_4KB_BDY_PRT_CTRL: u1,
            /// Master4 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect
            M5_4KB_BDY_PRT_CTRL: u1,
            /// Master6 4 KB boundary protect control bit
            /// 0: Disable 4 KB boundary protect
            /// 1: Enable 4 KB boundary protect Note: This bit is not used.
            M6_4KB_BDY_PRT_CTRL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4c);

        /// address: 0x2010040
        /// IOMMU Auto Gating Register
        pub const IOMMU_AUTO_GATING_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IOMMU circuit auto gating control The purpose is to decrease power consumption
            /// of the module.
            /// 0: Disable auto gating function
            /// 1: Enable auto gating function
            IOMMU_AUTO_GATING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x40);

        /// address: 0x2010030
        /// IOMMU Bypass Register
        pub const IOMMU_BYPASS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master0 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function Operating the register belongs to non-accurate timing
            /// sequence control function. That is, before the function is valid, master
            /// operation will complete address mapping function, and any subsequent operation
            /// will not perform address mapping. It is suggested that master is in reset state
            /// or in no any bus operation before operating the register.
            M0_BP: u1,
            /// Master1 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master1 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function
            M1_BP: u1,
            /// Master2 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master2 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function
            M2_BP: u1,
            /// Master3 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master3 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function
            M3_BP: u1,
            /// Master4 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master4 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function
            M4_BP: u1,
            /// Master5 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master5 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function
            M5_BP: u1,
            /// Master6 bypass switch After bypass function is opened, IOMMU can not map the
            /// address of Master6 sending, and directly output the virtual address to MBUS as
            /// physical address.
            /// 0: Disable bypass function
            /// 1: Enable bypass function Note: The bit is not used.
            M6_BP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x30);

        /// address: 0x20100b0
        /// IOMMU Domain Authority Control 0 Register
        pub const IOMMU_DM_AUT_CTRL0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain0 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM0_M0_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM0_M0_WT_AUT_CTRL: u1,
            /// Domain0 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM0_M1_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM0_M1_WT_AUT_CTRL: u1,
            /// Domain0 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM0_M2_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM0_M2_WT_AUT_CTRL: u1,
            /// Domain0 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM0_M3_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM0_M3_WT_AUT_CTRL: u1,
            /// Domain0 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM0_M4_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM0_M4_WT_AUT_CTRL: u1,
            /// Domain0 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM0_M5_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM0_M5_WT_AUT_CTRL: u1,
            /// Domain0 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM0_M6_RD_AUT_CTRL: u1,
            /// Domain0 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM0_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain1 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM1_M0_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM1_M0_WT_AUT_CTRL: u1,
            /// Domain1 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM1_M1_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM1_M1_WT_AUT_CTRL: u1,
            /// Domain1 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM1_M2_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM1_M2_WT_AUT_CTRL: u1,
            /// Domain1 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM1_M3_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM1_M3_WT_AUT_CTRL: u1,
            /// Domain1 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM1_M4_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM1_M4_WT_AUT_CTRL: u1,
            /// Domain1 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM1_M5_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM1_M5_WT_AUT_CTRL: u1,
            /// Domain1 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM1_M6_RD_AUT_CTRL: u1,
            /// Domain1 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM1_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xb0);

        /// address: 0x20100b4
        /// IOMMU Domain Authority Control 1 Register
        pub const IOMMU_DM_AUT_CTRL1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain2 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM2_M0_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM2_M0_WT_AUT_CTRL: u1,
            /// Domain2 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM2_M1_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM2_M1_WT_AUT_CTRL: u1,
            /// Domain2 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM2_M2_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM2_M2_WT_AUT_CTRL: u1,
            /// Domain2 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM2_M3_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM2_M3_WT_AUT_CTRL: u1,
            /// Domain2 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM2_M4_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM2_M4_WT_AUT_CTRL: u1,
            /// Domain2 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM2_M5_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM2_M5_WT_AUT_CTRL: u1,
            /// Domain2 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM2_M6_RD_AUT_CTRL: u1,
            /// Domain2 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM2_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain3 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM3_M0_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM3_M0_WT_AUT_CTRL: u1,
            /// Domain3 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM3_M1_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM3_M1_WT_AUT_CTRL: u1,
            /// Domain3 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM3_M2_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM3_M2_WT_AUT_CTRL: u1,
            /// Domain3 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM3_M3_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM3_M3_WT_AUT_CTRL: u1,
            /// Domain3 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM3_M4_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM3_M4_WT_AUT_CTRL: u1,
            /// Domain3 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM3_M5_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM3_M5_WT_AUT_CTRL: u1,
            /// Domain3 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM3_M6_RD_AUT_CTRL: u1,
            /// Domain3 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM3_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xb4);

        /// address: 0x20100b8
        /// IOMMU Domain Authority Control 2 Register
        pub const IOMMU_DM_AUT_CTRL2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain4 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM4_M0_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM4_M0_WT_AUT_CTRL: u1,
            /// Domain4 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM4_M1_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM4_M1_WT_AUT_CTRL: u1,
            /// Domain4 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM4_M2_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM4_M2_WT_AUT_CTRL: u1,
            /// Domain4 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM4_M3_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM4_M3_WT_AUT_CTRL: u1,
            /// Domain4 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM4_M4_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM4_M4_WT_AUT_CTRL: u1,
            /// Domain4 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM4_M5_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM4_M5_WT_AUT_CTRL: u1,
            /// Domain4 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM4_M6_RD_AUT_CTRL: u1,
            /// Domain4 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM4_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain5 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM5_M0_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM5_M0_WT_AUT_CTRL: u1,
            /// Domain5 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM5_M1_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM5_M1_WT_AUT_CTRL: u1,
            /// Domain5 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM5_M2_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM5_M2_WT_AUT_CTRL: u1,
            /// Domain5 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM5_M3_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM5_M3_WT_AUT_CTRL: u1,
            /// Domain5 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM5_M4_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM5_M4_WT_AUT_CTRL: u1,
            /// Domain5 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM5_M5_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM5_M5_WT_AUT_CTRL: u1,
            /// Domain5 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM5_M6_RD_AUT_CTRL: u1,
            /// Domain5 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM5_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xb8);

        /// address: 0x20100bc
        /// IOMMU Domain Authority Control 3 Register
        pub const IOMMU_DM_AUT_CTRL3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain6 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM6_M0_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM6_M0_WT_AUT_CTRL: u1,
            /// Domain6 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM6_M1_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM6_M1_WT_AUT_CTRL: u1,
            /// Domain6 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM6_M2_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM6_M2_WT_AUT_CTRL: u1,
            /// Domain6 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM6_M3_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM6_M3_WT_AUT_CTRL: u1,
            /// Domain6 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM6_M4_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM6_M4_WT_AUT_CTRL: u1,
            /// Domain6 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM6_M5_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM6_M5_WT_AUT_CTRL: u1,
            /// Domain6 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM6_M6_RD_AUT_CTRL: u1,
            /// Domain6 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM6_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain7 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM7_M0_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM7_M0_WT_AUT_CTRL: u1,
            /// Domain7 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM7_M1_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM7_M1_WT_AUT_CTRL: u1,
            /// Domain7 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM7_M2_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM7_M2_WT_AUT_CTRL: u1,
            /// Domain7 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM7_M3_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM7_M3_WT_AUT_CTRL: u1,
            /// Domain7 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM7_M4_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM7_M4_WT_AUT_CTRL: u1,
            /// Domain7 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM7_M5_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM7_M5_WT_AUT_CTRL: u1,
            /// Domain7 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM7_M6_RD_AUT_CTRL: u1,
            /// Domain7 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM7_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xbc);

        /// address: 0x20100c0
        /// IOMMU Domain Authority Control 4 Register
        pub const IOMMU_DM_AUT_CTRL4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain8 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM8_M0_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM8_M0_WT_AUT_CTRL: u1,
            /// Domain8 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM8_M1_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM8_M1_WT_AUT_CTRL: u1,
            /// Domain8 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM8_M2_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM8_M2_WT_AUT_CTRL: u1,
            /// Domain8 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM8_M3_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM8_M3_WT_AUT_CTRL: u1,
            /// Domain8 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM8_M4_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM8_M4_WT_AUT_CTRL: u1,
            /// Domain8 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM8_M5_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM8_M5_WT_AUT_CTRL: u1,
            /// Domain8 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM8_M6_RD_AUT_CTRL: u1,
            /// Domain8 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM8_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain9 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM9_M0_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM9_M0_WT_AUT_CTRL: u1,
            /// Domain9 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM9_M1_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM9_M1_WT_AUT_CTRL: u1,
            /// Domain9 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM9_M2_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM9_M2_WT_AUT_CTRL: u1,
            /// Domain9 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM9_M3_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM9_M3_WT_AUT_CTRL: u1,
            /// Domain9 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM9_M4_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM9_M4_WT_AUT_CTRL: u1,
            /// Domain9 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM9_M5_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM9_M5_WT_AUT_CTRL: u1,
            /// Domain9 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM9_M6_RD_AUT_CTRL: u1,
            /// Domain9 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM9_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc0);

        /// address: 0x20100c4
        /// IOMMU Domain Authority Control 5 Register
        pub const IOMMU_DM_AUT_CTRL5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain10 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM10_M0_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM10_M0_WT_AUT_CTRL: u1,
            /// Domain10 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM10_M1_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM10_M1_WT_AUT_CTRL: u1,
            /// Domain10 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM10_M2_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM10_M2_WT_AUT_CTRL: u1,
            /// Domain10 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM10_M3_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM10_M3_WT_AUT_CTRL: u1,
            /// Domain10 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM10_M4_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM10_M4_WT_AUT_CTRL: u1,
            /// Domain10 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM10_M5_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM10_M5_WT_AUT_CTRL: u1,
            /// Domain10 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM10_M6_RD_AUT_CTRL: u1,
            /// Domain10 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM10_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain11 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM11_M0_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM11_M0_WT_AUT_CTRL: u1,
            /// Domain11 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM11_M1_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM11_M1_WT_AUT_CTRL: u1,
            /// Domain11 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM11_M2_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM11_M2_WT_AUT_CTRL: u1,
            /// Domain11 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM11_M3_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM11_M3_WT_AUT_CTRL: u1,
            /// Domain11 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM11_M4_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM11_M4_WT_AUT_CTRL: u1,
            /// Domain11 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM11_M5_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM11_M5_WT_AUT_CTRL: u1,
            /// Domain11 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM11_M6_RD_AUT_CTRL: u1,
            /// Domain11 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM11_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc4);

        /// address: 0x20100c8
        /// IOMMU Domain Authority Control 6 Register
        pub const IOMMU_DM_AUT_CTRL6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain12 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M0_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M0_WT_AUT_CTRL: u1,
            /// Domain12 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M1_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M1_WT_AUT_CTRL: u1,
            /// Domain12 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M2_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M2_WT_AUT_CTRL: u1,
            /// Domain12 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M3_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M3_WT_AUT_CTRL: u1,
            /// Domain12 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M4_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M4_WT_AUT_CTRL: u1,
            /// Domain12 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M5_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M5_WT_AUT_CTRL: u1,
            /// Domain12 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM12_M6_RD_AUT_CTRL: u1,
            /// Domain12 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM12_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain13 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M0_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M0_WT_AUT_CTRL: u1,
            /// Domain13 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M1_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M1_WT_AUT_CTRL: u1,
            /// Domain13 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M2_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M2_WT_AUT_CTRL: u1,
            /// Domain13 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M3_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M3_WT_AUT_CTRL: u1,
            /// Domain13 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M4_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M4_WT_AUT_CTRL: u1,
            /// Domain13 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M5_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M5_WT_AUT_CTRL: u1,
            /// Domain13 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM13_M6_RD_AUT_CTRL: u1,
            /// Domain13 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM13_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xc8);

        /// address: 0x20100cc
        /// IOMMU Domain Authority Control 7 Register
        pub const IOMMU_DM_AUT_CTRL7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Domain14 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM14_M0_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM14_M0_WT_AUT_CTRL: u1,
            /// Domain14 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM14_M1_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM14_M1_WT_AUT_CTRL: u1,
            /// Domain14 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM14_M2_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM14_M2_WT_AUT_CTRL: u1,
            /// Domain14 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM14_M3_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM14_M3_WT_AUT_CTRL: u1,
            /// Domain14 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM14_M4_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM14_M4_WT_AUT_CTRL: u1,
            /// Domain14 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM14_M5_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM14_M5_WT_AUT_CTRL: u1,
            /// Domain14 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM14_M6_RD_AUT_CTRL: u1,
            /// Domain14 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM14_M6_WT_AUT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            /// Domain15 read permission control for master0
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM15_M0_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master0
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM15_M0_WT_AUT_CTRL: u1,
            /// Domain15 read permission control for master1
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM15_M1_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master1
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM15_M1_WT_AUT_CTRL: u1,
            /// Domain15 read permission control for master2
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM15_M2_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master2
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM15_M2_WT_AUT_CTRL: u1,
            /// Domain15 read permission control for master3
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM15_M3_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master3
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM15_M3_WT_AUT_CTRL: u1,
            /// Domain15 read permission control for master4
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM15_M4_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master4
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM15_M4_WT_AUT_CTRL: u1,
            /// Domain15 read permission control for master5
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            DM15_M5_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master5
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            DM15_M5_WT_AUT_CTRL: u1,
            /// Domain15 read permission control for master6
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            DM15_M6_RD_AUT_CTRL: u1,
            /// Domain15 write permission control for master6
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            DM15_M6_WT_AUT_CTRL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xcc);

        /// address: 0x20100d0
        /// IOMMU Domain Authority Overwrite Register
        pub const IOMMU_DM_AUT_OVWT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            M0_RD_AUT_OVWT_CTRL: u1,
            /// Master0 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            M0_WT_AUT_OVWT_CTRL: u1,
            /// Master1 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            M1_RD_AUT_OVWT_CTRL: u1,
            /// Master1 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            M1_WT_AUT_OVWT_CTRL: u1,
            /// Master2 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            M2_RD_AUT_OVWT_CTRL: u1,
            /// Master2 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            M2_WT_AUT_OVWT_CTRL: u1,
            /// Master3 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            M3_RD_AUT_OVWT_CTRL: u1,
            /// Master3 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            M3_WT_AUT_OVWT_CTRL: u1,
            /// Master5 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            M4_RD_AUT_OVWT_CTRL: u1,
            /// Master5 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            M4_WT_AUT_OVWT_CTRL: u1,
            /// Master5 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited
            M5_RD_AUT_OVWT_CTRL: u1,
            /// Master5 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited
            M5_WT_AUT_OVWT_CTRL: u1,
            /// Master6 read permission overwrite control
            /// 0: The read-operation is permitted
            /// 1: The read-operation is prohibited Note: The bit is not used.
            M6_RD_AUT_OVWT_CTRL: u1,
            /// Master6 write permission overwrite control
            /// 0: The write-operation is permitted
            /// 1: The write-operation is prohibited Note: The bit is not used.
            M6_WT_AUT_OVWT_CTRL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Domain write/read permission overwrite enable
            /// 0: Disable
            /// 1: Enable
            DM_AUT_OVWT_ENABLE: u1,
        }), base_address + 0xd0);

        /// address: 0x2010020
        /// IOMMU Enable Register
        pub const IOMMU_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IOMMU module enable switch
            /// 0: Disable IOMMU
            /// 1: Enable IOMMU Before IOMMU address mapping function opens, configure the
            /// Translation Table Base register; or ensure all masters are in bypass status or
            /// no the status of sending bus demand(such as reset)
            ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20);

        /// address: 0x2010104
        /// IOMMU Interrupt Clear Register
        pub const IOMMU_INT_CLR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Micro TLB0 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            MICRO_TLB0_INVALID_CLR: u1,
            /// Micro TLB1 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            MICRO_TLB1_INVALID_CLR: u1,
            /// Micro TLB2 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            MICRO_TLB2_INVALID_CLR: u1,
            /// Micro TLB3 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            MICRO_TLB3_INVALID_CLR: u1,
            /// Micro TLB4 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            MICRO_TLB4_INVALID_CLR: u1,
            /// Micro TLB5 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            MICRO_TLB5_INVALID_CLR: u1,
            /// Micro TLB6 permission invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt Note: The bit is not used.
            MICRO_TLB6_INVALID_CLR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Level1 page table invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            L1_PAGE_TABLE_INVALID_CLR: u1,
            /// Level2 page table invalid interrupt clear bit
            /// 0: Invalid operation
            /// 1: Clear interrupt
            L2_PAGE_TABLE_INVALID_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x104);

        /// address: 0x2010100
        /// IOMMU Interrupt Enable Register
        pub const IOMMU_INT_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Micro TLB0 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB0_INVALID_EN: u1,
            /// Micro TLB1 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB1_INVALID_EN: u1,
            /// Micro TLB2 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB2_INVALID_EN: u1,
            /// Micro TLB3 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB3_INVALID_EN: u1,
            /// Micro TLB4 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB4_INVALID_EN: u1,
            /// Micro TLB5 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB5_INVALID_EN: u1,
            /// Micro TLB6 permission invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            MICRO_TLB6_INVALID_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Level1 page table invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            L1_PAGE_TABLE_INVALID_EN: u1,
            /// Level2 page table invalid interrupt enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            L2_PAGE_TABLE_INVALID_EN: u1,
            /// Debug or Prefetch DRAM Invalid Level1 Page Table Enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            DBG_PF_DRAM_IV_L1_PT_EN: u1,
            /// Debug or Prefetch PTW Cache Invalid Level1 Page Table Enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            DBG_PF_PC_IV_L1_PT_EN: u1,
            /// Debug or Prefetch Invalid Page Table Enable
            /// 0: Mask interrupt
            /// 1: Enable interrupt
            DBG_PF_L2_IV_PT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x100);

        /// address: 0x2010110
        /// IOMMU Interrupt Error Address 0 Register
        pub const IOMMU_INT_ERR_ADDR0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB0 to interrupt
            INT_ERR_ADDR0: u32,
        }), base_address + 0x110);

        /// address: 0x2010114
        /// IOMMU Interrupt Error Address 1 Register
        pub const IOMMU_INT_ERR_ADDR1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB1 to interrupt
            INT_ERR_ADDR1: u32,
        }), base_address + 0x114);

        /// address: 0x2010118
        /// IOMMU Interrupt Error Address 2 Register
        pub const IOMMU_INT_ERR_ADDR2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB2 to interrupt
            INT_ERR_ADDR2: u32,
        }), base_address + 0x118);

        /// address: 0x201011c
        /// IOMMU Interrupt Error Address 3 Register
        pub const IOMMU_INT_ERR_ADDR3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB3 to interrupt
            INT_ERR_ADDR3: u32,
        }), base_address + 0x11c);

        /// address: 0x2010120
        /// IOMMU Interrupt Error Address 4 Register
        pub const IOMMU_INT_ERR_ADDR4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB4 to interrupt
            INT_ERR_ADDR4: u32,
        }), base_address + 0x120);

        /// address: 0x2010124
        /// IOMMU Interrupt Error Address 5 Register
        pub const IOMMU_INT_ERR_ADDR5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB5 to interrupt
            INT_ERR_ADDR5: u32,
        }), base_address + 0x124);

        /// address: 0x2010128
        /// IOMMU Interrupt Error Address 6 Register
        pub const IOMMU_INT_ERR_ADDR6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused Micro TLB6 to interrupt
            INT_ERR_ADDR6: u32,
        }), base_address + 0x128);

        /// address: 0x2010130
        /// IOMMU Interrupt Error Address 7 Register
        pub const IOMMU_INT_ERR_ADDR7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused L1 page table to interrupt
            INT_ERR_ADDR7: u32,
        }), base_address + 0x130);

        /// address: 0x2010134
        /// IOMMU Interrupt Error Address 8 Register
        pub const IOMMU_INT_ERR_ADDR8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address that caused L2 page table to interrupt
            INT_ERR_ADDR8: u32,
        }), base_address + 0x134);

        /// address: 0x2010150
        /// IOMMU Interrupt Error Data 0 Register
        pub const IOMMU_INT_ERR_DATA0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB0 to interrupt
            INT_ERR_DATA0: u32,
        }), base_address + 0x150);

        /// address: 0x2010154
        /// IOMMU Interrupt Error Data 1 Register
        pub const IOMMU_INT_ERR_DATA1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB1 to interrupt
            INT_ERR_DATA1: u32,
        }), base_address + 0x154);

        /// address: 0x2010158
        /// IOMMU Interrupt Error Data 2 Register
        pub const IOMMU_INT_ERR_DATA2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB2 to interrupt
            INT_ERR_DATA2: u32,
        }), base_address + 0x158);

        /// address: 0x201015c
        /// IOMMU Interrupt Error Data 3 Register
        pub const IOMMU_INT_ERR_DATA3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB3 to interrupt
            INT_ERR_DATA3: u32,
        }), base_address + 0x15c);

        /// address: 0x2010160
        /// IOMMU Interrupt Error Data 4 Register
        pub const IOMMU_INT_ERR_DATA4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB4 to interrupt
            INT_ERR_DATA4: u32,
        }), base_address + 0x160);

        /// address: 0x2010164
        /// IOMMU Interrupt Error Data 5 Register
        pub const IOMMU_INT_ERR_DATA5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB5 to interrupt
            INT_ERR_DATA5: u32,
        }), base_address + 0x164);

        /// address: 0x2010168
        /// IOMMU Interrupt Error Data 6 Register
        pub const IOMMU_INT_ERR_DATA6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused Micro TLB6 to interrupt
            /// Note: This field is not used.
            INT_ERR_DATA6: u32,
        }), base_address + 0x168);

        /// address: 0x2010170
        /// IOMMU Interrupt Error Data 7 Register
        pub const IOMMU_INT_ERR_DATA7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused L1 page table to
            /// interrupt
            INT_ERR_DATA7: u32,
        }), base_address + 0x170);

        /// address: 0x2010174
        /// IOMMU Interrupt Error Data 8 Register
        pub const IOMMU_INT_ERR_DATA8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Corresponding page table of virtual address that caused L2 page table to
            /// interrupt
            INT_ERR_DATA8: u32,
        }), base_address + 0x174);

        /// address: 0x2010108
        /// IOMMU Interrupt Status Register
        pub const IOMMU_INT_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Micro TLB0 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            MICRO_TLB0_INVALID_STA: u1,
            /// Micro TLB1 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            MICRO_TLB1_INVALID_STA: u1,
            /// Micro TLB2 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            MICRO_TLB2_INVALID_STA: u1,
            /// Micro TLB3 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            MICRO_TLB3_INVALID_STA: u1,
            /// Micro TLB4 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            MICRO_TLB4_INVALID_STA: u1,
            /// Micro TLB5 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            MICRO_TLB5_INVALID_STA: u1,
            /// Micro TLB6 permission invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens Note: The bit is not used.
            MICRO_TLB6_INVALID_STA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Level1 page table invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            L1_PAGE_TABLE_INVALID_STA: u1,
            /// Level2 page table invalid interrupt status bit
            /// 0: Interrupt does not happen or interrupt is cleared
            /// 1: Interrupt happens
            L2_PAGE_TABLE_INVALID_STA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x108);

        /// address: 0x2010180
        /// IOMMU L1 Page Table Interrupt Register
        pub const IOMMU_L1PG_INT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 address switch causes L1 page table to occur interrupt.
            MASTER0_L1PG_INT: u1,
            /// Master1 address switch causes L1 page table to occur interrupt.
            MASTER1_L1PG_INT: u1,
            /// Master2 address switch causes L1 page table to occur interrupt.
            MASTER2_L1PG_INT: u1,
            /// Master3 address switch causes L1 page table to occur interrupt.
            MASTER3_L1PG_INT: u1,
            /// Master4 address switch causes L1 page table to occur interrupt.
            MASTER4_L1PG_INT: u1,
            /// Master5 address switch causes L1 page table to occur interrupt.
            MASTER5_L1PG_INT: u1,
            /// Master6 address switch causes L1 page table to occur interrupt. Note: The bit is
            /// not used.
            MASTER6_L1PG_INT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Debug mode address switch causes L1 page table to occur interrupt.
            DBG_MODE_L1PG_INT: u1,
        }), base_address + 0x180);

        /// address: 0x2010184
        /// IOMMU L2 Page Table Interrupt Register
        pub const IOMMU_L2PG_INT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 address switch causes L2 page table to occur interrupt.
            MASTER0_L2PG_INT: u1,
            /// Master1 address switch causes L2 page table to occur interrupt.
            MASTER1_L2PG_INT: u1,
            /// Master2 address switch causes L2 page table to occur interrupt.
            MASTER2_L2PG_INT: u1,
            /// Master3 address switch causes L2 page table to occur interrupt.
            MASTER3_L2PG_INT: u1,
            /// Master4 address switch causes L2 page table to occur interrupt.
            MASTER4_L2PG_INT: u1,
            /// Master5 address switch causes L2 page table to occur interrupt.
            MASTER5_L2PG_INT: u1,
            /// Master6 address switch causes L2 page table to occur interrupt. Note: The bit is
            /// not used.
            MASTER6_L2PG_INT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Debug mode address switch causes L2 page table to occur interrupt.
            DBG_MODE_L2PG_INT: u1,
        }), base_address + 0x184);

        /// address: 0x2010048
        /// IOMMU Out of Order Control Register
        pub const IOMMU_OOO_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order
            M0_OOO_CTRL: u1,
            /// Master1 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order
            M1_OOO_CTRL: u1,
            /// Master2 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order
            M2_OOO_CTRL: u1,
            /// Master3 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order
            M3_OOO_CTRL: u1,
            /// Master4 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order
            M4_OOO_CTRL: u1,
            /// Master5 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order
            M5_OOO_CTRL: u1,
            /// Master6 out-of-order control bit
            /// 0: Disable out-of-order
            /// 1: Enable out-of-order Note: This bit is not used.
            M6_OOO_CTRL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x48);

        /// address: 0x20100a0
        /// IOMMU PC Invalidation Address Register
        pub const IOMMU_PC_IVLD_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// PTW Cache invalid address, 1 MB aligned.
            PC_IVLD_ADDR: u12,
        }), base_address + 0xa0);

        /// address: 0x20100a8
        /// IOMMU PC Invalidation Enable Register
        pub const IOMMU_PC_IVLD_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable PTW Cache invalidation operation
            /// 0: No operation or operation is completed
            /// 1: Enable invalidation operation After invalidation operation is completed, the
            /// bit can clear automatically. After or before invalidation operation starts,
            /// there is no absolute relationship between the same address switch operation and
            /// invalidation operation.
            PC_IVLD_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa8);

        /// address: 0x20100ac
        /// IOMMU PC Invalidation End Address Register
        pub const IOMMU_PC_IVLD_END_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// PTW Cache invalid end address, 1 MB aligned.
            PC_IVLD_EA: u12,
        }), base_address + 0xac);

        /// address: 0x201009c
        /// IOMMU PC Invalidation Mode Select Register
        pub const IOMMU_PC_IVLD_MODE_SEL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PTW Cache Invalid Mode Select
            /// 0: Invalidate PTW by using the Mask mode
            /// 1: Invalidate PTW by using the Start and End mode
            PC_IVLD_MODE_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x9c);

        /// address: 0x20100a4
        /// IOMMU PC Invalidation Start Address Register
        pub const IOMMU_PC_IVLD_STA_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// PTW Cache invalid start address, 1 MB aligned.
            PC_IVLD_SA: u12,
        }), base_address + 0xa4);

        /// address: 0x2010234
        /// IOMMU PMU Access High 0 Register
        pub const IOMMU_PMU_ACCESS_HIGH0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB0 access, higher 11-bit register
            PMU_ACCESS_HIGH0: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x234);

        /// address: 0x2010244
        /// IOMMU PMU Access High 1 Register
        pub const IOMMU_PMU_ACCESS_HIGH1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB1 access, higher 11-bit register
            PMU_ACCESS_HIGH1: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x244);

        /// address: 0x2010254
        /// IOMMU PMU Access High 2 Register
        pub const IOMMU_PMU_ACCESS_HIGH2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB2 access, higher 11-bit register
            PMU_ACCESS_HIGH2: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x254);

        /// address: 0x2010264
        /// IOMMU PMU Access High 3 Register
        pub const IOMMU_PMU_ACCESS_HIGH3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB3 access, higher 11-bit register
            PMU_ACCESS_HIGH3: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x264);

        /// address: 0x2010274
        /// IOMMU PMU Access High 4 Register
        pub const IOMMU_PMU_ACCESS_HIGH4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB4 access, higher 11-bit register
            PMU_ACCESS_HIGH4: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x274);

        /// address: 0x2010284
        /// IOMMU PMU Access High 5 Register
        pub const IOMMU_PMU_ACCESS_HIGH5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB5 access, higher 11-bit register
            PMU_ACCESS_HIGH5: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x284);

        /// address: 0x2010294
        /// IOMMU PMU Access High 6 Register
        pub const IOMMU_PMU_ACCESS_HIGH6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB6 access, higher 11-bit register Note: The field
            /// is not used.
            PMU_ACCESS_HIGH6: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x294);

        /// address: 0x20102d4
        /// IOMMU PMU Access High 7 Register
        pub const IOMMU_PMU_ACCESS_HIGH7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB7 access, higher 11-bit register
            PMU_ACCESS_HIGH7: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2d4);

        /// address: 0x20102e4
        /// IOMMU PMU Access High 8 Register
        pub const IOMMU_PMU_ACCESS_HIGH8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of PTW Cache access, higher 11-bit register
            PMU_ACCESS_HIGH8: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2e4);

        /// address: 0x2010230
        /// IOMMU PMU Access Low 0 Register
        pub const IOMMU_PMU_ACCESS_LOW0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB0 access, lower 32-bit register
            PMU_ACCESS_LOW0: u32,
        }), base_address + 0x230);

        /// address: 0x2010240
        /// IOMMU PMU Access Low 1 Register
        pub const IOMMU_PMU_ACCESS_LOW1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB1 access, lower 32-bit register
            PMU_ACCESS_LOW1: u32,
        }), base_address + 0x240);

        /// address: 0x2010250
        /// IOMMU PMU Access Low 2 Register
        pub const IOMMU_PMU_ACCESS_LOW2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB2 access, lower 32-bit register
            PMU_ACCESS_LOW2: u32,
        }), base_address + 0x250);

        /// address: 0x2010260
        /// IOMMU PMU Access Low 3 Register
        pub const IOMMU_PMU_ACCESS_LOW3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB3 access, lower 32-bit register
            PMU_ACCESS_LOW3: u32,
        }), base_address + 0x260);

        /// address: 0x2010270
        /// IOMMU PMU Access Low 4 Register
        pub const IOMMU_PMU_ACCESS_LOW4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB4 access, lower 32-bit register
            PMU_ACCESS_LOW4: u32,
        }), base_address + 0x270);

        /// address: 0x2010280
        /// IOMMU PMU Access Low 5 Register
        pub const IOMMU_PMU_ACCESS_LOW5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB5 access, lower 32-bit register
            PMU_ACCESS_LOW5: u32,
        }), base_address + 0x280);

        /// address: 0x2010290
        /// IOMMU PMU Access Low 6 Register
        pub const IOMMU_PMU_ACCESS_LOW6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB6 access, lower 32-bit register Note: The field
            /// is not used.
            PMU_ACCESS_LOW6: u32,
        }), base_address + 0x290);

        /// address: 0x20102d0
        /// IOMMU PMU Access Low 7 Register
        pub const IOMMU_PMU_ACCESS_LOW7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB7 access, lower 32-bit register
            PMU_ACCESS_LOW7: u32,
        }), base_address + 0x2d0);

        /// address: 0x20102e0
        /// IOMMU PMU Access Low 8 Register
        pub const IOMMU_PMU_ACCESS_LOW8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of PTW Cache access, lower 32-bit register
            PMU_ACCESS_LOW8: u32,
        }), base_address + 0x2e0);

        /// address: 0x2010210
        /// IOMMU_PMU_CLR__REG
        pub const IOMMU_PMU_CLR__REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: No clear operation or clear operation is completed
            /// 1: Clear counter data After the operation is completed, the bit can clear
            /// automatically.
            PMU_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x210);

        /// address: 0x2010200
        /// IOMMU_PMU_ENABLE__REG
        pub const IOMMU_PMU_ENABLE__REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable statistical function
            /// 1: Enable statistical function
            PMU_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x200);

        /// address: 0x201023c
        /// IOMMU PMU Hit High 0 Register
        pub const IOMMU_PMU_HIT_HIGH0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB0 hit, higher 11-bit register
            PMU_HIT_HIGH0: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x23c);

        /// address: 0x201024c
        /// IOMMU PMU Hit High 1 Register
        pub const IOMMU_PMU_HIT_HIGH1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB1 hit, higher 11-bit register
            PMU_HIT_HIGH1: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x24c);

        /// address: 0x201025c
        /// IOMMU PMU Hit High 2 Register
        pub const IOMMU_PMU_HIT_HIGH2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB2 hit, higher 11-bit register
            PMU_HIT_HIGH2: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x25c);

        /// address: 0x201026c
        /// IOMMU PMU Hit High 3 Register
        pub const IOMMU_PMU_HIT_HIGH3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB3 hit, higher 11-bit register
            PMU_HIT_HIGH3: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x26c);

        /// address: 0x201027c
        /// IOMMU PMU Hit High 4 Register
        pub const IOMMU_PMU_HIT_HIGH4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB4 hit, higher 11-bit register
            PMU_HIT_HIGH4: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x27c);

        /// address: 0x201028c
        /// IOMMU PMU Hit High 5 Register
        pub const IOMMU_PMU_HIT_HIGH5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB5 hit, higher 11-bit register
            PMU_HIT_HIGH5: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x28c);

        /// address: 0x201029c
        /// IOMMU PMU Hit High 6 Register
        pub const IOMMU_PMU_HIT_HIGH6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB6 hit, higher 11-bit register Note: The field is
            /// not used.
            PMU_HIT_HIGH6: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x29c);

        /// address: 0x20102dc
        /// IOMMU PMU Hit High 7 Register
        pub const IOMMU_PMU_HIT_HIGH7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB7 hit, higher 11-bit register
            PMU_HIT_HIGH7: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2dc);

        /// address: 0x20102ec
        /// IOMMU PMU Hit High 8 Register
        pub const IOMMU_PMU_HIT_HIGH8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of PTW Cache hit, higher 11-bit register
            PMU_HIT_HIGH8: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x2ec);

        /// address: 0x2010238
        /// IOMMU PMU Hit Low 0 Register
        pub const IOMMU_PMU_HIT_LOW0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB0 hit, lower 32-bit register
            PMU_HIT_LOW0: u32,
        }), base_address + 0x238);

        /// address: 0x2010248
        /// IOMMU PMU Hit Low 1 Register
        pub const IOMMU_PMU_HIT_LOW1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB1 hit, lower 32-bit register
            PMU_HIT_LOW1: u32,
        }), base_address + 0x248);

        /// address: 0x2010258
        /// IOMMU PMU Hit Low 2 Register
        pub const IOMMU_PMU_HIT_LOW2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB2 hit, lower 32-bit register
            PMU_HIT_LOW2: u32,
        }), base_address + 0x258);

        /// address: 0x2010268
        /// IOMMU PMU Hit Low 3 Register
        pub const IOMMU_PMU_HIT_LOW3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB3 hit, lower 32-bit register
            PMU_HIT_LOW3: u32,
        }), base_address + 0x268);

        /// address: 0x2010278
        /// IOMMU PMU Hit Low 4 Register
        pub const IOMMU_PMU_HIT_LOW4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB4 hit, lower 32-bit register
            PMU_HIT_LOW4: u32,
        }), base_address + 0x278);

        /// address: 0x2010288
        /// IOMMU PMU Hit Low 5 Register
        pub const IOMMU_PMU_HIT_LOW5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB5 hit, lower 32-bit register
            PMU_HIT_LOW5: u32,
        }), base_address + 0x288);

        /// address: 0x2010298
        /// IOMMU PMU Hit Low 6 Register
        pub const IOMMU_PMU_HIT_LOW6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB6 hit, lower 32-bit register Note: The field is
            /// not used.
            PMU_HIT_LOW6: u32,
        }), base_address + 0x298);

        /// address: 0x20102d8
        /// IOMMU PMU Hit Low 7 Register
        pub const IOMMU_PMU_HIT_LOW7_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of Micro TLB7 hit, lower 32-bit register
            PMU_HIT_LOW7: u32,
        }), base_address + 0x2d8);

        /// address: 0x20102e8
        /// IOMMU PMU Hit Low 8 Register
        pub const IOMMU_PMU_HIT_LOW8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total number of PTW Cache hit, lower 32-bit register
            PMU_HIT_LOW8: u32,
        }), base_address + 0x2e8);

        /// address: 0x2010308
        /// IOMMU Max Latency 0 Register
        pub const IOMMU_PMU_ML0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master0.
            PMU_ML0: u32,
        }), base_address + 0x308);

        /// address: 0x2010318
        /// IOMMU Max Latency 1 Register
        pub const IOMMU_PMU_ML1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master1.
            PMU_ML1: u32,
        }), base_address + 0x318);

        /// address: 0x2010328
        /// IOMMU Max Latency 2 Register
        pub const IOMMU_PMU_ML2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master2.
            PMU_ML2: u32,
        }), base_address + 0x328);

        /// address: 0x2010338
        /// IOMMU Max Latency 3 Register
        pub const IOMMU_PMU_ML3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master3.
            PMU_ML3: u32,
        }), base_address + 0x338);

        /// address: 0x2010348
        /// IOMMU Max Latency 4 Register
        pub const IOMMU_PMU_ML4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master4.
            PMU_ML4: u32,
        }), base_address + 0x348);

        /// address: 0x2010358
        /// IOMMU Max Latency 5 Register
        pub const IOMMU_PMU_ML5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master5.
            PMU_ML5: u32,
        }), base_address + 0x358);

        /// address: 0x2010368
        /// IOMMU Max Latency 6 Register
        pub const IOMMU_PMU_ML6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record the max latency of Master6. Note: The field is not used.
            PMU_ML6: u32,
        }), base_address + 0x368);

        /// address: 0x2010304
        /// IOMMU Total Latency High 0 Register
        pub const IOMMU_PMU_TL_HIGH0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master0, higher 18-bit register
            PMU_TL_HIGH0: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x304);

        /// address: 0x2010314
        /// IOMMU Total Latency High 1 Register
        pub const IOMMU_PMU_TL_HIGH1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master1, higher 18-bit register
            PMU_TL_HIGH1: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x314);

        /// address: 0x2010324
        /// IOMMU Total Latency High 2 Register
        pub const IOMMU_PMU_TL_HIGH2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master2, higher 18-bit register
            PMU_TL_HIGH2: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x324);

        /// address: 0x2010334
        /// IOMMU Total Latency High 3 Register
        pub const IOMMU_PMU_TL_HIGH3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master3, higher 18-bit register
            PMU_TL_HIGH3: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x334);

        /// address: 0x2010344
        /// IOMMU Total Latency High 4 Register
        pub const IOMMU_PMU_TL_HIGH4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master4, higher 18-bit register
            PMU_TL_HIGH4: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x344);

        /// address: 0x2010354
        /// IOMMU Total Latency High 5 Register
        pub const IOMMU_PMU_TL_HIGH5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master5, higher 18-bit register
            PMU_TL_HIGH5: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x354);

        /// address: 0x2010364
        /// IOMMU Total Latency High 6 Register
        pub const IOMMU_PMU_TL_HIGH6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master6, higher 18-bit register Note: The field is not
            /// used.
            PMU_TL_HIGH6: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x364);

        /// address: 0x2010300
        /// IOMMU Total Latency Low 0 Register
        pub const IOMMU_PMU_TL_LOW0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master0, lower 32-bit register
            PMU_TL_LOW0: u32,
        }), base_address + 0x300);

        /// address: 0x2010310
        /// IOMMU Total Latency Low 1 Register
        pub const IOMMU_PMU_TL_LOW1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master1, lower 32-bit register
            PMU_TL_LOW1: u32,
        }), base_address + 0x310);

        /// address: 0x2010320
        /// IOMMU Total Latency Low 2 Register
        pub const IOMMU_PMU_TL_LOW2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master2, lower 32-bit register
            PMU_TL_LOW2: u32,
        }), base_address + 0x320);

        /// address: 0x2010330
        /// IOMMU Total Latency Low 3 Register
        pub const IOMMU_PMU_TL_LOW3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master3, lower 32-bit register
            PMU_TL_LOW3: u32,
        }), base_address + 0x330);

        /// address: 0x2010340
        /// IOMMU Total Latency Low 4 Register
        pub const IOMMU_PMU_TL_LOW4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master4, lower 32-bit register
            PMU_TL_LOW4: u32,
        }), base_address + 0x340);

        /// address: 0x2010350
        /// IOMMU Total Latency Low 5 Register
        pub const IOMMU_PMU_TL_LOW5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master5, lower 32-bit register
            PMU_TL_LOW5: u32,
        }), base_address + 0x350);

        /// address: 0x2010360
        /// IOMMU Total Latency Low 6 Register
        pub const IOMMU_PMU_TL_LOW6_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Record total latency of Master6, lower 32-bit register Note: The field is not
            /// used.
            PMU_TL_LOW6: u32,
        }), base_address + 0x360);

        /// address: 0x2010010
        /// IOMMU_RESET__REG
        pub const IOMMU_RESET__REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Master0 Reset Master0 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master0 occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            M0_RST: u1,
            /// Master1 Reset Master1 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master1 occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            M1_RST: u1,
            /// Master2 Reset Master2 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master2 occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            M2_RST: u1,
            /// Master3 Reset Master3 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master3 occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            M3_RST: u1,
            /// Master4 Reset Master4 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master4 occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            M4_RST: u1,
            /// Master5 Reset Master5 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master5 occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            M5_RST: u1,
            /// Master6 Reset Master6 address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When Master6 occurs abnormal, the bit is used to reset
            /// PTW Cache individually. Note: This bit is not used.
            M6_RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Macrotlb Reset Macro TLB address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When PTW Cache occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            MTLB_RST: u1,
            /// PTW Cache Reset PTW Cache address convert lane software reset switch.
            /// 0: Set reset signal
            /// 1: Release reset signal When PTW Cache occurs abnormal, the bit is used to reset
            /// PTW Cache individually.
            PC_RST: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// IOMMU Software Reset Switch
            /// 0: Set reset signal
            /// 1: Release reset signal Before IOMMU software reset operation, ensure IOMMU
            /// never be opened; or all bus operations are completed; or DRAM and the
            /// peripherals have opened the corresponding switch, for shielding the effects of
            /// IOMMU reset.
            IOMMU_RESET: u1,
        }), base_address + 0x10);

        /// address: 0x2010060
        /// IOMMU TLB Enable Register
        pub const IOMMU_TLB_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Micro TLB0 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB0_ENABLE: u1,
            /// Micro TLB1 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB1_ENABLE: u1,
            /// Micro TLB2 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB2_ENABLE: u1,
            /// Micro TLB3 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB3_ENABLE: u1,
            /// Micro TLB4 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB4_ENABLE: u1,
            /// Micro TLB5 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB5_ENABLE: u1,
            /// Micro TLB6 enable bit
            /// 0: Disable
            /// 1: Enable
            MICRO_TLB6_ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Macro TLB enable bit
            /// 0: Disable
            /// 1: Enable
            MACRO_TLB_ENABLE: u1,
            /// PTW Cache enable bit
            /// 0: Disable
            /// 1: Enable
            PTW_CACHE_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x60);

        /// address: 0x2010080
        /// IOMMU TLB Flush Enable Register
        pub const IOMMU_TLB_FLUSH_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Micro TLB0 Flush Clear Micro TLB0
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB0_FS: u1,
            /// Micro TLB1 Flush Clear Micro TLB1
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB1_FS: u1,
            /// Micro TLB2 Flush Clear Micro TLB2
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB2_FS: u1,
            /// Micro TLB3 Flush Clear Micro TLB3
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB3_FS: u1,
            /// Micro TLB4 Flush Clear Micro TLB4
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB4_FS: u1,
            /// Micro TLB5 Flush Clear Micro TLB5
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB5_FS: u1,
            /// Micro TLB6 Flush Clear Micro TLB6
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MI_TLB6_FS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Macro TLB Flush Clear Macro TLB
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            MA_TLB_FS: u1,
            /// PTW Cache Flush Clear PTW Cache
            /// 0: No clear operation or clear operation is completed
            /// 1: Enable clear operation After the Flush operation is completed, the bit can
            /// clear automatically.
            PC_FS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x80);

        /// address: 0x2010094
        /// IOMMU TLB Invalidation Address Mask Register
        pub const IOMMU_TLB_IVLD_ADDR_MASK_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// TLB invalid address mask register, 4 KB aligned
            TLB_IVLD_ADDR_MASK: u20,
        }), base_address + 0x94);

        /// address: 0x2010090
        /// IOMMU TLB Invalidation Address Register
        pub const IOMMU_TLB_IVLD_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// TLB invalid address, 4 KB aligned
            TLB_IVLD_ADDR: u20,
        }), base_address + 0x90);

        /// address: 0x2010098
        /// IOMMU TLB Invalidation Enable Register
        pub const IOMMU_TLB_IVLD_ENABLE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable TLB invalidation operation
            /// 0: No operation or operation is completed
            /// 1: Enable invalidation operation After invalidation operation is completed, the
            /// bit can clear automatically. When operating invalidation operation, TLB/Cache
            /// operation has not affected. After or before invalidation operation starts, there
            /// is no absolute relationship between the same address switch operation and
            /// invalidation operation.
            TLB_IVLD_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x98);

        /// address: 0x201008c
        /// IOMMU TLB Invalidation End Address Register
        pub const IOMMU_TLB_IVLD_END_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// TLB invalid end address, 4 KB aligned.
            TLB_IVLD_END_ADDR: u20,
        }), base_address + 0x8c);

        /// address: 0x2010084
        /// IOMMU TLB Invalidation Mode Select Register
        pub const IOMMU_TLB_IVLD_MODE_SEL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Invalidate TLB by using the Mask mode
            /// 1: Invalidate TLB by using the Start and End mode
            TLB_IVLD_MODE_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x84);

        /// address: 0x2010088
        /// IOMMU TLB Invalidation Start Address Register
        pub const IOMMU_TLB_IVLD_STA_ADDR_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// TLB invalid start address, 4 KB aligned.
            TLB_IVLD_STA_ADDR: u20,
        }), base_address + 0x88);

        /// address: 0x2010070
        /// IOMMU TLB Prefetch Register
        pub const IOMMU_TLB_PREFETCH_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Micro TLB0 prefetch enable
            /// 0: Disable
            /// 1: Enable
            MI_TLB0_PF: u1,
            /// Micro TLB1 prefetch enable
            /// 0: Disable
            /// 1: Enable
            MI_TLB1_PF: u1,
            /// Micro TLB2 prefetch enable
            /// 0: Disable
            /// 1: Enable
            MI_TLB2_PF: u1,
            /// Micro TLB3 prefetch enable
            /// 0: Disable
            /// 1: Enable Note: If G2D accesses DDR, it is suggested that disable the prefetch
            /// function.
            MI_TLB3_PF: u1,
            /// Micro TLB4 prefetch enable
            /// 0: Disable
            /// 1: Enable
            MI_TLB4_PF: u1,
            /// Micro TLB5 prefetch enable
            /// 0: Disable
            /// 1: Enable
            MI_TLB5_PF: u1,
            /// Micro TLB6 prefetch enable
            /// 0: Disable
            /// 1: Enable
            MI_TLB6_PF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Prefetch Value Pagetable to Macro TLB
            /// 0: Disable
            /// 1: Enable If the function is enabled, the prefetch function will not update the
            /// invalid Level2 page table to Macro TLB.
            PF_VL_PT_TO_MT: u1,
            /// Prefetch Value Pagetable to PTW Cache
            /// 0: Disable
            /// 1: Enable If the function is enabled, the prefetch function will not update the
            /// invalid Level1 page table to PTW cache.
            PF_VL_PT_TO_PC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x70);

        /// address: 0x2010050
        /// IOMMU Translation Table Base Register
        pub const IOMMU_TTB_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Translation Table Base Level1 page table starting address, aligned to 16 KB.
            /// When operating the register, IOMMU address mapping function must be closed,
            /// namely IOMMU_ENABLE_REG is 0; Or Bypass function of all main equipment is set to
            /// 1, or no the state of transfer bus commands (such as setting).
            TTB: u18,
        }), base_address + 0x50);

        /// address: 0x2010198
        /// IOMMU_VA_CONFIG__REG
        pub const IOMMU_VA_CONFIG__REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: No operation or operation is completed
            /// 1: Start After the operation is completed, the bit can clear automatically. Read
            /// operation process: a) Write IOMMU_VA_REG[31:0]; b) Write IOMMU_VA_CONFIG_REG[8]
            /// to 0; c) Write IOMMU_VA_CONFIG_REG[0] to 1 to start read-process; d) Query
            /// IOMMU_VA_CONFIG_REG[0] until it is 0; e) Read IOMMU_VA_DATA_REG[31:0]; Write
            /// operation process: a) Write IOMMU_VA_REG[31:0]; b) Write
            /// IOMMU_VA_DATA_REG[31:0]; c) Write IOMMU_VA_CONFIG_REG[8] to 1; d) Write
            /// IOMMU_VA_CONFIG_REG[0] to 1 to start write-process; e) Query
            /// IOMMU_VA_CONFIG_REG[0] until it is 0;
            VA_CONFIG_START: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Virtual Address Configuration
            /// 0: Read operation
            /// 1: Write operation
            VA_CONFIG: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// 0: Prefetch
            /// 1: Debug Mode It is used to chose prefetch mode or Debug mode.
            MODE_SEL: u1,
        }), base_address + 0x198);

        /// address: 0x2010194
        /// IOMMU_VA_DATA__REG
        pub const IOMMU_VA_DATA__REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data corresponding to read/write virtual address
            VA_DATA: u32,
        }), base_address + 0x194);

        /// address: 0x2010190
        /// IOMMU_VA__REG
        pub const IOMMU_VA__REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Virtual address of read/write
            VA: u32,
        }), base_address + 0x190);

        /// address: 0x2010044
        /// IOMMU Write Buffer Control Register
        pub const IOMMU_WBUF_CTRL_REG = @intToPtr(*volatile u32, base_address + 0x44);
    };

    /// RISCV_CFG
    pub const RISCV_CFG = struct {
        pub const base_address = 0x6010000;

        /// address: 0x6010060
        /// IRQ Mode0 Register
        pub const IRQ_MODE0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRQ Mode0
            /// 0: High-level trigger
            /// 1: Rising edge trigger
            IRQ_MD0: u32,
        }), base_address + 0x60);

        /// address: 0x6010064
        /// IRQ Mode1 Register
        pub const IRQ_MODE1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRQ Mode1
            /// 0: High-level trigger
            /// 1: Rising edge trigger
            IRQ_MD1: u32,
        }), base_address + 0x64);

        /// address: 0x6010068
        /// IRQ Mode2 Register
        pub const IRQ_MODE2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRQ Mode2
            /// 0: High-level trigger
            /// 1: Rising edge trigger
            IRQ_MD2: u32,
        }), base_address + 0x68);

        /// address: 0x601006c
        /// IRQ Mode3 Register
        pub const IRQ_MODE3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRQ Mode3
            /// 0: High-level trigger
            /// 1: Rising edge trigger
            IRQ_MD3: u32,
        }), base_address + 0x6c);

        /// address: 0x6010070
        /// IRQ Mode4 Register
        pub const IRQ_MODE4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// IRQ Mode4
            /// 0: High-level trigger
            /// 1: Rising edge trigger
            IRQ_MD4: u32,
        }), base_address + 0x70);

        /// address: 0x6010050
        /// Retire PC0 Register
        pub const RETITE_PC0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Retire PC[31:0] It indicates the current retiring instruction PC[31:0].
            RT_PC_L: u32,
        }), base_address + 0x50);

        /// address: 0x6010054
        /// Retire PC1 Register
        pub const RETITE_PC1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Retire PC[39:31] It indicates the current retiring instruction PC[39:31].
            RT_PC_H: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Retire Signal
            /// 0: The current period has not the retired instruction
            /// 1: The current period has the retired instruction
            RT_SIG: u1,
        }), base_address + 0x54);

        /// address: 0x6010010
        /// RF1P Configuration Register
        pub const RF1P_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// RF1P Configuration
            RF1P_CFG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x601011c
        /// RISCV AXI PMU Read Bandwidth Register
        pub const RISCV_AXI_PMU_BW_RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor the total data (KB) of read-channel durning period
            BW_RD: u32,
        }), base_address + 0x11c);

        /// address: 0x6010120
        /// RISCV AXI PMU Write Bandwidth Register
        pub const RISCV_AXI_PMU_BW_WR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor the total data (KB) of write-channel durning period
            BW_WR: u32,
        }), base_address + 0x120);

        /// address: 0x6010104
        /// RISCV AXI PMU Control Register
        pub const RISCV_AXI_PMU_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// PMU Enable
            /// 0: PMU disabled
            /// 1: PMU enabled
            PMU_EN: u1,
            /// PMU Clear
            /// 0: No operation
            /// 1: PMU cleared
            PMU_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x104);

        /// address: 0x601010c
        /// RISCV AXI PMU Read Latency Register
        pub const RISCV_AXI_PMU_LAT_RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor the total latency of read-channel durning period
            LAT_RD: u32,
        }), base_address + 0x10c);

        /// address: 0x6010110
        /// RISCV AXI PMU Write Latency Register
        pub const RISCV_AXI_PMU_LAT_WR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor the total latency of write-channel durning period
            LAT_WR: u32,
        }), base_address + 0x110);

        /// address: 0x6010108
        /// RISCV AXI PMU Period Register
        pub const RISCV_AXI_PMU_PRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor period Suggest that the field is in units of 1 us (1 ms).
            PRD: u32,
        }), base_address + 0x108);

        /// address: 0x6010114
        /// RISCV AXI PMU Read Request Register
        pub const RISCV_AXI_PMU_REQ_RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor the total command numbers of read-channel durning period
            REQ_RD: u32,
        }), base_address + 0x114);

        /// address: 0x6010118
        /// RISCV AXI PMU Write Request Register
        pub const RISCV_AXI_PMU_REQ_WR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Monitor the total command numbers of write-channel durning period
            REQ_WR: u32,
        }), base_address + 0x118);

        /// address: 0x6010004
        /// RISCV Start Address0 Register
        pub const RISCV_STA_ADD0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Address Low 32-bit The bit0 is fixed as 0 and can not be written.
            STA_ADD_L: u32,
        }), base_address + 0x4);

        /// address: 0x6010008
        /// RISCV Start Address1 Register
        pub const RISCV_STA_ADD1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Address High 8-bit.
            STA_ADD_H: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x601001c
        /// ROM Configuration Register
        pub const ROM_CFG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// ROM Configuration
            ROM_CFG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x6010044
        /// SRAM Address Twist Register
        pub const SRAM_ADDR_TWIST_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// SRAM Address Twist Flag. When this bit is set up, the RISCV_BROM area would
            /// become invisible, and the start address of SRAM A1 would be twisted into 0x0,
            /// the original start address of SRAM A1 is 0x0002 0000. After the address has been
            /// twisted, RISCV reads data from 0x0002000 to 0x0002ffff as same as from 0x0 to
            /// 0xffff.
            SRAM_ADDR_TS_FG: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// SRAM Twist Keyfield The bit 0 can be written only if this key field is written
            /// by 0x16AA.
            SRAM_TS_KF: u16,
        }), base_address + 0x44);

        /// address: 0x6010040
        /// Timestamp Test Mode Select Register
        pub const TS_TMODE_SEL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timestamp Test Mode Enable
            /// 0: Normal Mode
            /// 1: Test Mode
            TS_TEST_MODE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x40);

        /// address: 0x6010020
        /// Wakeup Enable Register
        pub const WAKEUP_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Enable
            WP_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20);

        /// address: 0x6010024
        /// Wakeup Mask0 Register
        pub const WAKEUP_MASK0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Mask0
            WP_MASK0: u32,
        }), base_address + 0x24);

        /// address: 0x6010028
        /// Wakeup Mask1 Register
        pub const WAKEUP_MASK1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Mask1
            WP_MASK1: u32,
        }), base_address + 0x28);

        /// address: 0x601002c
        /// Wakeup Mask2 Register
        pub const WAKEUP_MASK2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Mask2
            WP_MASK2: u32,
        }), base_address + 0x2c);

        /// address: 0x6010030
        /// Wakeup Mask3 Register
        pub const WAKEUP_MASK3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Mask3
            WP_MASK3: u32,
        }), base_address + 0x30);

        /// address: 0x6010034
        /// Wakeup Mask4 Register
        pub const WAKEUP_MASK4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup Mask4
            WP_MASK4: u32,
        }), base_address + 0x34);

        /// address: 0x6010048
        /// Work Mode Register
        pub const WORK_MODE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Work Mode Status
            /// 00: Normal Mode
            /// 01: Low Power Mode
            /// 10: Debug Mode
            /// 11: Reserved
            WM_STA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x48);
    };

    /// LEDC
    pub const LEDC = struct {
        pub const base_address = 0x2008000;

        /// address: 0x2008000
        /// LEDC Control Register
        pub const LEDC_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LEDC Enable
            /// 0: Disable
            /// 1: Enable That the bit is enabled indicates LEDC can be started when LEDC data
            /// finished transmission or LEDC_EN is cleared to 0 by hardware in LEDC_SOFT_RESET
            /// situation.
            LEDC_EN: u1,
            /// LEDC soft reset Write 1 to clear it automatically. The ranges of LEDC soft reset
            /// include the following points: all internal status registers, the control state
            /// machine returns to in idle status, the LEDC FIFO read & write point is cleared
            /// to 0, the LEDC interrupt is cleared; and the affected registers are followed.
            /// 1.LEDC_CTRL_REG (LEDC_EN is cleared to 0); 2. PLL_T0&1_TIMING_CTRL_REG remains
            /// unchanged; 3. LEDC_DATA_FINISH_CNT_REG (LEDC_DATA_FINISH_CNT is cleared to 0);
            /// 4.LED_RESET_TIMING_CTRL_REG remains unchanged; 5. LEDC_WAIT_TIME_CTRL_REG
            /// remains unchanged; 6. LEDC_DMA_CTRL_REG remains unchanged; 7.
            /// LEDC_INTERRUPT_CTRL_REG remains unchanged; 8.LEDC_INT_STS _REG is cleared to 0;
            /// 9. LEDC_CLK_GATING_REG remains unchanged; 10.LEDC_FIFO_DATA_REG remains
            /// unchanged;
            LEDC_SOFT_RESET: u1,
            /// MSB control for Blue data
            /// 0: LSB
            /// 1: MSB
            LED_MSB_B: u1,
            /// MSB control for Red data
            /// 0: LSB
            /// 1: MSB
            LED_MSB_R: u1,
            /// MSB control for Green data
            /// 0: LSB
            /// 1: MSB
            LED_MSB_G: u1,
            /// Adjust sequence of the combined GRB data
            /// 0: LSB
            /// 1: MSB
            LED_MSB_TOP: u1,
            /// 000 GRB (bypass) 001 GBR 010 RGB 011 RBG 100 BGR 101 BRG By default, the
            /// software configures data to LEDC according to GRB (MSB) mode, the LEDC internal
            /// combines data to output to the external LED. Other modes configure as follows.
            /// Software Input Mode Configuration LEDC Output Mode GRB 000 001 010 011 100 101
            /// GBR 000 001 010 011 100 101 RGB 000 001 010 011 100 101 RBG 000 001 010 011 100
            /// 101 BGR 000 001 010 011 100 101 BRG 000 001 010 011 100 101
            LED_RGB_MODE: u3,
            reserved0: u1,
            /// Write operation: The software writes 1 to the bit, the CPU triggers LEDC to
            /// transfer a reset to LED. Only when LEDC is in IDLE status, the reset can be
            /// performed. After the reset finished, the control state machine returns to the
            /// IDLE status. To return LEDC to the IDLE status, it also needs to be used with
            /// SOFT_RESET. When the software sets the bit, the software can read the bit to
            /// check if the reset is complete. Read operation:
            /// 0: LEDC completes the transmission of the LED reset operation
            /// 1: LEDC does not complete the transmission of the LED reset operation
            RESET_LED_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Total length of transfer data (range: 0 to 8K, unit: 32-bit, only low 24-bit is
            /// valid) The field is recommended to be set to an integer multiple of (LED_NUM+1).
            /// If TOTAL_DATA_LENGTH is greater than (LED_NUM+1), but non- integer multiple, the
            /// last frame of data will transfer data less than (LED_NUM+1).
            TOTAL_DATA_LENGTH: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x2008008
        /// LEDC Data Finish Counter Register
        pub const LEDC_DATA_FINISH_CNT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value is the total LED data that have been sent. (Range: 0– 8k)
            LED_DATA_FINISH_CNT: u13,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The value is the time that internal FIFO in LEDC is waiting for data. When the
            /// time is exceeded, the LEDC will send the wait_data_timeout_int interrupt. (This
            /// is an abnormal situation, software needs to reset LEDC.) The value is about 300
            /// us by default. The adjust range is 80 ns–655 us.
            /// led_wait_data_time=42ns*(N+1). N: 1–1FFF. When the field is 0,
            /// LEDC_WAIT_DATA_TIME=1FFF
            LED_WAIT_DATA_TIME: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x8);

        /// address: 0x2008014
        /// LEDC Data Register
        pub const LEDC_DATA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA LED display data (the lower 24-bit is valid)
            LEDC: u32,
        }), base_address + 0x14);

        /// address: 0x2008018
        /// LEDC DMA Control Register
        pub const LEDC_DMA_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The remaining space of internal FIFO in LEDC The internal FIFO in LEDC is 24*32.
            /// When the remaining space of internal FIFO in LEDC is more than or equal to
            /// LEDFIFO_TRIG_LEVEL, the DMA or the CPU request will generate. The default value
            /// is 15. The adjusted value is from 1 to 31. The recommended configuration is 7 or
            /// 15. When the configuration value is 0, LEDFIFO_TRIG_LEVEL=F.
            LEDC_FIFO_TRIG_LEVEL: u5,
            /// LEDC DMA request enable
            /// 0: Disable request of DMA transfer data
            /// 1: Enable request of DMA transfer data
            LEDC_DMA_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x18);

        /// address: 0x2008030
        /// LEDC_FIFO_DATA_X[%s]
        pub const LEDC_FIFO_DATA_X = @intToPtr(*volatile [32]u32, base_address + 0x30);

        /// address: 0x200801c
        /// LEDC_INTERRUPT_CTRL_REG
        pub const LEDC_INTERRUPT_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data transmission complete interrupt enable
            /// 0: Disable
            /// 1: Enable
            LED_TRANS_FINISH_INT_EN: u1,
            /// FIFO request CPU data interrupt enable
            /// 0: Disable
            /// 1: Enable
            FIFO_CPUREQ_INT_EN: u1,
            reserved0: u1,
            /// The internal FIFO in LEDC cannot get data because of some abnormal situation,
            /// after the time of led_wait_data_time, the interrupt will be enabled.
            /// 0: Disable
            /// 1: Enable
            WAITDATA_TIMEOUT_INT_EN: u1,
            /// FIFO overflow interrupt enable When the data written by the software is more
            /// than the internal FIFO level of LEDC, the LEDC is in the data loss state.
            /// 0: Disable
            /// 1: Enable
            FIFO_OVERFLOW_INT_EN: u1,
            /// Global interrupt enable
            /// 0: Disable
            /// 1: Enable
            GLOBAL_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x1c);

        /// address: 0x2008020
        /// LEDC Interrupt Status Register
        pub const LEDC_INT_STS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data transfer complete interrupt The value indicates that the data configured as
            /// total_data_length is transferred completely.
            /// 0: Data is not transferred completely
            /// 1: Data is transferred completely
            LED_TRANS_FINISH_INT: u1,
            /// FIFO request CPU data interrupt When FIFO data is less than the threshold, the
            /// interrupt will be reported to the CPU.
            /// 0: FIFO does not request that CPU transfers data
            /// 1: FIFO requests that CPU transfers data
            FIFO_CPUREQ_INT: u1,
            reserved0: u1,
            /// When internal FIFO of LEDC cannot get data because of some abnormal situation,
            /// after led_wait_data_time, the timeout interrupt is set, the LEDC is in WAIT_DATA
            /// state, the LEDC outputs a level state configured by LED_POLARITY; in the course
            /// of wait_data, if the new data arrives, the LEDC will continue to send data, at
            /// this time software needs to notice whether the waiting time of LEDC exceeds the
            /// operation time of reset. If the waiting time of LEDC exceeds the operation time
            /// of reset (this is equivalent to reset operation sent by LEDC), the LED may enter
            /// in refresh state, the data has not been sent.
            /// 0: LEDC not timeout
            /// 1: LEDC timeout
            WAITDATA_TIMEOUT_INT: u1,
            /// FIFO overflow interrupt The data written by external is more than the maximum
            /// storage space of LED FIFO, the LEDC will be in the data loss state. At this
            /// time, the software needs to deal with the abnormal situation. The processing
            /// mode is as follows. (1) The software can query LED_FIFO_DATA_REG to determine
            /// which data has been stored in the internal FIFO of LEDC. (2) The LEDC performs
            /// soft_reset operation to refresh all data.
            /// 0: FIFO not overflow
            /// 1: FIFO overflow
            FIFO_OVERFLOW_INT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// FIFO internal valid data depth It indicates the space FIFO has been occupied.
            FIFO_WLW: u6,
            /// FIFO full status flag
            FIFO_FULL: u1,
            /// FIFO empty status flag
            FIFO_EMPTY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x20);

        /// address: 0x2008010
        /// LEDC Wait Time0 Control Register
        pub const LEDC_WAIT_TIME0_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waiting time between 2 LED data. The LEDC output is low level. The adjust range
            /// is 80 ns–10 us. wait_time0=42 ns*(N+1) Unit: cycle(24 MHz) N: 1–FF
            TOTAL_WAIT_TIME0: u8,
            /// WAIT_TIME0 enable When it is 1, the controller automatically inserts waiting
            /// time between LED package data.
            /// 0: Disable
            /// 1: Enable
            WAIT_TIM0_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x10);

        /// address: 0x2008028
        /// LEDC Wait Time1 Control Register
        pub const LEDC_WAIT_TIME1_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Waiting time between 2 frame data. The LEDC output is low level. The adjust
            /// range is 80 ns– 85 s. wait_time1=42 ns*(N+1) Unit: cycle (24 MHz) N:
            /// 0x80–0x7FFFFFFF If the value is 0, TOTAL_WAIT_TIME1=0x7FFFFFFF
            TOTAL_WAIT_TIME1: u31,
            /// 0: Disable
            /// 1: Enable WAIT_TIME1 enable When the bit is 1, the controller automatically
            /// inserts the waiting time between the LED frame data.
            WAIT_TIM1_EN: u1,
        }), base_address + 0x28);

        /// address: 0x200800c
        /// LEDC Reset Timing Control Register
        pub const LED_RESET_TIMING_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value is the number of external LED lamp. Maximum up to 1024. The default
            /// value 0 indicates that 1 LED lamp is external connected. The range is from 0 to
            /// 1023.
            LED_NUM: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Reset time control of LED lamp Unit: cycle (24 MHz), tr_time=42 ns*(N+1) The
            /// default value is 300 us. The adjust range is 80 ns–327 us. N: 1–1FFF
            TR_TIME: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xc);

        /// address: 0x2008004
        /// LEDC T0 & T1 Timing Control Register
        pub const LED_T01_TIMING_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LED T0l time Unit: cycle (24 MHz), T0L_TIME =42 ns*(N+1) The default value is
            /// 840 ns, the range is 80 ns–2560 ns. N: 1–3F. When is 0, T0L_TIME = 3F
            T0L_TIME: u6,
            /// LED T0h time Unit: cycle (24 MHz), T0H_TIME =42 ns*(N+1) The default value is
            /// 336 ns, the range is 80 ns–1280 ns. N: 1–1F. When is 0, T0H_TIME = 1F
            T0H_TIME: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// LED T1L time Unit: cycle (24 MHz), T1L_TIME =42 ns*(N+1) The default value is
            /// 294 ns, the range is 80 ns–1280 ns. N: 1–1F. When is 0, T1L_TIME = 1F
            T1L_TIME: u5,
            /// LED T1H time Unit: cycle (24 MHz), T1H_TIME =42 ns*(N+1) The default value is
            /// 882 ns, the range is 80 ns–2560 ns. N: 1–3F. When is 0, T1H_TIME = 3F
            T1H_TIME: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);
    };

    /// LRADC
    pub const LRADC = struct {
        pub const base_address = 0x2009800;

        /// address: 0x2009800
        /// LRADC Control Register
        pub const LRADC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// LRADC Enable
            /// 0: Disable
            /// 1: Enable
            LRADC_EN: u1,
            reserved0: u1,
            /// LRADC Sample Rate
            /// 00: 2 kHz
            /// 01: 1 kHz
            /// 10: 500 Hz
            /// 11: 250 Hz
            LRADC_SAMPLE_RATE: u2,
            /// Level B Corresponding Data Value Setting (the real voltage value)
            /// 00: Reserved
            /// 01: 0x39 (1.221 V)
            /// 10: 0x36 (1.157 V)
            /// 11: 0x33 (1.093 V)
            LEVELB_VOL: u2,
            /// LRADC Channel Enable
            /// 0: Disable
            /// 1: Enable
            LRADC_CHANNEL_EN: u1,
            /// LRADC Hold KEY Enable
            /// 0: Disable
            /// 1: Enable
            LRADC_HOLD_KEY_EN: u1,
            /// Level A to Level B time threshold select Judge the ADC convert value from level
            /// A to level B in n+1 samples.
            LEVELA_B_CNT: u4,
            /// Key Mode Select
            /// 00: Normal Mode
            /// 01: Single Mode
            /// 10: Continuous Mode
            KEY_MODE_SELECT: u2,
            reserved1: u1,
            reserved2: u1,
            /// Continuous Mode Time Select One of 8*(N+1) sample as a valuable sample data.
            CONTINUE_TIME_SELECT: u4,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ADC First Convert Delay Setting ADC conversion is delayed by n samples.
            FIRST_CONVERT_DLY: u8,
        }), base_address + 0x0);

        /// address: 0x200980c
        /// LRADC Data Register
        pub const LRADC_DATA = @intToPtr(*volatile MmioInt(32, u6), base_address + 0xc);

        /// address: 0x2009804
        /// LRADC Interrupt Control Register
        pub const LRADC_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC0 Data IRQ Enable
            /// 0: Disable
            /// 1: Enable
            ADC0_DATA_IRQ_EN: u1,
            /// ADC0 Key Down Enable
            /// 0: Disable
            /// 1: Enable
            ADC0_KEYDOWN_EN: u1,
            /// ADC0 Hold Key IRQ Enable
            /// 0: Disable
            /// 1: Enable
            ADC0_HOLD_IRQ_EN: u1,
            /// ADC0 Already Hold Key IRQ Enable
            /// 0: Disable
            /// 1: Enable
            ADC0_ALRDY_HOLD_IRQ_EN: u1,
            /// ADC0 Key Up IRQ Enable
            /// 0: Disable
            /// 1: Enable
            ADC0_KEYUP_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x4);

        /// address: 0x2009808
        /// LRADC Interrupt Status Register
        pub const LRADC_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC0 Data IRQ Pending Bit
            /// 0: No IRQ
            /// 1: IRQ Pending Writing 1 to the bit will clear it and its corresponding
            /// interrupt if the interrupt is enabled.
            ADC0_DATA_PENDING: u1,
            /// ADC0 Key Down IRQ Pending Bit When the general key is pulled down, and the
            /// corresponding interrupt is enabled, the status bit is set and the interrupt line
            /// is set.
            /// 0: No IRQ
            /// 1: IRQ Pending Writing 1 to the bit will clear it and its corresponding
            /// interrupt if the interrupt is enabled.
            ADC0_KEYDOWN_PENDING: u1,
            /// ADC0 Hold Key Pending Bit When the hold key is pulled down, and the
            /// corresponding interrupt is enabled, the status bit is set and the interrupt line
            /// is set.
            /// 0: NO IRQ
            /// 1: IRQ Pending Writing 1 to the bit will clear it and its corresponding
            /// interrupt if the interrupt is enabled.
            ADC0_HOLDKEY_PENDING: u1,
            /// ADC0 Already Hold Pending Bit When the hold key is pulled down and the general
            /// key is pulled down, and the corresponding interrupt is enabled.
            /// 0: No IRQ
            /// 1: IRQ Pending Writing 1 to the bit will clear it and its corresponding
            /// interrupt if the interrupt is enabled.
            ADC0_ALRDY_HOLD_PENDING: u1,
            /// ADC0 Key up Pending Bit When the general key is pulled up, and the corresponding
            /// interrupt is enabled, the status bit is set.
            /// 0: No IRQ
            /// 1: IRQ Pending Writing 1 to the bit will clear it and its corresponding
            /// interrupt if the interrupt is enabled.
            ADC0_KEYUP_PENDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x8);
    };

    /// DSP_MSGBOX
    pub const DSP_MSGBOX = struct {
        pub const base_address = 0x1701000;

        pub const _N = @ptrCast(*volatile [2]packed struct {
            /// (N=0–1)(P=0–3) MSGBOX FIFO Status Register
            MSGBOX_FIFO_STATUS_REG: Mmio(32, packed struct {
                /// FIFO is not available flag
                /// 0: The Message FIFO queue empty level reaches the configured threshold
                /// 1: The Message FIFO queue empty level does not reach the configured threshold
                /// This FIFO status register has the status related to the message queue.
                FIFO_NOT_AVA_FLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
                padding28: u1,
                padding29: u1,
                padding30: u1,
            }),

            /// (N=0–1)(P=0–3) MSGBOX Message Queue Register
            MSGBOX_MSG_REG: Mmio(32, packed struct {
                /// The message register stores the next to be read message of the message FIFO
                /// queue.
                MSG_QUE: u32,
            }),

            /// (N=0–1)(P=0–3) MSGBOX Message Status Register
            MSGBOX_MSG_STATUS_REG: Mmio(32, packed struct {
                /// Message Number Number of unread messages in the message queue. Here, limited to
                /// eight messages per message queue.
                /// 0000: There is no message in the message FIFO queue.
                /// 0001: There is 1 message in the message FIFO queue.
                /// 0010: There are 2 messages in the message FIFO queue.
                /// 0011: There are 3 messages in the message FIFO queue.
                /// 0100: There are 4 messages in the message FIFO queue.
                /// 0101: There are 5 messages in the message FIFO queue.
                /// 0110: There are 6 messages in the message FIFO queue.
                /// 0111: There are 7 messages in the message FIFO queue.
                /// 1000: There are 8 messages in the message FIFO queue. 1001~1111:/
                MSG_NUM: u4,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
            }),

            /// MSGBOX Read IRQ Enable Register
            MSGBOX_RD_IRQ_EN_REG: Mmio(32, packed struct {
                /// Reception Channel0 Interrupt Enable
                /// 0: Disable
                /// 1: Enable (It notifies user 0 by interrupt when Message Queue 0 received a new
                /// message.)
                RECEPTION_MQ0_IRQ_EN: u1,
                reserved0: u1,
                /// Reception Channel1 Interrupt Enable
                /// 0: Disable
                /// 1: Enable (It notifies user 0 by interrupt when Message Queue 1 received a new
                /// message.)
                RECEPTION_MQ1_IRQ_EN: u1,
                reserved1: u1,
                /// Reception Channel2 Interrupt Enable
                /// 0: Disable
                /// 1: Enable (It notifies user 0 by interrupt when Message Queue 2 received a new
                /// message.)
                RECEPTION_MQ2_IRQ_EN: u1,
                reserved2: u1,
                /// Reception Channel3 Interrupt Enable
                /// 0: Disable
                /// 1: Enable (It notifies user 0 by interrupt when Message Queue 3 received a new
                /// message.)
                RECEPTION_MQ3_IRQ_EN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
            }),

            /// MSGBOX Read IRQ Status Register
            MSGBOX_RD_IRQ_STATUS_REG: Mmio(32, packed struct {
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 0 when Message Queue 0 received a
                /// new message. Setting 1 to this bit clears it.
                RECEPTION_MQ0_IRQ_PEND: u1,
                reserved0: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 0 when Message Queue 1 received a
                /// new message. Setting 1 to this bit clears it.
                RECEPTION_MQ1_IRQ_PEND: u1,
                reserved1: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 0 when Message Queue 2 received a
                /// new message. Setting 1 to this bit clears it.
                RECEPTION_MQ2_IRQ_PEND: u1,
                reserved2: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 0 when Message Queue 3 received a
                /// new message. Setting 1 to this bit clears it.
                RECEPTION_MQ3_IRQ_PEND: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
            }),

            /// MSGBOX_WR_INT_THRESHOLD_REG
            MSGBOX_WR_INT_THRESHOLD_REG: Mmio(32, packed struct {
                /// Configure the FIFO empty level to trigger the write interrupt for user1
                /// 00: 1
                /// 01: 2
                /// 10: 4
                /// 11: 8
                MSG_WR_INT_THRESHOLD_CFG: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
                padding27: u1,
                padding28: u1,
                padding29: u1,
            }),

            /// MSGBOX Write IRQ Enable Register
            MSGBOX_WR_IRQ_EN_REG: Mmio(32, packed struct {
                reserved0: u1,
                /// 0: Disable
                /// 1: Enable (It notifies user 1 by interrupt when Message Queue 0 empty level
                /// reaches the configured threshold.)
                TRANSMIT_MQ0_IRQ_EN: u1,
                reserved1: u1,
                /// 0: Disable
                /// 1: Enable (It notifies user 1 by interrupt when Message Queue 1 empty level
                /// reaches the configured threshold.)
                TRANSMIT_MQ1_IRQ_EN: u1,
                reserved2: u1,
                /// 0: Disable
                /// 1: Enable (It notifies user 1 by interrupt when Message Queue 2 empty level
                /// reaches the configured threshold.)
                TRANSMIT_MQ2_IRQ_EN: u1,
                reserved3: u1,
                /// 0: Disable
                /// 1: Enable (It notifies user 1 by interrupt when Message Queue 3 empty level
                /// reaches the configured threshold.)
                TRANSMIT_MQ3_IRQ_EN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }),

            /// MSGBOX Write IRQ Status Register
            MSGBOX_WR_IRQ_STATUS_REG: Mmio(32, packed struct {
                reserved0: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 1 when Message Queue 0 empty level
                /// reaches the configured threshold. Setting 1 to this bit clears it.
                TRANSMIT_MQ0_IRQ_PEND: u1,
                reserved1: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 1 when Message Queue 1 empty level
                /// reaches the configured threshold. Setting 1 to this bit clears it.
                TRANSMIT_MQ1_IRQ_PEND: u1,
                reserved2: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 1 when Message Queue 2 empty level
                /// reaches the configured threshold. Setting 1 to this bit clears it.
                TRANSMIT_MQ2_IRQ_PEND: u1,
                reserved3: u1,
                /// 0: No effect
                /// 1: Pending. This bit will be pending for user 1 when Message Queue 3 empty level
                /// reaches the configured threshold. Setting 1 to this bit clears it.
                TRANSMIT_MQ3_IRQ_PEND: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
            }),
            padding0: u64,
            padding1: u64,
            padding2: u64,
            padding3: u64,
            padding4: u64,
            padding5: u64,
            padding6: u64,
            padding7: u64,
            padding8: u64,
            padding9: u64,
            padding10: u64,
            padding11: u64,
            padding12: u64,
            padding13: u64,
            padding14: u64,
            padding15: u64,
            padding16: u64,
            padding17: u64,
            padding18: u64,
            padding19: u64,
            padding20: u64,
            padding21: u64,
            padding22: u64,
            padding23: u64,
            padding24: u64,
            padding25: u64,
            padding26: u64,
            padding27: u64,
        }, base_address + 0x20);
    };

    /// OWA
    pub const OWA = struct {
        pub const base_address = 0x2036000;

        /// address: 0x2036000
        /// OWA_CTL
        pub const OWA_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reset TX
            /// 0: Normal
            /// 1: Reset Self clear to 0.
            RST_TX: u1,
            /// Global Enable Disabling this bit overrides the operations of enabling and
            /// flushing all FIFOs by any other blocks or channels.
            /// 0: Disabled
            /// 1: Enabled
            GEN: u1,
            /// Loopback Test
            /// 0: Normal Mode
            /// 1: Loopback Test When the bit is set to ‘1’, the DOUT and DIN need be
            /// connected.
            LOOP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Reset RX
            /// 0: Normal
            /// 1: Reset Self clear to ‘0’.
            RST_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x2036040
        /// OWA Expand Control Register
        pub const OWA_EXP_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Insert detection number Configure how many jumping edges are detected to
            /// generate an insertion interrupt
            INSERT_DETECTION_NUM: u8,
            /// Insert detection enable
            /// 0: Disable
            /// 1: Enable
            INSERT_DETECTION_ENABLE: u1,
            /// Syncw_bitorder_en
            /// 0: Pa/Pb is the sync code of audio data
            /// 1: Pa/Pb reversed high and low bits is the sync code of audio data
            SYNCW_BITORDER_EN: u1,
            /// Data type bitorder enable
            /// 0: The received PC data is as the data length of the valid audio
            /// 1: The received PC data is reversed high and low bits, then as the length of the
            /// valid audio data
            DATA_TYPE_BITORDER_EN: u1,
            /// Data length bitorder enable
            /// 0: The received PD data is as the length of the valid audio data
            /// 1: The received PD data is reversed high and low bits, then as the length of the
            /// valid audio data
            DATA_LENGTH_BITORDER_EN: u1,
            /// Audio data bitorder enable
            /// 0: The audio data received by RX is stored directly into FIFO
            /// 1: The audio data received by RX is reversed high and low bits, then stored into
            /// FIFO
            AUDIO_DATA_BITORDER_EN: u1,
            /// OWA RX Mode Select
            /// 0: Manual Ctrl. Configure by OWA RX_MODE_MAN
            /// 1: Auto Ctrl. Configure by the channel status values resolved by hardware
            OWA_RX_MODE: u1,
            /// OWA RX Proteocol Select
            /// 0: IEC60958
            /// 1: IEC61937
            OWA_RX_MODE_MAN: u1,
            /// Unit Select Configure this field according to RX data type
            /// 0: In units of 16-bit
            /// 1: In units of 2-byte
            UNIT_SELECT: u1,
            /// The number for the repetition period of the burst frame Configure this field
            /// according to RX data. A mismatch between the configuration data and the received
            /// data will result in an error interrupt.
            REPEAT_PERIOD_OF_FR_NUM: u14,
            /// Burst data output select
            /// 0: Burst preamble and payload
            /// 1: Burst payload
            BURST_DATAOUT_SELECT: u1,
            padding0: u1,
        }), base_address + 0x40);

        /// address: 0x2036050
        /// OWA Expand Debug Register0
        pub const OWA_EXP_DBG_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remains Data Counter Value See the value of the sampled valid data in real time.
            DATA_CAP_NUM: u16,
            /// IEC61937 Data Capture State Machine
            /// 000: IDLE
            /// 001: SYNC_PA
            /// 010: SYNC_PB
            /// 011: DTYPE_PC
            /// 100: DLEN_PD
            /// 101: RX_ACTIVE
            IEC61937_DATA_CAP_FSM: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x50);

        /// address: 0x2036054
        /// OWA Expand Debug Register1
        pub const OWA_EXP_DBG_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Rate Counter See the value of audio sample ratio in real time.
            SR_CNT: u16,
            /// Repetition period of the burst frame counter See the value of repetition period
            /// counter in real time.
            REPET_PERIOD_OF_FR_CNT: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x54);

        /// address: 0x2036048
        /// OWA Expand Infomation Register0
        pub const OWA_EXP_INFO_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD Data information
            PD_DATA: u16,
            /// PC Data information
            PC_DATA: u16,
        }), base_address + 0x48);

        /// address: 0x203604c
        /// OWA Expand Infomation Register1
        pub const OWA_EXP_INFO_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sample Rate Value Read this value after RX_LOCK.
            SR_VALUE: u16,
            /// Repetition period of the burst frame value Check whether the repetition period
            /// of the burst frame calculated by hardware is consistent with the configuration
            /// value.
            REPET_PERIOD_OF_FR_VALUE: u14,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4c);

        /// address: 0x2036044
        /// OWA Expand Interrupt Status Register
        pub const OWA_EXP_ISTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// INSERT_INT INSERT INT
            /// 0: No Pending IRQ
            /// 1: OWA RX detects device insertion Write ‘1’ to clear this interrupt.
            INSERT_INT_INSERT: u1,
            /// PAPB_CAP_INT PAPB CAP INT
            /// 0: No Pending IRQ
            /// 1: IEC61937 mode captures PA and PB Write ‘1’ to clear this interrupt.
            PAPB_CAP_INT_PAPB: u1,
            /// PCPD_CAP_INT PCPD CAP INT
            /// 0: No Pending IRQ
            /// 1: IEC61937 mode captures PC and PD Write ‘1’ to clear this interrupt.
            PCPD_CAP_INT_PCPD: u1,
            /// RPDB_ERR_INT RPDB ERR INT
            /// 0: No Pending IRQ
            /// 1: Hardware counts the repetition period of the burst frame is different from
            /// register configuration number Write ‘1’ to clear this interrupt.
            RPDB_ERR_INT_RPDB: u1,
            /// PC_DTYPE_CHANGE_INT PC DTYPE CHANGE INT
            /// 0: No Pending IRQ
            /// 1: PC Datatype (except Pause/Null data type) information is change Write ‘1’
            /// to clear this interrupt.
            PC_DTYPE_CHANGE_INT_PC: u1,
            /// PC_ERR_FLAG_INT PC ERR FLAG INT
            /// 0: No Pending IRQ
            /// 1: PC Error-flag is available to indicate if the contents of the data- burst
            /// contain data errors (except Pause/Null data bursts type). The using of this bit
            /// by receivers is optional. Write ‘1’ to clear this interrupt.
            PC_ERR_FLAG_INT_PC: u1,
            /// PC_BITSTRM_CHANGE_INT PC BITSTRM CHANGE INT
            /// 0: No Pending IRQ
            /// 1: PC Bitstream Number is change. Bitstream Number indicates which bitstream the
            /// data burst belongs. (except Pause/Null data bursts type) Write ‘1’ to clear
            /// this interrupt.
            PC_BITSTRM_CHANGE_INT_PC: u1,
            /// PC_PAUSE_STOP_INT Audio bitstream is interrupted. When stopped, the interface
            /// becomes idle.
            /// 0: No Pending IRQ
            /// 1: PC Pause burst Stop, frame sequence discontinued. Transmitters may optionally
            /// use the STOP value to indicate that the transmission of the current encoded
            /// Write ‘1’ to clear this interrupt.
            PC_PAUSE_STOP_INT_AUDIO: u1,
            /// PD_CHANGE_INT PD CHANGE INT
            /// 0: No Pending IRQ
            /// 1: PD Data length information is change. (except Pause/Null data burst type)
            /// Write ‘1’ to clear this interrupt.
            PD_CHANGE_INT_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// INSERT_INT_EN INSERT Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            INSERT_INT_EN_INSERT: u1,
            /// PAPB_CAP_INT_EN PAPB_CAP Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PAPB_CAP_INT_EN_PAPB_CAP: u1,
            /// PCPD_CAP_INT_EN PCPD_CAP Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PCPD_CAP_INT_EN_PCPD_CAP: u1,
            /// RPDB_ERR_INT_EN RPDB_ERROR Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RPDB_ERR_INT_EN_RPDB_ERROR: u1,
            /// PC_DTYPE_CHANGE_INT_EN PC_DATATYPE_CHANGE Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PC_DTYPE_CHANGE_INT_EN_PC_DATATYPE_CHANGE: u1,
            /// PC_ERR_FLAG_INT PC_ERROR_FLAG Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PC_ERR_FLAG_INT_PC_ERROR_FLAG: u1,
            /// PC_BITSTRM_CHANGE_INT_EN PC_BITSTREAM_CHANGE Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PC_BITSTRM_CHANGE_INT_EN_PC_BITSTREAM_CHANGE: u1,
            /// PC_PAUSE_STOP_INT PC_PAUSE_BURSTS_STOP Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PC_PAUSE_STOP_INT_PC_PAUSE_BURSTS_STOP: u1,
            /// PD_CHANGE_INT_EN PD_LENGTH_CHANGE Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            PD_CHANGE_INT_EN_PD_LENGTH_CHANGE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x44);

        /// address: 0x2036014
        /// OWA FIFO Control Register
        pub const OWA_FCTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Output Mode(Mode 0,1,2,3)
            /// 00: Expanding ‘0’ at LSB of RXFIFO Register
            /// 01: Expanding received sample sign bit at MSB of RXFIFO Register
            /// 10: Truncating received samples at high half-word of RXFIFO Register and low
            /// half-word of RXFIFO Register is filled by ‘0’
            /// 11: Truncating received samples at low half-word of RXFIFO Register and high
            /// half-word of RXFIFO Register is expanded by its sigh bit Mode 0: APB_RDATA[31:0]
            /// = {RXFIFO[23:0], 8’h0} Mode 1: APB_RDATA[31:0] = {8’RXFIFO[23],
            /// RXFIFO[23:0]} Mode 2: APB_RDATA[31:0] = {RXFIFO[23:8], 16’h0} Mode 3:
            /// APB_RDATA[31:0] = {16’RXFIFO[23], RXFIFO[23:8]}
            RXOM: u2,
            /// TXFIFO Input Mode (Mode0, 1)
            /// 0: Valid data at the MSB of TXFIFO Register
            /// 1: Valid data at the LSB of TXFIFO Register Example for 20-bit transmitted audio
            /// sample: Mode 0: TXFIFO[23:0] = {APB_WDATA[31:12], 4’h0} Mode 1: TXFIFO[23:0] =
            /// {APB_WDATA[19:0], 4’h0}
            TXIM: u1,
            reserved0: u1,
            /// RX FIFO Trigger Level Interrupt and DMA request trigger level for RX FIFO normal
            /// condition. Trigger Level = RXTL + 1
            RXTL: u7,
            reserved1: u1,
            /// TX FIFO Empty Trigger Level Interrupt and DMA request trigger level for TX FIFO
            /// normal condition. Trigger Level = TXTL
            TXTL: u8,
            /// OWA RX Synchronize Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN: u1,
            /// The bit takes effect only when the RX_SYNC_EN is set to 1. Audio
            /// Codec/I2S0/I2S1/I2S2/DMIC/OWA RX Synchronize Enable Start.
            /// 0: Disabled
            /// 1: Enabled
            RX_SYNC_EN_START: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Write ‘1’ to flush RXFIFO, self clear to ‘0’.
            FRX: u1,
            /// Write ‘1’ to flush TXFIFO, self clear to ‘0’.
            FTX: u1,
            /// Audio Hub Enable The bit takes effect only when the TXEN is set to 1. Audio
            /// codec/I2S0/I2S1/I2S2/OWA TXFIFO Hub Enable.
            /// 0: Disabled
            /// 1: Enabled
            HUB_EN: u1,
        }), base_address + 0x14);

        /// address: 0x2036018
        /// OWA FIFO Status Register
        pub const OWA_FSTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Available Sample Word Counter
            RXA_CNT: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RXFIFO Available
            /// 0: No available data in RXFIFO
            /// 1: More than one sample in RXFIFO ( >= 1 Word )
            RXA: u1,
            /// TXFIFO Empty Space Word Counter
            TXE_CNT: u8,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TXFIFO Empty (indicate the TXFIFO is not full)
            /// 0: No room for new sample in TXFIFO
            /// 1: More than one room for new sample in TXFIFO ( >= 1 Word )
            TXE: u1,
        }), base_address + 0x18);

        /// address: 0x203601c
        /// OWA Interrupt Control Register
        pub const OWA_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Data Available Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXAI_EN: u1,
            /// RXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RXOI_EN: u1,
            /// RXFIFO Data Available DRQ Enable When set to ‘1’, RXFIFO DMA Request is
            /// asserted if data is available in RXFIFO.
            /// 0: Disabled
            /// 1: Enabled
            RX_DRQ: u1,
            reserved0: u1,
            /// TXFIFO Empty Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEI_EN: u1,
            /// TXFIFO Overrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXOI_EN: u1,
            /// TXFIFO Underrun Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            TXUI_EN: u1,
            /// TXFIFO Empty DRQ Enable
            /// 0: Disabled
            /// 1: Enabled
            TX_DRQ: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// RX PARITY ERORR Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_PARERRI_EN: u1,
            /// RX UNLOCK Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_UNLOCKI_EN: u1,
            /// RX LOCK Interrupt Enable
            /// 0: Disabled
            /// 1: Enabled
            RX_LOCKI_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x1c);

        /// address: 0x203600c
        /// OWA Interrupt Status Register
        pub const OWA_ISTA = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXFIFO Available Pending Interrupt
            /// 0: No Pending IRQ
            /// 1: Data Available Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            RXA_INT: u1,
            /// RXFIFO Overrun Pending Interrupt
            /// 0: RXFIFO Overrun Pending Write ‘1’ to clear this interrupt.
            RXO_INT: u1,
            reserved0: u1,
            reserved1: u1,
            /// TX FIFO Empty Pending Interrupt
            /// 0: No Pending IRQ
            /// 1: FIFO Empty Pending Interrupt Writing “1” to clear this interrupt or
            /// automatically clear if the interrupt condition fails.
            TXE_INT: u1,
            /// TX FIFO Overrun Pending Interrupt
            /// 0: No Pending IRQ
            /// 1: FIFO Overrun Pending Interrupt Writing “1” to clear this interrupt.
            TXO_INT: u1,
            /// TX FIFO Underrun Pending Interrupt
            /// 0: No Pending IRQ
            /// 1: FIFO Underrun Pending Interrupt Writing “1” to clear this interrupt.
            TXU_INT: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// RX Parity Error Pending Interrupt
            /// 0: No Pending IRQ
            /// 1: RX Parity Error Pending Interrupt Write “1” to clear this interrupt
            RX_PARERRI_INT: u1,
            /// RX Unlock Pending Interrupt
            /// 0: No Pending IRQ
            /// 1: RX Unlock Pending Interrupt (RX_LOCK_FLAG turns from 0 to 1) Write 1 to clear
            /// this interrupt.
            RX_UNLOCK_INT: u1,
            /// RX Lock Interrupt
            /// 0: No Pending IRQ
            /// 1: RX Lock Pending Interrupt (RX_LOCK_FLAG turns from 0 to 1) Write ‘1’ to
            /// clear this interrupt.
            RX_LOCK_INT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x2036010
        /// OWA RXFIFO Register
        pub const OWA_RXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// The host can get one sample by reading this register, A channel data is first,
            /// and then the B channel data.
            RX_DATA: u32,
        }), base_address + 0x10);

        /// address: 0x2036008
        /// OWA RX Configuration Register
        pub const OWA_RX_CFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disabled
            /// 1: Enabled
            RXEN: u1,
            /// Channel Status Capture
            /// 0: Idle or Capture End
            /// 1: Capture Channel Status Start The field must be set to 1 at each operation
            /// (such as recording). When set to ‘1’, the system starts to capture the
            /// channel status. When finished, the bit will automatically turn to ‘0’.
            CHST_CP: u1,
            reserved0: u1,
            /// RX Channel State Source Select
            /// 0: RX_CH_STA register holds status from Channel A
            /// 1: RX_CH_STA register holds status from Channel B
            RX_CHST_SRC: u1,
            /// RX Lock Flag
            /// 0: Unlocked
            /// 1: Locked
            RX_LOCK_FLAG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x8);

        /// address: 0x2036034
        /// OWA_RX_CHSTA0
        pub const OWA_RX_CHSTA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Application Type
            /// 0: Consumer application
            /// 1: Professional application
            PRO: u1,
            /// Audio Data Type
            /// 0: Linear PCM samples
            /// 1: Non-linear PCM audio
            TYPE: u1,
            /// Copyright
            /// 0: Copyright is asserted
            /// 1: No Copyright is asserted
            CP: u1,
            /// Emphasis Additional Format Information For bit 1 = ‘0’, Linear PCM Audio
            /// mode:
            /// 000: 2 Audio channels without pre-emphasis
            /// 001: 2 Audio channels with 50 μs/15 μs pre-emphasis
            /// 010: Reserved (For 2 Audio channels with pre-emphasis)
            /// 011: Reserved (For 2 Audio channels with pre-emphasis) 100 to 111: Reserved For
            /// bit 1 = ‘1’, Other than Linear PCM applications:
            /// 000: Default state 001 to 111: Reserved
            EMP: u3,
            /// Mode
            /// 00: Default mode 01 to 11: Reserved
            MODE: u2,
            /// Category Code Indicates the Kind of Equipment that Generates the digital audio
            /// interface Signal.
            CC: u8,
            /// Source Number
            SN: u4,
            /// Channel Number
            CN: u4,
            /// Sampling Frequency
            /// 0000: 44.1 kHz
            /// 0001: Not Indicated
            /// 0010: 48 kHz
            /// 0011: 32 kHz
            /// 0100: 22.05 kHz
            /// 0101: Reserved
            /// 0110: 24 kHz
            /// 0111: Reserved
            /// 1000: Reserved
            /// 1001: 768 kHz
            /// 1010: 96 kHz
            /// 1011: Reserved
            /// 1100: 176.4 kHz
            /// 1101: Reserved
            /// 1110: 192 kHz
            /// 1111: Reserved
            FREQ: u4,
            /// Clock Accuracy
            /// 00: Level 2
            /// 01: Level 1
            /// 10: Level 3
            /// 11: Not Matched
            CA: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x2036038
        /// OWA_RX_CHSTA1
        pub const OWA_RX_CHSTA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Max Word Length
            /// 0: Maximum Audio sample word length is 20 bits
            /// 1: Maximum Audio sample word length is 24 bits
            MWL: u1,
            /// Sample Word Length For bit 0 = ‘0’:
            /// 000: Not indicated
            /// 001: 16 bits
            /// 010: 18 bits
            /// 100: 19 bits
            /// 101: 20 bits
            /// 110: 17 bits
            /// 111: Reserved For bit 0 = ‘1’:
            /// 000: Not indicated
            /// 001: 20 bits
            /// 010: 22 bits
            /// 100: 23 bits
            /// 101: 24 bits
            /// 110: 21 bits
            /// 111: Reserved
            WL: u3,
            /// Original Sampling Frequency
            /// 0000: Not indicated
            /// 0001: 192 kHz
            /// 0010: 12 kHz
            /// 0011: 176.4 kHz
            /// 0100: Reserved
            /// 0101: 96 kHz
            /// 0110: 8 kHz
            /// 0111: 88.2 kHz
            /// 1000: 16 kHz
            /// 1001: 24 kHz
            /// 1010: 11.025 kHz
            /// 1011: 22.05 kHz
            /// 1100: 32 kHz
            /// 1101: 48 kHz
            /// 1110: Reserved
            /// 1111: 44.1 kHz
            ORIG_FREQ: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x38);

        /// address: 0x2036028
        /// OWA RX Counter Register
        pub const OWA_RX_CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX Sample Counter The audio sample number of writing into RXFIFO. When one
            /// sample is written by Codec, the RX sample counter register increases by one. The
            /// RX counter register can be set to any initial value at any time. After being
            /// updated by the initial value, the counter register should count on the base of
            /// this value.
            RX_CNT: u32,
        }), base_address + 0x28);

        /// address: 0x2036020
        /// OWA_TXFIFO
        pub const OWA_TXFIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmitting A, B channel data should be written this register one by one. A
            /// channel data is first, and then the B channel data.
            TX_DATA: u32,
        }), base_address + 0x20);

        /// address: 0x2036004
        /// OWA TX Configuration Register
        pub const OWA_TX_CFIG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Enable
            /// 0: Disabled
            /// 1: Enabled
            TXEN: u1,
            /// CHSTMODE
            /// 0: Channel status A and B set to 0
            /// 1: Channel status A and B generated from TX_CHSTA
            TX_CHM: u1,
            /// TX Sample Format
            /// 00: 16 bits
            /// 01: 20 bits
            /// 10: 24 bits
            /// 11: Reserved
            TX_SF: u2,
            /// TX Clock Divide Ratio Clock divide ratio = TX_TATIO + 1 Fs =
            /// PLL_AUDIO/[(TX_TATIO + 1)*64*2]
            TX_RATIO: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// TX Data Type
            /// 0: Linear PCM (Valid bit of both sub-frame set to 0 )
            /// 1: Non-audio (Valid bit of both sub-frame set to 1)
            TX_AUDIO: u1,
            /// Audio Sample Select when TX FIFO Underrun
            /// 0: Sending 0
            /// 1: Sending the last audio Note: This bit is only valid in PCM mode.
            ASS: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Tx Single Channel Mode
            /// 0: Disabled
            /// 1: Enabled
            TX_SINGLE_MODE: u1,
        }), base_address + 0x4);

        /// address: 0x203602c
        /// OWA TX Channel Status Register0
        pub const OWA_TX_CHSTA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Application Type
            /// 0: Consumer application
            /// 1: Professional application This bit must be fixed to “0”.
            PRO: u1,
            /// Audio Data Type
            /// 0: Linear PCM samples
            /// 1: Non-linear PCM audio
            TYPE: u1,
            /// Copyright
            /// 0: Copyright is asserted
            /// 1: No copyright is asserted
            CP: u1,
            /// Emphasis Additional format information For bit 1 = “0”, Linear PCM audio
            /// mode:
            /// 000: 2 audio channels without pre-emphasis
            /// 001: 2 audio channels with 50 μs/15 μs pre-emphasis
            /// 010: Reserved (for 2 audio channels with pre-emphasis)
            /// 011: Reserved (for 2 audio channels with pre-emphasis) 100 to 111: Reserved For
            /// bit 1 = “1”, other than Linear PCM applications:
            /// 000: Default state 001 to 111: Reserved
            EMP: u3,
            /// Mode
            /// 00: Default Mode 01 to 11: Reserved
            MODE: u2,
            /// Category Code Indicates the kind of equipment that generates the digital audio
            /// interface signal.
            CC: u8,
            /// Source Number
            SN: u4,
            /// Channel Number
            CN: u4,
            /// Sampling Frequency
            /// 0000: 44.1 kHz
            /// 0001: Not indicated
            /// 0010: 48 kHz
            /// 0011: 32 kHz
            /// 0100: 22.05 kHz
            /// 0101: Reserved
            /// 0110: 24 kHz
            /// 0111: Reserved
            /// 1000: Reserved
            /// 1001: 768 kHz
            /// 1010: 96 kHz
            /// 1011: Reserved
            /// 1100: 176.4 kHz
            /// 1101: Reserved
            /// 1110: 192 kHz
            /// 1111: Reserved
            FREQ: u4,
            /// Clock Accuracy
            /// 00: Level 2
            /// 01: Level 1
            /// 10: Level 3
            /// 11: Not matched
            CA: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x2c);

        /// address: 0x2036030
        /// OWA TX Channel Status Register1
        pub const OWA_TX_CHSTA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Max Word Length
            /// 0: Maximum audio sample word length is 20 bits
            /// 1: Maximum audio sample word length is 24 bits
            MWL: u1,
            /// Sample Word Length For bit 0 = “0”:
            /// 000: Not indicated
            /// 001: 16 bits
            /// 010: 18 bits
            /// 100: 19 bits
            /// 101: 20 bits
            /// 110: 17 bits
            /// 111: Reserved For bit 0 = “1”:
            /// 000: Not indicated
            /// 001: 20 bits
            /// 010: 22 bits
            /// 100: 23 bits
            /// 101: 24 bits
            /// 110: 21 bits
            /// 111: Reserved
            WL: u3,
            /// Original Sampling Frequency
            /// 0000: Not indicated
            /// 0001: 192 kHz
            /// 0010: 12 kHz
            /// 0011: 176.4 kHz
            /// 0100: Reserved
            /// 0101: 96 kHz
            /// 0110: 8 kHz
            /// 0111: 88.2 kHz
            /// 1000: 16 kHz
            /// 1001: 24 kHz
            /// 1010: 11.025 kHz
            /// 1011: 22.05 kHz
            /// 1100: 32 kHz
            /// 1101: 48 kHz
            /// 1110: Reserved
            /// 1111: 44.1 kHz
            ORIG_FREQ: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x2036024
        /// OWA TX Counter Register
        pub const OWA_TX_CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX Sample Counter The audio sample number of sending into TXFIFO. When one
            /// sample is put into TXFIFO by DMA or by host IO, the TX sample counter register
            /// increases by one. The TX sample counter register can be set to any initial value
            /// at any time. After updated by the initial value, the counter register should
            /// count on the base of this initial value.
            TX_CNT: u32,
        }), base_address + 0x24);
    };

    /// GPIO
    pub const GPIO = struct {
        pub const base_address = 0x2000000;

        /// address: 0x2000030
        /// PB Configure Register 0
        pub const PB_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PB0 Select 0000:Input 0001:Output 0010:PWM3 0011:IR-TX 0100:TWI2-SCK
            /// 0101:SPI1-WP/DBI-TE 0110:UART0-TX 0111:UART2-TX 1000:OWA-OUT 1001:Reserved
            /// 1110:PB-EINT0 1111:IO Disable
            PB0_SELECT: u4,
            /// PB1 Select 0000:Input 0001:Output 0010:PWM4 0011:I2S2-DOUT3 0100:TWI2-SDA
            /// 0101:I2S2-DIN3 0110:UART0-RX 0111:UART2-RX 1000:IR-RX 1001:Reserved
            /// 1110:PB-EINT1 1111:IO Disable
            PB1_SELECT: u4,
            /// PB2 Select 0000:Input 0001:Output 0010:LCD0-D0 0011:I2S2-DOUT2 0100:TWI0-SDA
            /// 0101:I2S2-DIN2 0110:LCD0-D18 0111:UART4-TX 1000:Reserved 1001:Reserved
            /// 1110:PB-EINT2 1111:IO Disable
            PB2_SELECT: u4,
            /// PB3 Select 0000:Input 0001:Output 0010:LCD0-D1 0011:I2S2-DOUT1 0100:TWI0-SCK
            /// 0101:I2S2-DIN0 0110:LCD0-D19 0111:UART4-RX 1000:Reserved 1001:Reserved
            /// 1110:PB-EINT3 1111:IO Disable
            PB3_SELECT: u4,
            /// PB4 Select 0000:Input 0001:Output 0010:LCD0-D8 0011:I2S2-DOUT0 0100:TWI1-SCK
            /// 0101:I2S2-DIN1 0110:LCD0-D20 0111:UART5-TX 1000:Reserved 1001:Reserved
            /// 1110:PB-EINT4 1111:IO Disable
            PB4_SELECT: u4,
            /// PB5 Select 0000:Input 0001:Output 0010:LCD0-D9 0011:I2S2-BCLK 0100:TWI1-SDA
            /// 0101:PWM0 0110:LCD0-D21 0111:UART5-RX 1000:Reserved 1001:Reserved 1110:PB-EINT5
            /// 1111:IO Disable
            PB5_SELECT: u4,
            /// PB6 Select 0000:Input 0001:Output 0010:LCD0-D16 0011:I2S2-LRCK 0100:TWI3-SCK
            /// 0101:PWM1 0110:LCD0-D22 0111:UART3-TX 1000:CPUBIST0 1001:Reserved 1110:PB-EINT6
            /// 1111:IO Disable
            PB6_SELECT: u4,
            /// PB7 Select 0000:Input 0001:Output 0010:LCD0-D17 0011:I2S2-MCLK 0100:TWI3-SDA
            /// 0101:IR-RX 0110:LCD0-D23 0111:UART3-RX 1000:CPUBIST1 1001:Reserved 1110:PB-EINT7
            /// 1111:IO Disable
            PB7_SELECT: u4,
        }), base_address + 0x30);

        /// address: 0x2000034
        /// PB Configure Register 1
        pub const PB_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PB8 Select 0000:Input 0001:Output 0010:DMIC-DATA3 0011:PWM5 0100:TWI2-SCK
            /// 0101:SPI1-HOLD/DBI-DCX/DBI-WRX 0110:UART0-TX 0111:UART1-TX 1000:Reserved
            /// 1001:Reserved 1110:PB-EINT8 1111:IO Disable
            PB8_SELECT: u4,
            /// PB9 Select 0000:Input 0001:Output 0010:DMIC-DATA2 0011:PWM6 0100:TWI2-SDA
            /// 0101:SPI1-MISO/DBI-SDI/DBI-TE/DBI-DCX 0110:UART0-RX 0111:UART1-RX 1000:Reserved
            /// 1001:Reserved 1110:PB-EINT9 1111:IO Disable
            PB9_SELECT: u4,
            /// PB10 Select 0000:Input 0001:Output 0010:DMIC-DATA1 0011:PWM7 0100:TWI0-SCK
            /// 0101:SPI1-MOSI/DBI-SDO 0110:CLK-FANOUT0 0111:UART1-RTS 1000:Reserved
            /// 1001:Reserved 1110:PB-EINT10 1111:IO Disable
            PB10_SELECT: u4,
            /// PB11 Select 0000:Input 0001:Output 0010:DMIC-DATA0 0011:PWM2 0100:TWI0-SDA
            /// 0101:SPI1-CLK/DBI-SCLK 0110:CLK-FANOUT1 0111:UART1-CTS 1000:Reserved
            /// 1001:Reserved 1110:PB-EINT11 1111:IO Disable
            PB11_SELECT: u4,
            /// PB12 Select 0000:Input 0001:Output 0010:DMIC-CLK 0011:PWM0 0100:OWA-IN
            /// 0101:SPI1-CS/DBI-CSX 0110:CLK-FANOUT2 0111:IR-RX 1000:Reserved 1001:Reserved
            /// 1110:PB-EINT12 1111:IO Disable
            PB12_SELECT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x34);

        /// address: 0x2000040
        /// PB Data Register
        pub const PB_DAT = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x40);

        /// address: 0x2000044
        /// PB Multi_Driving Register 0
        pub const PB_DRV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PB0 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB0_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PB1 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB1_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PB2 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB2_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PB3 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB3_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PB4 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB4_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PB5 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB5_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PB6 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB6_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PB7 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB7_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x44);

        /// address: 0x2000048
        /// PB Multi_Driving Register 1
        pub const PB_DRV1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PB8 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB8_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PB9 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB9_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PB10 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB10_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PB11 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB11_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PB12 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PB12_DRV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x48);

        /// address: 0x2000220
        /// PB External Interrupt Configure Register 0
        pub const PB_EINT_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT0_CFG: u4,
            /// External INT1 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT1_CFG: u4,
            /// External INT2 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT2_CFG: u4,
            /// External INT3 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT3_CFG: u4,
            /// External INT4 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT4_CFG: u4,
            /// External INT5 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT5_CFG: u4,
            /// External INT6 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT6_CFG: u4,
            /// External INT7 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT7_CFG: u4,
        }), base_address + 0x220);

        /// address: 0x2000224
        /// PB_EINT_CFG1
        pub const PB_EINT_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT8 Mode.
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT8_CFG: u4,
            /// External INT9 Mode.
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT9_CFG: u4,
            /// External INT10 Mode.
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT10_CFG: u4,
            /// External INT11 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT11_CFG: u4,
            /// External INT12 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT12_CFG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x224);

        /// address: 0x2000230
        /// PB External Interrupt Control Register
        pub const PB_EINT_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Enable
            /// 0: Disable
            /// 1: Enable
            EINT0_CTL: u1,
            /// External INT1 Enable
            /// 0: Disable
            /// 1: Enable
            EINT1_CTL: u1,
            /// External INT2 Enable
            /// 0: Disable
            /// 1: Enable
            EINT2_CTL: u1,
            /// External INT3 Enable
            /// 0: Disable
            /// 1: Enable
            EINT3_CTL: u1,
            /// External INT4 Enable
            /// 0: Disable
            /// 1: Enable
            EINT4_CTL: u1,
            /// External INT5 Enable
            /// 0: Disable
            /// 1: Enable
            EINT5_CTL: u1,
            /// External INT6 Enable
            /// 0: Disable
            /// 1: Enable
            EINT6_CTL: u1,
            /// External INT7 Enable
            /// 0: Disable
            /// 1: Enable
            EINT7_CTL: u1,
            /// External INT8 Enable
            /// 0: Disable
            /// 1: Enable
            EINT8_CTL: u1,
            /// External INT9 Enable
            /// 0: Disable
            /// 1: Enable
            EINT9_CTL: u1,
            /// External INT10 Enable
            /// 0: Disable
            /// 1: Enable
            EINT10_CTL: u1,
            /// External INT11 Enable
            /// 0: Disable
            /// 1: Enable
            EINT11_CTL: u1,
            /// External INT12 Enable
            /// 0: Disable
            /// 1: Enable
            EINT12_CTL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x230);

        /// address: 0x2000238
        /// PB External Interrupt Debounce Register
        pub const PB_EINT_DEB = @intToPtr(*volatile Mmio(32, packed struct {
            /// PIO Interrupt Clock Select
            /// 0: LOSC 32KHz
            /// 1: HOSC 24MHz
            PIO_INT_CLK_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debounce Clock Pre_scale n The selected clock source is prescaled by 2^n.
            DEB_CLK_PRE_SCALE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x238);

        /// address: 0x2000234
        /// PB External Interrupt Status Register
        pub const PB_EINT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT0_STATUS: u1,
            /// External INT1 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT1_STATUS: u1,
            /// External INT2 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT2_STATUS: u1,
            /// External INT3 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT3_STATUS: u1,
            /// External INT4 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT4_STATUS: u1,
            /// External INT5 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT5_STATUS: u1,
            /// External INT6 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT6_STATUS: u1,
            /// External INT7 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT7_STATUS: u1,
            /// External INT8 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT8_STATUS: u1,
            /// External INT9 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT9_STATUS: u1,
            /// External INT10 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT10_STATUS: u1,
            /// External INT11 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT11_STATUS: u1,
            /// External INT12 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT12_STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x234);

        /// address: 0x2000054
        /// PB Pull Register 0
        pub const PB_PULL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PB0 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB0_PULL: u2,
            /// PB1 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB1_PULL: u2,
            /// PB2 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB2_PULL: u2,
            /// PB3 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB3_PULL: u2,
            /// PB4 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB4_PULL: u2,
            /// PB5 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB5_PULL: u2,
            /// PB6 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB6_PULL: u2,
            /// PB7 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB7_PULL: u2,
            /// PB8 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB8_PULL: u2,
            /// PB9 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB9_PULL: u2,
            /// PB10 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB10_PULL: u2,
            /// PB11 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB11_PULL: u2,
            /// PB12 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PB12_PULL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x54);

        /// address: 0x2000060
        /// PC Configure Register 0
        pub const PC_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PC0 Select 0000:Input 0001:Output 0010:UART2-TX 0011:TWI2-SCK 0100:LEDC-DO
            /// 0101:Reserved 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT0 1111:IO Disable
            PC0_SELECT: u4,
            /// PC1 Select. 0000:Input 0001:Output 0010:UART2-RX 0011:TWI2-SDA 0100:Reserved
            /// 0101:Reserved 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT1 1111:IO Disable
            PC1_SELECT: u4,
            /// PC2 Select 0000:Input 0001:Output 0010:SPI0-CLK 0011:SDC2-CLK 0100:Reserved
            /// 0101:Reserved 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT2 1111:IO Disable
            PC2_SELECT: u4,
            /// PC3 Select 0000:Input 0001:Output 0010:SPI0-CS0 0011:SDC2-CMD 0100:Reserved
            /// 0101:Reserved 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT3 1111:IO Disable
            PC3_SELECT: u4,
            /// PC4 Select 0000:Input 0001:Output 0010:SPI0-MOSI 0011:SDC2-D2 0100:BOOT-SEL0
            /// 0101:Reserved 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT4 1111:IO Disable
            PC4_SELECT: u4,
            /// PC5 Select 0000:Input 0001:Output 0010:SPI0-MISO 0011:SDC2-D1 0100:BOOT-SEL1
            /// 0101:Reserved 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT5 1111:IO Disable
            PC5_SELECT: u4,
            /// PC6 Select 0000:Input 0001:Output 0010:SPI0-WP 0011:SDC2-D0 0100:UART3-TX
            /// 0101:TWI3-SCK 0110:DBG-CLK 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT6 1111:IO Disable
            PC6_SELECT: u4,
            /// PC7 Select 0000:Input 0001:Output 0010:SPI0-HOLD 0011:SDC2-D3 0100:UART3-RX
            /// 0101:TWI3-SDA 0110:TCON-TRIG 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PC-EINT7 1111:IO Disable
            PC7_SELECT: u4,
        }), base_address + 0x60);

        /// address: 0x2000070
        /// PC Data Register
        pub const PC_DAT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x70);

        /// address: 0x2000074
        /// PC Multi_Driving Register 0
        pub const PC_DRV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PC0 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC0_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PC1 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC1_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PC2 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC2_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PC3 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC3_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PC4 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC4_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PC5 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC5_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PC6 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC6_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PC7 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PC7_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x74);

        /// address: 0x2000240
        /// PC External Interrupt Configure Register 0
        pub const PC_EINT_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT0_CFG: u4,
            /// External INT1 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT1_CFG: u4,
            /// External INT2 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT2_CFG: u4,
            /// External INT3 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT3_CFG: u4,
            /// External INT4 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT4_CFG: u4,
            /// External INT5 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT5_CFG: u4,
            /// External INT6 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT6_CFG: u4,
            /// External INT7 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT7_CFG: u4,
        }), base_address + 0x240);

        /// address: 0x2000250
        /// PC External Interrupt Control Register
        pub const PC_EINT_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Enable
            /// 0: Disable
            /// 1: Enable
            EINT0_CTL: u1,
            /// External INT1 Enable
            /// 0: Disable
            /// 1: Enable
            EINT1_CTL: u1,
            /// External INT2 Enable
            /// 0: Disable
            /// 1: Enable
            EINT2_CTL: u1,
            /// External INT3 Enable
            /// 0: Disable
            /// 1: Enable
            EINT3_CTL: u1,
            /// External INT4 Enable
            /// 0: Disable
            /// 1: Enable
            EINT4_CTL: u1,
            /// External INT5 Enable
            /// 0: Disable
            /// 1: Enable
            EINT5_CTL: u1,
            /// External INT6 Enable
            /// 0: Disable
            /// 1: Enable
            EINT6_CTL: u1,
            /// External INT7 Enable
            /// 0: Disable
            /// 1: Enable
            EINT7_CTL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x250);

        /// address: 0x2000258
        /// PC External Interrupt Debounce Register
        pub const PC_EINT_DEB = @intToPtr(*volatile Mmio(32, packed struct {
            /// PIO Interrupt Clock Select
            /// 0: LOSC 32KHz
            /// 1: HOSC 24MHz
            PIO_INT_CLK_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debounce Clock Pre_scale n The selected clock source is prescaled by 2^n.
            DEB_CLK_PRE_SCALE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x258);

        /// address: 0x2000254
        /// PC External Interrupt Status Register
        pub const PC_EINT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT0_STATUS: u1,
            /// External INT1 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT1_STATUS: u1,
            /// External INT2 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT2_STATUS: u1,
            /// External INT3 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT3_STATUS: u1,
            /// External INT4 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT4_STATUS: u1,
            /// External INT5 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT5_STATUS: u1,
            /// External INT6 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT6_STATUS: u1,
            /// External INT7 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT7_STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x254);

        /// address: 0x2000084
        /// PC Pull Register 0
        pub const PC_PULL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PC0 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC0_PULL: u2,
            /// PC1 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC1_PULL: u2,
            /// PC2 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC2_PULL: u2,
            /// PC3 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC3_PULL: u2,
            /// PC4 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC4_PULL: u2,
            /// PC5 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC5_PULL: u2,
            /// PC6 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC6_PULL: u2,
            /// PC7 Pull_up/down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PC7_PULL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x2000090
        /// PD Configure Register 0
        pub const PD_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD0 Select 0000:Input 0001:Output 0010:LCD0-D2 0011:LVDS0-V0P 0100:DSI-D0P
            /// 0101:TWI0-SCK 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT0 1111:IO Disable
            PD0_SELECT: u4,
            /// PD1 Select 0000:Input 0001:Output 0010:LCD0-D3 0011:LVDS0-V0N 0100:DSI-D0N
            /// 0101:UART2-TX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT1 1111:IO Disable
            PD1_SELECT: u4,
            /// PD2 Select 0000:Input 0001:Output 0010:LCD0-D4 0011:LVDS0-V1P 0100:DSI-D1P
            /// 0101:UART2-RX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT2 1111:IO Disable
            PD2_SELECT: u4,
            /// PD3 Select 0000:Input 0001:Output 0010:LCD0-D5 0011:LVDS0-V1N 0100:DSI-D1N
            /// 0101:UART2-RTS 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT3 1111:IO Disable
            PD3_SELECT: u4,
            /// PD4 Select 0000:Input 0001:Output 0010:LCD0-D6 0011:LVDS0-V2P 0100:DSI-CKP
            /// 0101:UART2-CTS 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT4 1111:IO Disable
            PD4_SELECT: u4,
            /// PD5 Select 0000:Input 0001:Output 0010:LCD0-D7 0011:LVDS0-V2N 0100:DSI-CKN
            /// 0101:UART5-TX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT5 1111:IO Disable
            PD5_SELECT: u4,
            /// PD6 Select 0000:Input 0001:Output 0010:LCD0-D10 0011:LVDS0-CKP 0100:DSI-D2P
            /// 0101:UART5-RX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT6 1111:IO Disable
            PD6_SELECT: u4,
            /// PD7 Select 0000:Input 0001:Output 0010:LCD0-D11 0011:LVDS0-CKN 0100:DSI-D2N
            /// 0101:UART4-TX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT7 1111:IO Disable
            PD7_SELECT: u4,
        }), base_address + 0x90);

        /// address: 0x2000094
        /// PD Configure Register 1
        pub const PD_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD8 Select 0000:Input 0001:Output 0010:LCD0-D12 0011:LVDS0-V3P 0100:DSI-D3P
            /// 0101:UART4-RX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PD-EINT8 1111:IO Disable
            PD8_SELECT: u4,
            /// PD9 Select 0000:Input 0001:Output 0010:LCD0-D13 0011:LVDS0-V3N 0100:DSI-D3N
            /// 0101:PWM6 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT9
            /// 1111:IO Disable
            PD9_SELECT: u4,
            /// PD10 Select 0000:Input 0001:Output 0010:LCD0-D14 0011:LVDS1-V0P
            /// 0100:SPI1-CS/DBI-CSX 0101:UART3-TX 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PD-EINT10 1111:IO Disable
            PD10_SELECT: u4,
            /// PD11 Select 0000:Input 0001:Output 0010:LCD0-D15 0011:LVDS1-V0N
            /// 0100:SPI1-CLK/DBI-SCLK 0101:UART3-RX 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PD-EINT11 1111:IO Disable
            PD11_SELECT: u4,
            /// PD12 Select 0000:Input 0001:Output 0010:LCD0-D18 0011:LVDS1-V1P
            /// 0100:SPI1-MOSI/DBI-SDO 0101:TWI0-SDA 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PD-EINT12 1111:IO Disable
            PD12_SELECT: u4,
            /// PD13 Select 0000:Input 0001:Output 0010:LCD0-D19 0011:LVDS1-V1N
            /// 0100:SPI1-MISO/DBI-SDI/DBI-TE/DBI-DCX 0101:UART3-RTS 0110:Reserved 0111:Reserved
            /// 1000:Reserved 1001:Reserved 1110:PD-EINT13 1111:IO Disable
            PD13_SELECT: u4,
            /// PD14 Select 0000:Input 0001:Output 0010:LCD0-D20 0011:LVDS1-V2P
            /// 0100:SPI1-HOLD/DBI-DCX/DBI-WRX 0101:UART3-CTS 0110:Reserved 0111:Reserved
            /// 1000:Reserved 1001:Reserved 1110:PD-EINT14 1111:IO Disable
            PD14_SELECT: u4,
            /// PD15 Select 0000:Input 0001:Output 0010:LCD0-D21 0011:LVDS1-V2N
            /// 0100:SPI1-WP/DBI-TE 0101:IR-RX 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PD-EINT15 1111:IO Disable
            PD15_SELECT: u4,
        }), base_address + 0x94);

        /// address: 0x2000098
        /// PD Configure Register 2
        pub const PD_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD16 Select 0000:Input 0001:Output 0010:LCD0-D22 0011:LVDS1-CKP 0100:DMIC-DATA3
            /// 0101:PWM0 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT16
            /// 1111:IO Disable
            PD16_SELECT: u4,
            /// PD17 Select. 0000:Input 0001:Output 0010:LCD0-D23 0011:LVDS1-CKN 0100:DMIC-DATA2
            /// 0101:PWM1 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT17
            /// 1111:IO Disable
            PD17_SELECT: u4,
            /// PD18 Select 0000:Input 0001:Output 0010:LCD0-CLK 0011:LVDS1-V3P 0100:DMIC-DATA1
            /// 0101:PWM2 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT18
            /// 1111:IO Disable
            PD18_SELECT: u4,
            /// PD19 Select 0000:Input 0001:Output 0010:LCD0-DE 0011:LVDS1-V3N 0100:DMIC-DATA0
            /// 0101:PWM3 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT19
            /// 1111:IO Disable
            PD19_SELECT: u4,
            /// PD20 Select 0000:Input 0001:Output 0010:LCD0-HSYNC 0011:TWI2-SCK 0100:DMIC-CLK
            /// 0101:PWM4 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT20
            /// 1111:IO Disable
            PD20_SELECT: u4,
            /// PD21 Select 0000:Input 0001:Output 0010:LCD0-VSYNC 0011:TWI2-SDA 0100:UART1-TX
            /// 0101:PWM5 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT21
            /// 1111:IO Disable
            PD21_SELECT: u4,
            /// PD22 Select 0000:Input 0001:Output 0010:OWA-OUT 0011:IR-RX 0100:UART1-RX
            /// 0101:PWM7 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PD-EINT22
            /// 1111:IO Disable
            PD22_SELECT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x98);

        /// address: 0x20000a0
        /// PD Data Register
        pub const PD_DAT = @intToPtr(*volatile MmioInt(32, u23), base_address + 0xa0);

        /// address: 0x20000a4
        /// PD Multi_Driving Register 0
        pub const PD_DRV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD0 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD0_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PD1 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD1_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PD2 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD2_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PD3 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD3_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PD4 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD4_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PD5 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD5_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PD6 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD6_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PD7 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD7_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xa4);

        /// address: 0x20000a8
        /// PD Multi_Driving Register 1
        pub const PD_DRV1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD8 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD8_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PD9 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD9_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PD10 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD10_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PD11 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD11_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PD12 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD12_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PD13 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD13_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PD14 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD14_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PD15 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD15_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xa8);

        /// address: 0x20000ac
        /// PD Multi_Driving Register 2
        pub const PD_DRV2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD16 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD16_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PD17 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD17_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PD18 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD18_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PD19 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD19_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PD20 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD20_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PD21 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD21_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PD22 Multi_Driving Select.
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PD22_DRV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xac);

        /// address: 0x2000260
        /// PD External Interrupt Configure Register 0
        pub const PD_EINT_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT0_CFG: u4,
            /// External INT1 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT1_CFG: u4,
            /// External INT2 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT2_CFG: u4,
            /// External INT3 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT3_CFG: u4,
            /// External INT4 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT4_CFG: u4,
            /// External INT5 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT5_CFG: u4,
            /// External INT6 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT6_CFG: u4,
            /// External INT7 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT7_CFG: u4,
        }), base_address + 0x260);

        /// address: 0x2000264
        /// PD External Interrupt Configure Register 1
        pub const PD_EINT_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT8 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT8_CFG: u4,
            /// External INT9 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT9_CFG: u4,
            /// External INT10 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT10_CFG: u4,
            /// External INT11 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT11_CFG: u4,
            /// External INT12 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT12_CFG: u4,
            /// External INT13 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT13_CFG: u4,
            /// External INT14 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT14_CFG: u4,
            /// External INT15 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT15_CFG: u4,
        }), base_address + 0x264);

        /// address: 0x2000268
        /// PD External Interrupt Configure Register 2
        pub const PD_EINT_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT16 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT16_CFG: u4,
            /// External INT17 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT17_CFG: u4,
            /// External INT18 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT18_CFG: u4,
            /// External INT19 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT19_CFG: u4,
            /// External INT20 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT20_CFG: u4,
            /// External INT21 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT21_CFG: u4,
            /// External INT22 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT22_CFG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x268);

        /// address: 0x2000270
        /// PD External Interrupt Control Register
        pub const PD_EINT_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Enable
            /// 0: Disable
            /// 1: Enable
            EINT0_CTL: u1,
            /// External INT1 Enable
            /// 0: Disable
            /// 1: Enable
            EINT1_CTL: u1,
            /// External INT2 Enable
            /// 0: Disable
            /// 1: Enable
            EINT2_CTL: u1,
            /// External INT3 Enable
            /// 0: Disable
            /// 1: Enable
            EINT3_CTL: u1,
            /// External INT4 Enable
            /// 0: Disable
            /// 1: Enable
            EINT4_CTL: u1,
            /// External INT5 Enable
            /// 0: Disable
            /// 1: Enable
            EINT5_CTL: u1,
            /// External INT6 Enable
            /// 0: Disable
            /// 1: Enable
            EINT6_CTL: u1,
            /// External INT7 Enable
            /// 0: Disable
            /// 1: Enable
            EINT7_CTL: u1,
            /// External INT8 Enable
            /// 0: Disable
            /// 1: Enable
            EINT8_CTL: u1,
            /// External INT9 Enable
            /// 0: Disable
            /// 1: Enable
            EINT9_CTL: u1,
            /// External INT10 Enable
            /// 0: Disable
            /// 1: Enable
            EINT10_CTL: u1,
            /// External INT11 Enable
            /// 0: Disable
            /// 1: Enable
            EINT11_CTL: u1,
            /// External INT12 Enable
            /// 0: Disable
            /// 1: Enable
            EINT12_CTL: u1,
            /// External INT13 Enable
            /// 0: Disable
            /// 1: Enable
            EINT13_CTL: u1,
            /// External INT14 Enable
            /// 0: Disable
            /// 1: Enable
            EINT14_CTL: u1,
            /// External INT15 Enable
            /// 0: Disable
            /// 1: Enable
            EINT15_CTL: u1,
            /// External INT16 Enable
            /// 0: Disable
            /// 1: Enable
            EINT16_CTL: u1,
            /// External INT17 Enable
            /// 0: Disable
            /// 1: Enable
            EINT17_CTL: u1,
            /// External INT18 Enable
            /// 0: Disable
            /// 1: Enable
            EINT18_CTL: u1,
            /// External INT19 Enable
            /// 0: Disable
            /// 1: Enable
            EINT19_CTL: u1,
            /// External INT20 Enable
            /// 0: Disable
            /// 1: Enable
            EINT20_CTL: u1,
            /// External INT21 Enable
            /// 0: Disable
            /// 1: Enable
            EINT21_CTL: u1,
            /// External INT22 Enable
            /// 0: Disable
            /// 1: Enable
            EINT22_CTL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x270);

        /// address: 0x2000278
        /// PD External Interrupt Debounce Register
        pub const PD_EINT_DEB = @intToPtr(*volatile Mmio(32, packed struct {
            /// PIO Interrupt Clock Select
            /// 0: LOSC 32KHz
            /// 1: HOSC 24MHz
            PIO_INT_CLK_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debounce Clock Pre_scale n The selected clock source is prescaled by 2^n.
            DEB_CLK_PRE_SCALE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x278);

        /// address: 0x2000274
        /// PD External Interrupt Status Register
        pub const PD_EINT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT0_STATUS: u1,
            /// External INT1 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT1_STATUS: u1,
            /// External INT2 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT2_STATUS: u1,
            /// External INT3 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT3_STATUS: u1,
            /// External INT4 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT4_STATUS: u1,
            /// External INT5 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT5_STATUS: u1,
            /// External INT6 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT6_STATUS: u1,
            /// External INT7 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT7_STATUS: u1,
            /// External INT8 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT8_STATUS: u1,
            /// External INT9 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT9_STATUS: u1,
            /// External INT10 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT10_STATUS: u1,
            /// External INT11 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT11_STATUS: u1,
            /// External INT12 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT12_STATUS: u1,
            /// External INT13 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT13_STATUS: u1,
            /// External INT14 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT14_STATUS: u1,
            /// External INT15 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT15_STATUS: u1,
            /// External INT16 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT16_STATUS: u1,
            /// External INT17 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT17_STATUS: u1,
            /// External INT18 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT18_STATUS: u1,
            /// External INT19 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT19_STATUS: u1,
            /// External INT20 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT20_STATUS: u1,
            /// External INT21 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT21_STATUS: u1,
            /// External INT22 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT22_STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x274);

        /// address: 0x20000b4
        /// PD Pull Register 0
        pub const PD_PULL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD0 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD0_PULL: u2,
            /// PD1 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD1_PULL: u2,
            /// PD2 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD2_PULL: u2,
            /// PD3 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD3_PULL: u2,
            /// PD4 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD4_PULL: u2,
            /// PD5 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD5_PULL: u2,
            /// PD6 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD6_PULL: u2,
            /// PD7 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD7_PULL: u2,
            /// PD8 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD8_PULL: u2,
            /// PD9 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD9_PULL: u2,
            /// PD10 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD10_PULL: u2,
            /// PD11 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD11_PULL: u2,
            /// PD12 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD12_PULL: u2,
            /// PD13 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD13_PULL: u2,
            /// PD14 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD14_PULL: u2,
            /// PD15 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD15_PULL: u2,
        }), base_address + 0xb4);

        /// address: 0x20000b8
        /// PD Pull Register 1
        pub const PD_PULL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PD16 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD16_PULL: u2,
            /// PD17 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD17_PULL: u2,
            /// PD18 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD18_PULL: u2,
            /// PD19 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD19_PULL: u2,
            /// PD20 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD20_PULL: u2,
            /// PD21 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD21_PULL: u2,
            /// PD22 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PD22_PULL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xb8);

        /// address: 0x20000c0
        /// PE Configure Register 0
        pub const PE_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE0 Select 0000:Input 0001:Output 0010:NCSI0-HSYNC 0011:UART2-RTS 0100:TWI1-SCK
            /// 0101:LCD0-HSYNC 0110:Reserved 0111:Reserved 1000:RGMII-RXCTRL/RMII-CRS-DV
            /// 1001:Reserved 1110:PE-EINT0 1111:IO Disable
            PE0_SELECT: u4,
            /// PE1 Select 0000:Input 0001:Output 0010:NCSI0-VSYNC 0011:UART2-CTS 0100:TWI1-SDA
            /// 0101:LCD0-VSYNC 0110:Reserved 0111:Reserved 1000:RGMII-RXD0/RMII-RXD0
            /// 1001:Reserved 1110:PE-EINT1 1111:IO Disable
            PE1_SELECT: u4,
            /// PE2 Select 0000:Input 0001:Output 0010:NCSI0-PCLK 0011:UART2-TX 0100:TWI0-SCK
            /// 0101:CLK-FANOUT0 0110:UART0-TX 0111:Reserved 1000:RGMII-RXD1/RMII-RXD1
            /// 1001:Reserved 1110:PE-EINT2 1111:IO Disable
            PE2_SELECT: u4,
            /// PE3 Select 0000:Input 0001:Output 0010:NCSI0-MCLK 0011:UART2-RX 0100:TWI0-SDA
            /// 0101:CLK-FANOUT1 0110:UART0-RX 0111:Reserved 1000:RGMII-TXCK/RMII-TXCK
            /// 1001:Reserved 1110:PE-EINT3 1111:IO Disable
            PE3_SELECT: u4,
            /// PE4 Select 0000:Input 0001:Output 0010:NCSI0-D0 0011:UART4-TX 0100:TWI2-SCK
            /// 0101:CLK-FANOUT2 0110:D-JTAG-MS 0111:R-JTAG-MS 1000:RGMII-TXD0/RMII-TXD0
            /// 1001:Reserved 1110:PE-EINT4 1111:IO Disable
            PE4_SELECT: u4,
            /// PE5 Select 0000:Input 0001:Output 0010:NCSI0-D1 0011:UART4-RX 0100:TWI2-SDA
            /// 0101:LEDC-DO 0110:D-JTAG-DI 0111:R-JTAG-DI 1000:RGMII-TXD1/RMII-TXD1
            /// 1001:Reserved 1110:PE-EINT5 1111:IO Disable
            PE5_SELECT: u4,
            /// PE6 Select 0000:Input 0001:Output 0010:NCSI0-D2 0011:UART5-TX 0100:TWI3-SCK
            /// 0101:OWA-IN 0110:D-JTAG-DO 0111:R-JTAG-DO 1000:RMII-TXCTRL/RMII-TXEN
            /// 1001:Reserved 1110:PE-EINT6 1111:IO Disable
            PE6_SELECT: u4,
            /// PE7 Select 0000:Input 0001:Output 0010:NCSI0-D3 0011:UART5-RX 0100:TWI3-SDA
            /// 0101:OWA-OUT 0110:D-JTAG-CK 0111:R-JTAG-CK 1000:RGMII-CLKIN/RMII-RXER
            /// 1001:Reserved 1110:PE-EINT7 1111:IO Disable
            PE7_SELECT: u4,
        }), base_address + 0xc0);

        /// address: 0x20000c4
        /// PE Configure Register 1
        pub const PE_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE8 Select 0000:Input 0001:Output 0010:NCSI0-D4 0011:UART1-RTS 0100:PWM2
            /// 0101:UART3-TX 0110:Reserved 0111:Reserved 1000:MDC 1001:Reserved 1110:PE-EINT8
            /// 1111:IO Disable
            PE8_SELECT: u4,
            /// PE9 Select 0000:Input 0001:Output 0010:NCSI0-D5 0011:UART1-CTS 0100:PWM3
            /// 0101:UART3-RX 0110:Reserved 0111:Reserved 1000:MDIO 1001:Reserved 1110:PE-EINT9
            /// 1111:IO Disable
            PE9_SELECT: u4,
            /// PE10 Select 0000:Input 0001:Output 0010:NCSI0-D6 0011:UART1-TX 0100:PWM4
            /// 0101:IR-RX 0110:Reserved 0111:Reserved 1000:EPHY-25M 1001:Reserved
            /// 1110:PE-EINT10 1111:IO Disable
            PE10_SELECT: u4,
            /// PE11 Select 0000:Input 0001:Output 0010:NCSI0-D7 0011:UART1-RX 0100:I2S0-DOUT3
            /// 0101:I2S0-DIN3 0110:Reserved 0111:Reserved 1000:RGMII-TXD2 1001:Reserved
            /// 1110:PE-EINT11 1111:IO Disable
            PE11_SELECT: u4,
            /// PE12 Select 0000:Input 0001:Output 0010:TWI2-SCK 0011:NCSI0-FIELD
            /// 0100:I2S0-DOUT2 0101:I2S0-DIN2 0110:Reserved 0111:Reserved 1000:RGMII-TXD3
            /// 1001:Reserved 1110:PE-EINT12 1111:IO Disable
            PE12_SELECT: u4,
            /// PE13 Select 0000:Input 0001:Output 0010:TWI2-SDA 0011:PWM5 0100:I2S0-DOUT0
            /// 0101:I2S0-DIN1 0110:DMIC-DATA3 0111:Reserved 1000:RGMII-RXD2 1001:Reserved
            /// 1110:PE-EINT13 1111:IO Disable
            PE13_SELECT: u4,
            /// PE14 Select 0000:Input 0001:Output 0010:TWI1-SCK 0011:D-JTAG-MS 0100:I2S0-DOUT1
            /// 0101:I2S0-DIN0 0110:DMIC-DATA2 0111:Reserved 1000:RGMII-RXD3 1001:Reserved
            /// 1110:PE-EINT14 1111:IO Disable
            PE14_SELECT: u4,
            /// PE15 Select 0000:Input 0001:Output 0010:TWI1-SDA 0011:D-JTAG-DI 0100:PWM6
            /// 0101:I2S0-LRCK 0110:DMIC-DATA1 0111:Reserved 1000:RGMII-RXCK 1001:Reserved
            /// 1110:PE-EINT15 1111:IO Disable
            PE15_SELECT: u4,
        }), base_address + 0xc4);

        /// address: 0x20000c8
        /// PE_CFG2
        pub const PE_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE16 Select 0000:Input 0001:Output 0010:TWI3-SCK 0011:D-JTAG-DO 0100:PWM7
            /// 0101:I2S0-BCLK 0110:DMIC-DATA0 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PE-EINT16 1111:IO Disable
            PE16_SELECT: u4,
            /// PE17 Select 0000:Input 0001:Output 0010:TWI3-SDA 0011:D-JTAG-CK 0100:IR-TX
            /// 0101:I2S0-MCLK 0110:DMIC-CLK 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PE-EINT17 1111:IO Disable
            PE17_SELECT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc8);

        /// address: 0x20000d0
        /// PE Data Register
        pub const PE_DAT = @intToPtr(*volatile MmioInt(32, u18), base_address + 0xd0);

        /// address: 0x20000d4
        /// PE Multi_Driving Register 0
        pub const PE_DRV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE0 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE0_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PE1 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE1_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PE2 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE2_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PE3 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE3_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PE4 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE4_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PE5 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE5_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PE6 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE6_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PE7 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE7_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xd4);

        /// address: 0x20000d8
        /// PE Multi_Driving Register 1
        pub const PE_DRV1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE8 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE8_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PE9 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE9_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PE10 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE10_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PE11 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE11_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PE12 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE12_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PE13 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE13_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PE14 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE14_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PE15 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE15_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xd8);

        /// address: 0x20000dc
        /// PE_DRV2
        pub const PE_DRV2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE16 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE16_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PE17 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PE17_DRV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xdc);

        /// address: 0x2000280
        /// PE External Interrupt Configure Register 0
        pub const PE_EINT_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT0_CFG: u4,
            /// External INT1 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT1_CFG: u4,
            /// External INT2 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT2_CFG: u4,
            /// External INT3 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT3_CFG: u4,
            /// External INT4 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT4_CFG: u4,
            /// External INT5 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT5_CFG: u4,
            /// External INT6 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT6_CFG: u4,
            /// External INT7 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT7_CFG: u4,
        }), base_address + 0x280);

        /// address: 0x2000284
        /// PE External Interrupt Configure Register 1
        pub const PE_EINT_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT8 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT8_CFG: u4,
            /// External INT9 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT9_CFG: u4,
            /// External INT10 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT10_CFG: u4,
            /// External INT11 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT11_CFG: u4,
            /// External INT12 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT12_CFG: u4,
            /// External INT13 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT13_CFG: u4,
            /// External INT14 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT14_CFG: u4,
            /// External INT15 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT15_CFG: u4,
        }), base_address + 0x284);

        /// address: 0x2000288
        /// PE_EINT_CFG2
        pub const PE_EINT_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT16 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT16_CFG: u4,
            /// External INT17 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT17_CFG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x288);

        /// address: 0x2000290
        /// PE External Interrupt Control Register
        pub const PE_EINT_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Enable
            /// 0: Disable
            /// 1: Enable
            EINT0_CTL: u1,
            /// External INT1 Enable
            /// 0: Disable
            /// 1: Enable
            EINT1_CTL: u1,
            /// External INT2 Enable
            /// 0: Disable
            /// 1: Enable
            EINT2_CTL: u1,
            /// External INT3 Enable
            /// 0: Disable
            /// 1: Enable
            EINT3_CTL: u1,
            /// External INT4 Enable
            /// 0: Disable
            /// 1: Enable
            EINT4_CTL: u1,
            /// External INT5 Enable
            /// 0: Disable
            /// 1: Enable
            EINT5_CTL: u1,
            /// External INT6 Enable
            /// 0: Disable
            /// 1: Enable
            EINT6_CTL: u1,
            /// External INT7 Enable
            /// 0: Disable
            /// 1: Enable
            EINT7_CTL: u1,
            /// External INT8 Enable
            /// 0: Disable
            /// 1: Enable
            EINT8_CTL: u1,
            /// External INT9 Enable
            /// 0: Disable
            /// 1: Enable
            EINT9_CTL: u1,
            /// External INT10 Enable
            /// 0: Disable
            /// 1: Enable
            EINT10_CTL: u1,
            /// External INT11 Enable
            /// 0: Disable
            /// 1: Enable
            EINT11_CTL: u1,
            /// External INT12 Enable
            /// 0: Disable
            /// 1: Enable
            EINT12_CTL: u1,
            /// External INT13 Enable
            /// 0: Disable
            /// 1: Enable
            EINT13_CTL: u1,
            /// External INT14 Enable
            /// 0: Disable
            /// 1: Enable
            EINT14_CTL: u1,
            /// External INT15 Enable
            /// 0: Disable
            /// 1: Enable
            EINT15_CTL: u1,
            /// External INT16 Enable
            /// 0: Disable
            /// 1: Enable
            EINT16_CTL: u1,
            /// External INT17 Enable
            /// 0: Disable
            /// 1: Enable
            EINT17_CTL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x290);

        /// address: 0x2000298
        /// PE External Interrupt Debounce Register
        pub const PE_EINT_DEB = @intToPtr(*volatile Mmio(32, packed struct {
            /// PIO Interrupt Clock Select
            /// 0: LOSC 32KHz
            /// 1: HOSC 24MHz
            PIO_INT_CLK_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debounce Clock Pre_scale n The selected clock source is prescaled by 2^n.
            DEB_CLK_PRE_SCALE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x298);

        /// address: 0x2000294
        /// PE External Interrupt Status Register
        pub const PE_EINT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT0_STATUS: u1,
            /// External INT1 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT1_STATUS: u1,
            /// External INT2 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT2_STATUS: u1,
            /// External INT3 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT3_STATUS: u1,
            /// External INT4 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT4_STATUS: u1,
            /// External INT5 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT5_STATUS: u1,
            /// External INT6 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT6_STATUS: u1,
            /// External INT7 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT7_STATUS: u1,
            /// External INT8 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT8_STATUS: u1,
            /// External INT9 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT9_STATUS: u1,
            /// External INT10 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT10_STATUS: u1,
            /// External INT11 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT11_STATUS: u1,
            /// External INT12 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT12_STATUS: u1,
            /// External INT13 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT13_STATUS: u1,
            /// External INT14 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT14_STATUS: u1,
            /// External INT15 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT15_STATUS: u1,
            /// External INT16 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT16_STATUS: u1,
            /// External INT17 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT17_STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x294);

        /// address: 0x20000e4
        /// PE Pull Register 0
        pub const PE_PULL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE0 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE0_PULL: u2,
            /// PE1 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE1_PULL: u2,
            /// PE2 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE2_PULL: u2,
            /// PE3 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE3_PULL: u2,
            /// PE4 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE4_PULL: u2,
            /// PE5 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE5_PULL: u2,
            /// PE6 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE6_PULL: u2,
            /// PE7 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE7_PULL: u2,
            /// PE8 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE8_PULL: u2,
            /// PE9 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE9_PULL: u2,
            /// PE10 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE10_PULL: u2,
            /// PE11 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE11_PULL: u2,
            /// PE12 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE12_PULL: u2,
            /// PE13 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE13_PULL: u2,
            /// PE14 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE14_PULL: u2,
            /// PE15 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE15_PULL: u2,
        }), base_address + 0xe4);

        /// address: 0x20000e8
        /// PE_PULL1
        pub const PE_PULL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE16 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE16_PULL: u2,
            /// PE17 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PE17_PULL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xe8);

        /// address: 0x20000f0
        /// PF Configure Register 0
        pub const PF_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PF0 Select 0000:Input 0001:Output 0010:SDC0-D1 0011:Reserved 0100:R-JTAG-MS
            /// 0101:I2S2-DOUT1 0110:I2S2-DIN0 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PF-EINT0 1111:IO Disable
            PF0_SELECT: u4,
            /// PF1 Select 0000:Input 0001:Output 0010:SDC0-D0 0011:Reserved 0100:R-JTAG-DI
            /// 0101:I2S2-DOUT0 0110:I2S2-DIN1 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PF-EINT1 1111:IO Disable
            PF1_SELECT: u4,
            /// PF2 Select 0000:Input 0001:Output 0010:SDC0-CLK 0011:UART0-TX 0100:TWI0-SCK
            /// 0101:LEDC-DO 0110:OWA-IN 0111:Reserved 1000:Reserved 1001:Reserved 1110:PF-EINT2
            /// 1111:IO Disable
            PF2_SELECT: u4,
            /// PF3 Select 0000:Input 0001:Output 0010:SDC0-CMD 0011:Reserved 0100:R-JTAG-DO
            /// 0101:I2S2-BCLK 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PF-EINT3 1111:IO Disable
            PF3_SELECT: u4,
            /// PF4 Select 0000:Input 0001:Output 0010:SDC0-D3 0011:UART0-RX 0100:TWI0-SDA
            /// 0101:PWM6 0110:IR-TX 0111:Reserved 1000:Reserved 1001:Reserved 1110:PF-EINT4
            /// 1111:IO Disable
            PF4_SELECT: u4,
            /// PF5 Select 0000:Input 0001:Output 0010:SDC0-D2 0011:Reserved 0100:R-JTAG-CK
            /// 0101:I2S2-LRCK 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PF-EINT5 1111:IO Disable
            PF5_SELECT: u4,
            /// PF6 Select 0000:Input 0001:Output 0010:Reserved 0011:OWA-OUT 0100:IR-RX
            /// 0101:I2S2-MCLK 0110:PWM5 0111:Reserved 1000:Reserved 1001:Reserved 1110:PF-EINT6
            /// 1111:IO Disable
            PF6_SELECT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xf0);

        /// address: 0x2000100
        /// PF Data Register
        pub const PF_DAT = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x100);

        /// address: 0x2000104
        /// PF Multi_Driving Register 0
        pub const PF_DRV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PF0 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF0_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PF1 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF1_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PF2 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF2_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PF3 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF3_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PF4 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF4_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PF5 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF5_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PF6 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PF6_DRV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x104);

        /// address: 0x20002a0
        /// PF External Interrupt Configure Register 0
        pub const PF_EINT_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT0_CFG: u4,
            /// External INT1 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT1_CFG: u4,
            /// External INT2 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT2_CFG: u4,
            /// External INT3 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT3_CFG: u4,
            /// External INT4 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT4_CFG: u4,
            /// External INT5 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT5_CFG: u4,
            /// External INT6 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT6_CFG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x2a0);

        /// address: 0x20002b0
        /// PF External Interrupt Control Register
        pub const PF_EINT_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Enable
            /// 0: Disable
            /// 1: Enable
            EINT0_CTL: u1,
            /// External INT1 Enable
            /// 0: Disable
            /// 1: Enable
            EINT1_CTL: u1,
            /// External INT2 Enable
            /// 0: Disable
            /// 1: Enable
            EINT2_CTL: u1,
            /// External INT3 Enable
            /// 0: Disable
            /// 1: Enable
            EINT3_CTL: u1,
            /// External INT4 Enable
            /// 0: Disable
            /// 1: Enable
            EINT4_CTL: u1,
            /// External INT5 Enable
            /// 0: Disable
            /// 1: Enable
            EINT5_CTL: u1,
            /// External INT6 Enable
            /// 0: Disable
            /// 1: Enable
            EINT6_CTL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2b0);

        /// address: 0x20002b8
        /// PF External Interrupt Debounce Register
        pub const PF_EINT_DEB = @intToPtr(*volatile Mmio(32, packed struct {
            /// PIO Interrupt Clock Select
            /// 0: LOSC 32KHz
            /// 1: HOSC 24MHz
            PIO_INT_CLK_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debounce Clock Pre_scale n The selected clock source is prescaled by 2^n.
            DEB_CLK_PRE_SCALE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2b8);

        /// address: 0x20002b4
        /// PF External Interrupt Status Register
        pub const PF_EINT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT0_STATUS: u1,
            /// External INT1 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT1_STATUS: u1,
            /// External INT2 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT2_STATUS: u1,
            /// External INT3 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT3_STATUS: u1,
            /// External INT4 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT4_STATUS: u1,
            /// External INT5 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT5_STATUS: u1,
            /// External INT6 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT6_STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2b4);

        /// address: 0x2000114
        /// PF Pull Register 0
        pub const PF_PULL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PF0 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF0_PULL: u2,
            /// PF1 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF1_PULL: u2,
            /// PF2 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF2_PULL: u2,
            /// PF3 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF3_PULL: u2,
            /// PF4 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF4_PULL: u2,
            /// PF5 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF5_PULL: u2,
            /// PF6 Pull_up or down Select
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PF6_PULL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x114);

        /// address: 0x2000120
        /// PG Configure Register 0
        pub const PG_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG0 Select 0000:Input 0001:Output 0010:SDC1-CLK 0011:UART3-TX
            /// 0100:RGMII-RXCTRL/RMII-CRS-DV 0101:PWM7 0110:Reserved 0111:Reserved
            /// 1000:Reserved 1001:Reserved 1110:PG-EINT0 1111:IO Disable
            PG0_SELECT: u4,
            /// PG1 Select 0000:Input 0001:Output 0010:SDC1-CMD 0011:UART3-RX
            /// 0100:RGMII-RXD0/RMII-RXD0 0101:PWM6 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PG-EINT1 1111:IO Disable
            PG1_SELECT: u4,
            /// PG2 Select 0000:Input 0001:Output 0010:SDC1-D0 0011:UART3-RTS
            /// 0100:RGMII-RXD1/RMII-RXD1 0101:UART4-TX 0110:Reserved 0111:Reserved
            /// 1000:Reserved 1001:Reserved 1110:PG-EINT2 1111:IO Disable
            PG2_SELECT: u4,
            /// PG3 Select 0000:Input 0001:Output 0010:SDC1-D1 0011:UART3-CTS
            /// 0100:RGMII-TXCK/RMII-TXCK 0101:UART4-RX 0110:Reserved 0111:Reserved
            /// 1000:Reserved 1001:Reserved 1110:PG-EINT3 1111:IO Disable
            PG3_SELECT: u4,
            /// PG4 Select 0000:Input 0001:Output 0010:SDC1-D2 0011:UART5-TX
            /// 0100:RGMII-TXD0/RMII-TXD0 0101:PWM5 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PG-EINT4 1111:IO Disable
            PG4_SELECT: u4,
            /// PG5 Select 0000:Input 0001:Output 0010:SDC1-D3 0011:UART5-RX
            /// 0100:RGMII-TXD1/RMII-TXD1 0101:PWM4 0110:Reserved 0111:Reserved 1000:Reserved
            /// 1001:Reserved 1110:PG-EINT5 1111:IO Disable
            PG5_SELECT: u4,
            /// PG6 Select 0000:Input 0001:Output 0010:UART1-TX 0011:TWI2-SCK 0100:RGMII-TXD2
            /// 0101:PWM1 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved 1110:PG-EINT6
            /// 1111:IO Disable
            PG6_SELECT: u4,
            /// PG7 Select 0000:Input 0001:Output 0010:UART1-RX 0011:TWI2-SDA 0100:RGMII-TXD3
            /// 0101:OWA-IN 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT7 1111:IO Disable
            PG7_SELECT: u4,
        }), base_address + 0x120);

        /// address: 0x2000124
        /// PG Configure Register 1
        pub const PG_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG8 Select 0000:Input 0001:Output 0010:UART1-RTS 0011:TWI1-SCK 0100:RGMII-RXD2
            /// 0101:UART3-TX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT8 1111:IO Disable
            PG8_SELECT: u4,
            /// PG9 Select. 0000:Input 0001:Output 0010:UART1-CTS 0011:TWI1-SDA 0100:RGMII-RXD3
            /// 0101:UART3-RX 0110:Reserved 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT9 1111:IO Disable
            PG9_SELECT: u4,
            /// PG10 Select 0000:Input 0001:Output 0010:PWM3 0011:TWI3-SCK 0100:RGMII-RXCK
            /// 0101:CLK-FANOUT0 0110:IR-RX 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT10 1111:IO Disable
            PG10_SELECT: u4,
            /// PG11 Select 0000:Input 0001:Output 0010:I2S1-MCLK 0011:TWI3-SDA 0100:EPHY-25M
            /// 0101:CLK-FANOUT1 0110:TCON-TRIG 0111:Reserved 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT11 1111:IO Disable
            PG11_SELECT: u4,
            /// PG12 Select 0000:Input 0001:Output 0010:I2S1-LRCK 0011:TWI0-SCK
            /// 0100:RGMII-TXCTRL/RMII-TXEN 0101:CLK-FANOUT2 0110:PWM0 0111:UART1-TX
            /// 1000:Reserved 1001:Reserved 1110:PG-EINT12 1111:IO Disable
            PG12_SELECT: u4,
            /// PG13 Select 0000:Input 0001:Output 0010:I2S1-BCLK 0011:TWI0-SDA
            /// 0100:RGMII-CLKIN/RMII-RXER 0101:PWM2 0110:LEDC-DO 0111:UART1-RX 1000:Reserved
            /// 1001:Reserved 1110:PG-EINT13 1111:IO Disable
            PG13_SELECT: u4,
            /// PG14 Select 0000:Input 0001:Output 0010:I2S1-DIN0 0011:TWI2-SCK 0100:MDC
            /// 0101:I2S1-DOUT1 0110:SPI0-WP 0111:UART1-RTS 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT14 1111:IO Disable
            PG14_SELECT: u4,
            /// PG15 Select 0000:Input 0001:Output 0010:I2S1-DOUT0 0011:TWI2-SDA 0100:MDIO
            /// 0101:I2S1-DIN1 0110:SPI0-HOLD 0111:UART1-CTS 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT15 1111:IO Disable
            PG15_SELECT: u4,
        }), base_address + 0x124);

        /// address: 0x2000128
        /// PG_CFG2
        pub const PG_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG16 Select 0000:Input 0001:Output 0010:IR-RX 0011:TCON-TRIG 0100:PWM5
            /// 0101:CLK-FANOUT2 0110:OWA-IN 0111:LEDC-DO 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT16 1111:IO Disable
            PG16_SELECT: u4,
            /// PG17 Select 0000:Input 0001:Output 0010:UART2-TX 0011:TWI3-SCK 0100:PWM7
            /// 0101:CLK-FANOUT0 0110:IR-TX 0111:UART0-TX 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT17 1111:IO Disable
            PG17_SELECT: u4,
            /// PG18 Select 0000:Input 0001:Output 0010:UART2-RX 0011:TWI3-SDA 0100:PWM6
            /// 0101:CLK-FANOUT1 0110:OWA-OUT 0111:UART0-RX 1000:Reserved 1001:Reserved
            /// 1110:PG-EINT18 1111:IO Disable
            PG18_SELECT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x128);

        /// address: 0x2000130
        /// PG Data Register
        pub const PG_DAT = @intToPtr(*volatile MmioInt(32, u19), base_address + 0x130);

        /// address: 0x2000134
        /// PG Multi_Driving Register 0
        pub const PG_DRV0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG0 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG0_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PG1 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG1_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PG2 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG2_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PG3 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG3_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PG4 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG4_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PG5 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG5_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PG6 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG6_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PG7 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG7_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x134);

        /// address: 0x2000138
        /// PG Multi_Driving Register 1
        pub const PG_DRV1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG8 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG8_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PG9 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG9_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PG10 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG10_DRV: u2,
            reserved4: u1,
            reserved5: u1,
            /// PG11 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG11_DRV: u2,
            reserved6: u1,
            reserved7: u1,
            /// PG12 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG12_DRV: u2,
            reserved8: u1,
            reserved9: u1,
            /// PG13 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG13_DRV: u2,
            reserved10: u1,
            reserved11: u1,
            /// PG14 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG14_DRV: u2,
            reserved12: u1,
            reserved13: u1,
            /// PG15 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG15_DRV: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x138);

        /// address: 0x200013c
        /// PG_DRV2
        pub const PG_DRV2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG16 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG16_DRV: u2,
            reserved0: u1,
            reserved1: u1,
            /// PG17 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG17_DRV: u2,
            reserved2: u1,
            reserved3: u1,
            /// PG18 Multi_Driving Select
            /// 00: Level 0
            /// 01: Level 1
            /// 10: Level 2
            /// 11: Level 3
            PG18_DRV: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x13c);

        /// address: 0x20002c0
        /// PG External Interrupt Configure Register 0
        pub const PG_EINT_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT0_CFG: u4,
            /// External INT1 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT1_CFG: u4,
            /// External INT2 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT2_CFG: u4,
            /// External INT3 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT3_CFG: u4,
            /// External INT4 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT4_CFG: u4,
            /// External INT5 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT5_CFG: u4,
            /// External INT6 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT6_CFG: u4,
            /// External INT7 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT7_CFG: u4,
        }), base_address + 0x2c0);

        /// address: 0x20002c4
        /// PG External Interrupt Configure Register 1
        pub const PG_EINT_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT8 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT8_CFG: u4,
            /// External INT9 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT9_CFG: u4,
            /// External INT10 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT10_CFG: u4,
            /// External INT11 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT11_CFG: u4,
            /// External INT12 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT12_CFG: u4,
            /// External INT13 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT13_CFG: u4,
            /// External INT14 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT14_CFG: u4,
            /// External INT15 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT15_CFG: u4,
        }), base_address + 0x2c4);

        /// address: 0x20002c8
        /// PG_EINT_CFG2
        pub const PG_EINT_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT16 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT16_CFG: u4,
            /// External INT17 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT17_CFG: u4,
            /// External INT18 Mode
            /// 0x0: Positive Edge
            /// 0x1: Negative Edge
            /// 0x2: High Level
            /// 0x3: Low Level
            /// 0x4: Double Edge (Positive/Negative) Others: Reserved
            EINT18_CFG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c8);

        /// address: 0x20002d0
        /// PG External Interrupt Control Register
        pub const PG_EINT_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Enable
            /// 0: Disable
            /// 1: Enable
            EINT0_CTL: u1,
            /// External INT1 Enable
            /// 0: Disable
            /// 1: Enable
            EINT1_CTL: u1,
            /// External INT2 Enable
            /// 0: Disable
            /// 1: Enable
            EINT2_CTL: u1,
            /// External INT3 Enable
            /// 0: Disable
            /// 1: Enable
            EINT3_CTL: u1,
            /// External INT4 Enable
            /// 0: Disable
            /// 1: Enable
            EINT4_CTL: u1,
            /// External INT5 Enable
            /// 0: Disable
            /// 1: Enable
            EINT5_CTL: u1,
            /// External INT6 Enable
            /// 0: Disable
            /// 1: Enable
            EINT6_CTL: u1,
            /// External INT7 Enable
            /// 0: Disable
            /// 1: Enable
            EINT7_CTL: u1,
            /// External INT8 Enable
            /// 0: Disable
            /// 1: Enable
            EINT8_CTL: u1,
            /// External INT9 Enable
            /// 0: Disable
            /// 1: Enable
            EINT9_CTL: u1,
            /// External INT10 Enable
            /// 0: Disable
            /// 1: Enable
            EINT10_CTL: u1,
            /// External INT11 Enable
            /// 0: Disable
            /// 1: Enable
            EINT11_CTL: u1,
            /// External INT12 Enable
            /// 0: Disable
            /// 1: Enable
            EINT12_CTL: u1,
            /// External INT13 Enable
            /// 0: Disable
            /// 1: Enable
            EINT13_CTL: u1,
            /// External INT14 Enable
            /// 0: Disable
            /// 1: Enable
            EINT14_CTL: u1,
            /// External INT15 Enable
            /// 0: Disable
            /// 1: Enable
            EINT15_CTL: u1,
            /// External INT16 Enable
            /// 0: Disable
            /// 1: Enable
            EINT16_CTL: u1,
            /// External INT17 Enable
            /// 0: Disable
            /// 1: Enable
            EINT17_CTL: u1,
            /// External INT18 Enable
            /// 0: Disable
            /// 1: Enable
            EINT18_CTL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2d0);

        /// address: 0x20002d8
        /// PG External Interrupt Debounce Register
        pub const PG_EINT_DEB = @intToPtr(*volatile Mmio(32, packed struct {
            /// PIO Interrupt Clock Select
            /// 0: LOSC 32KHz
            /// 1: HOSC 24MHz
            PIO_INT_CLK_SELECT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debounce Clock Pre_scale n The selected clock source is prescaled by 2^n.
            DEB_CLK_PRE_SCALE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2d8);

        /// address: 0x20002d4
        /// PG External Interrupt Status Register
        pub const PG_EINT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// External INT0 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT0_STATUS: u1,
            /// External INT1 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT1_STATUS: u1,
            /// External INT2 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT2_STATUS: u1,
            /// External INT3 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT3_STATUS: u1,
            /// External INT4 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT4_STATUS: u1,
            /// External INT5 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT5_STATUS: u1,
            /// External INT6 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT6_STATUS: u1,
            /// External INT7 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT7_STATUS: u1,
            /// External INT8 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT8_STATUS: u1,
            /// External INT9 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT9_STATUS: u1,
            /// External INT10 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT10_STATUS: u1,
            /// External INT11 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT11_STATUS: u1,
            /// External INT12 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT12_STATUS: u1,
            /// External INT13 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT13_STATUS: u1,
            /// External INT14 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT14_STATUS: u1,
            /// External INT15 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT15_STATUS: u1,
            /// External INT16 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT16_STATUS: u1,
            /// External INT17 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT17_STATUS: u1,
            /// External INT18 Pending Bit
            /// 0: No IRQ pending
            /// 1: IRQ pending Write ‘1’ to clear
            EINT18_STATUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2d4);

        /// address: 0x2000144
        /// PG Pull Register 0
        pub const PG_PULL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG0 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG0_PULL: u2,
            /// PG1 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG1_PULL: u2,
            /// PG2 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG2_PULL: u2,
            /// PG3 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG3_PULL: u2,
            /// PG4 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG4_PULL: u2,
            /// PG5 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG5_PULL: u2,
            /// PG6 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG6_PULL: u2,
            /// PG7 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG7_PULL: u2,
            /// PG8 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG8_PULL: u2,
            /// PG9 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG9_PULL: u2,
            /// PG10 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG10_PULL: u2,
            /// PG11 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG11_PULL: u2,
            /// PG12 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG12_PULL: u2,
            /// PG13 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG13_PULL: u2,
            /// PG14 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG14_PULL: u2,
            /// PG15 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG15_PULL: u2,
        }), base_address + 0x144);

        /// address: 0x2000148
        /// PG_PULL1
        pub const PG_PULL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PG16 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG16_PULL: u2,
            /// PG17 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG17_PULL: u2,
            /// PG18 Pull_up or down Select.
            /// 00: Pull_up/down disable
            /// 01: Pull_up
            /// 10: Pull_down
            /// 11: Reserved
            PG18_PULL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x148);

        /// address: 0x2000340
        /// PIO Group Withstand Voltage Mode Select Register
        pub const PIO_POW_MOD_SEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// PC_POWER MODE Select
            /// 0: 3.3 V
            /// 1: 1.8 V If PC_Port Power Source selects VCC_IO, this bit is invalid.
            PC_PWR_MOD_SEL: u1,
            /// PD_POWER MODE Select
            /// 0: 3.3 V
            /// 1: 1.8 V If PD_Port Power Source selects VCC_IO, this bit is invalid.
            PD_PWR_MOD_SEL: u1,
            /// PE_POWER MODE Select
            /// 0: 3.3 V
            /// 1: 1.8 V If PE_Port Power Source selects VCC_IO, this bit is invalid.
            PE_PWR_MOD_SEL: u1,
            /// PF_POWER MODE Select
            /// 0: 3.3 V
            /// 1: 1.8 V If PF_Port Power Source selects VCC_IO, this bit is invalid.
            PF_PWR_MOD_SEL: u1,
            /// PG_POWER MODE Select
            /// 0: 3.3 V
            /// 1: 1.8 V If PG_Port Power Source selects VCC_IO, this bit is invalid.
            PG_PWR_MOD_SEL: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// VCC_IO POWER MODE Select
            /// 0: 3.3 V
            /// 1: 1.8 V
            VCCIO_PWR_MOD_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x340);

        /// address: 0x2000344
        /// PIO Group Withstand Voltage Mode Select Control Register
        pub const PIO_POW_MS_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// VCC_PC Withstand Voltage Mode Select Control
            /// 0: Enable
            /// 1: Disable
            VCC_PC_WS_VOL_MOD_SEL: u1,
            /// VCC_PD Withstand Voltage Mode Select Control
            /// 0: Enable
            /// 1: Disable
            VCC_PD_WS_VOL_MOD_SEL: u1,
            /// VCC_PE Withstand Voltage Mode Select Control
            /// 0: Enable
            /// 1: Disable
            VCC_PE_WS_VOL_MOD_SEL: u1,
            /// VCC_PF Withstand Voltage Mode Select Control
            /// 0: Enable
            /// 1: Disable
            VCC_PF_WS_VOL_MOD_SEL: u1,
            /// VCC_PG Withstand Voltage Mode Select Control
            /// 0: Enable
            /// 1: Disable
            VCC_PG_WS_VOL_MOD_SEL: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// VCC_IO Withstand Voltage Mode Select Control
            /// 0: Enable
            /// 1: Disable
            VCCIO_WS_VOL_MOD_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x344);

        /// address: 0x2000348
        /// PIO Group Power Value Register
        pub const PIO_POW_VAL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// PC_Port Power Value If PC_Port power source selects VCC_IO, this bit is invalid.
            PC_PWR_VAL: u1,
            /// PD_Port Power Value If PD_Port power source selects VCC_IO, this bit is invalid.
            PD_PWR_VAL: u1,
            /// PE_Port Power Value If PE_Port power source selects VCC_IO, this bit is invalid.
            PE_PWR_VAL: u1,
            /// PF_Port Power Value If PF_Port power source selects VCC_IO, this bit is invalid.
            PF_PWR_VAL: u1,
            /// PG_Port Power Value If PG_Port power source selects VCC_IO, this bit is invalid.
            PG_PWR_VAL: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// VCC_IO Power Value
            VCCIO_PWR_VAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x348);

        /// address: 0x2000350
        /// PIO Group Power Voltage Select Control Register
        pub const PIO_POW_VOL_SEL_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Power Voltage Select Control
            /// 0: 1.8 V
            /// 1: 3.3 V
            @"VCC-PF": u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x350);
    };

    /// RISCV PLIC
    pub const @"RISCV PLIC" = struct {
        pub const base_address = 0x10000000;

        /// address: 0x101ffffc
        /// PLIC Control Register
        pub const PLIC_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Control
            /// 0: Only the machine mode can access to all registers in PLIC. The super-user
            /// mode can not access PLIC_CTRL, PLIC_PRIO, PLIC_IP, and PLIC_IE registers, only
            /// access the interrupt threshold register and the interrupt response/completion
            /// register. The normal-user mode can not access any registers in PLIC.
            /// 1: The machine mode can access to all registers in PLIC. The super- user mode
            /// can access all registers except PLL_CTRL in PLIC. The normal-user mode can not
            /// access any registers in PLIC.
            PLIC_CTRL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1ffffc);

        /// address: 0x10200004
        /// PLIC Machine Claim Register
        pub const PLIC_MCLAIM_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Machine Claim Read register: Return the current stored ID value of the
            /// register. The read operation indicates that the interrupt of the corresponding
            /// ID starts to perform. The PLIC starts to process the interrupt response. Write
            /// register: Indicate that the interrupt of the corresponding ID is complete. The
            /// writing operation can not update the response/completion register. The PLIC
            /// starts to process the interrupt completion.
            PLIC_MCLAIM: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x200004);

        /// address: 0x10200000
        /// PLIC Machine Threshold Register
        pub const PLIC_MTH_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Machine Threshold Indicate the interrupt threshold of the current interrupt
            /// mode. If the threshold is configured to 0, it indicates that all interrupts are
            /// permitted.
            PLIC_MTH: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x200000);

        /// address: 0x10000004
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x4);

        /// address: 0x10000008
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);

        /// address: 0x1000000c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc);

        /// address: 0x10000010
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x10000014
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x10000018
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x1000001c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1c);

        /// address: 0x10000020
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20);

        /// address: 0x10000024
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x24);

        /// address: 0x10000028
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x28);

        /// address: 0x1000002c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2c);

        /// address: 0x10000030
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x30);

        /// address: 0x10000034
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x34);

        /// address: 0x10000038
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x38);

        /// address: 0x1000003c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3c);

        /// address: 0x10000040
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x40);

        /// address: 0x10000044
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x44);

        /// address: 0x10000048
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x48);

        /// address: 0x1000004c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x4c);

        /// address: 0x10000050
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x10000054
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x54);

        /// address: 0x10000058
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x58);

        /// address: 0x1000005c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x5c);

        /// address: 0x10000060
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x60);

        /// address: 0x10000064
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x64);

        /// address: 0x10000068
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x68);

        /// address: 0x1000006c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x6c);

        /// address: 0x10000070
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x70);

        /// address: 0x10000074
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x74);

        /// address: 0x10000078
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x78);

        /// address: 0x1000007c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x7c);

        /// address: 0x10000080
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_32 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x80);

        /// address: 0x10000084
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_33 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x84);

        /// address: 0x10000088
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_34 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x88);

        /// address: 0x1000008c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_35 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8c);

        /// address: 0x10000090
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_36 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x90);

        /// address: 0x10000094
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_37 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x94);

        /// address: 0x10000098
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_38 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x98);

        /// address: 0x1000009c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_39 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x9c);

        /// address: 0x100000a0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_40 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa0);

        /// address: 0x100000a4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_41 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa4);

        /// address: 0x100000a8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_42 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa8);

        /// address: 0x100000ac
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_43 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xac);

        /// address: 0x100000b0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_44 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xb0);

        /// address: 0x100000b4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_45 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xb4);

        /// address: 0x100000b8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_46 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xb8);

        /// address: 0x100000bc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_47 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xbc);

        /// address: 0x100000c0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_48 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc0);

        /// address: 0x100000c4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_49 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc4);

        /// address: 0x100000c8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_50 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc8);

        /// address: 0x100000cc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_51 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xcc);

        /// address: 0x100000d0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_52 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd0);

        /// address: 0x100000d4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_53 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd4);

        /// address: 0x100000d8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_54 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd8);

        /// address: 0x100000dc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_55 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xdc);

        /// address: 0x100000e0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_56 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xe0);

        /// address: 0x100000e4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_57 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xe4);

        /// address: 0x100000e8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_58 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xe8);

        /// address: 0x100000ec
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_59 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xec);

        /// address: 0x100000f0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_60 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf0);

        /// address: 0x100000f4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_61 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf4);

        /// address: 0x100000f8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_62 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf8);

        /// address: 0x100000fc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_63 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xfc);

        /// address: 0x10000100
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_64 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x100);

        /// address: 0x10000104
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_65 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x10000108
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_66 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x108);

        /// address: 0x1000010c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_67 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10c);

        /// address: 0x10000110
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_68 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x110);

        /// address: 0x10000114
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_69 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x114);

        /// address: 0x10000118
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_70 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x118);

        /// address: 0x1000011c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_71 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x11c);

        /// address: 0x10000120
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_72 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x120);

        /// address: 0x10000124
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_73 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x124);

        /// address: 0x10000128
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_74 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x128);

        /// address: 0x1000012c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_75 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x12c);

        /// address: 0x10000130
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_76 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x130);

        /// address: 0x10000134
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_77 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x134);

        /// address: 0x10000138
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_78 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x138);

        /// address: 0x1000013c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_79 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x13c);

        /// address: 0x10000140
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_80 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x140);

        /// address: 0x10000144
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_81 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x144);

        /// address: 0x10000148
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_82 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x148);

        /// address: 0x1000014c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_83 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14c);

        /// address: 0x10000150
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_84 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x150);

        /// address: 0x10000154
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_85 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x154);

        /// address: 0x10000158
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_86 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x158);

        /// address: 0x1000015c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_87 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x15c);

        /// address: 0x10000160
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_88 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x160);

        /// address: 0x10000164
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_89 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x164);

        /// address: 0x10000168
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_90 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x168);

        /// address: 0x1000016c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_91 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x16c);

        /// address: 0x10000170
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_92 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x170);

        /// address: 0x10000174
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_93 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x174);

        /// address: 0x10000178
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_94 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x178);

        /// address: 0x1000017c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_95 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x17c);

        /// address: 0x10000180
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_96 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x180);

        /// address: 0x10000184
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_97 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x184);

        /// address: 0x10000188
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_98 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x188);

        /// address: 0x1000018c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_99 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18c);

        /// address: 0x10000190
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_100 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x190);

        /// address: 0x10000194
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_101 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x194);

        /// address: 0x10000198
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_102 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x198);

        /// address: 0x1000019c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_103 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x19c);

        /// address: 0x100001a0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_104 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1a0);

        /// address: 0x100001a4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_105 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1a4);

        /// address: 0x100001a8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_106 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1a8);

        /// address: 0x100001ac
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_107 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1ac);

        /// address: 0x100001b0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_108 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1b0);

        /// address: 0x100001b4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_109 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1b4);

        /// address: 0x100001b8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_110 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1b8);

        /// address: 0x100001bc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_111 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1bc);

        /// address: 0x100001c0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_112 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1c0);

        /// address: 0x100001c4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_113 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1c4);

        /// address: 0x100001c8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_114 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1c8);

        /// address: 0x100001cc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_115 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1cc);

        /// address: 0x100001d0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_116 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1d0);

        /// address: 0x100001d4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_117 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1d4);

        /// address: 0x100001d8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_118 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1d8);

        /// address: 0x100001dc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_119 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1dc);

        /// address: 0x100001e0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_120 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1e0);

        /// address: 0x100001e4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_121 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1e4);

        /// address: 0x100001e8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_122 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1e8);

        /// address: 0x100001ec
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_123 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1ec);

        /// address: 0x100001f0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_124 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1f0);

        /// address: 0x100001f4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_125 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1f4);

        /// address: 0x100001f8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_126 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1f8);

        /// address: 0x100001fc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_127 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x1fc);

        /// address: 0x10000200
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_128 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x200);

        /// address: 0x10000204
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_129 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x204);

        /// address: 0x10000208
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_130 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x208);

        /// address: 0x1000020c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_131 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20c);

        /// address: 0x10000210
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_132 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x210);

        /// address: 0x10000214
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_133 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x214);

        /// address: 0x10000218
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_134 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x218);

        /// address: 0x1000021c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_135 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x21c);

        /// address: 0x10000220
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_136 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x220);

        /// address: 0x10000224
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_137 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x224);

        /// address: 0x10000228
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_138 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x228);

        /// address: 0x1000022c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_139 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x22c);

        /// address: 0x10000230
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_140 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x230);

        /// address: 0x10000234
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_141 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x234);

        /// address: 0x10000238
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_142 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x238);

        /// address: 0x1000023c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_143 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x23c);

        /// address: 0x10000240
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_144 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x240);

        /// address: 0x10000244
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_145 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x244);

        /// address: 0x10000248
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_146 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x248);

        /// address: 0x1000024c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_147 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x24c);

        /// address: 0x10000250
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_148 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x250);

        /// address: 0x10000254
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_149 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x254);

        /// address: 0x10000258
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_150 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x258);

        /// address: 0x1000025c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_151 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x25c);

        /// address: 0x10000260
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_152 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x260);

        /// address: 0x10000264
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_153 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x264);

        /// address: 0x10000268
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_154 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x268);

        /// address: 0x1000026c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_155 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x26c);

        /// address: 0x10000270
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_156 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x270);

        /// address: 0x10000274
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_157 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x274);

        /// address: 0x10000278
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_158 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x278);

        /// address: 0x1000027c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_159 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x27c);

        /// address: 0x10000280
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_160 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x280);

        /// address: 0x10000284
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_161 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x284);

        /// address: 0x10000288
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_162 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x288);

        /// address: 0x1000028c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_163 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x28c);

        /// address: 0x10000290
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_164 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x290);

        /// address: 0x10000294
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_165 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x294);

        /// address: 0x10000298
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_166 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x298);

        /// address: 0x1000029c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_167 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x29c);

        /// address: 0x100002a0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_168 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2a0);

        /// address: 0x100002a4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_169 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2a4);

        /// address: 0x100002a8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_170 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2a8);

        /// address: 0x100002ac
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_171 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2ac);

        /// address: 0x100002b0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_172 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2b0);

        /// address: 0x100002b4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_173 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2b4);

        /// address: 0x100002b8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_174 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2b8);

        /// address: 0x100002bc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_175 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2bc);

        /// address: 0x100002c0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_176 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2c0);

        /// address: 0x100002c4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_177 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2c4);

        /// address: 0x100002c8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_178 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2c8);

        /// address: 0x100002cc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_179 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2cc);

        /// address: 0x100002d0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_180 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2d0);

        /// address: 0x100002d4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_181 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2d4);

        /// address: 0x100002d8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_182 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2d8);

        /// address: 0x100002dc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_183 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2dc);

        /// address: 0x100002e0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_184 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2e0);

        /// address: 0x100002e4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_185 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2e4);

        /// address: 0x100002e8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_186 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2e8);

        /// address: 0x100002ec
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_187 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2ec);

        /// address: 0x100002f0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_188 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2f0);

        /// address: 0x100002f4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_189 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2f4);

        /// address: 0x100002f8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_190 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2f8);

        /// address: 0x100002fc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_191 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2fc);

        /// address: 0x10000300
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_192 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x300);

        /// address: 0x10000304
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_193 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x304);

        /// address: 0x10000308
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_194 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x308);

        /// address: 0x1000030c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_195 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x30c);

        /// address: 0x10000310
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_196 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x310);

        /// address: 0x10000314
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_197 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x314);

        /// address: 0x10000318
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_198 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x318);

        /// address: 0x1000031c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_199 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x31c);

        /// address: 0x10000320
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_200 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x320);

        /// address: 0x10000324
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_201 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x324);

        /// address: 0x10000328
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_202 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x328);

        /// address: 0x1000032c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_203 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x32c);

        /// address: 0x10000330
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_204 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x330);

        /// address: 0x10000334
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_205 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x334);

        /// address: 0x10000338
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_206 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x338);

        /// address: 0x1000033c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_207 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x33c);

        /// address: 0x10000340
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_208 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x340);

        /// address: 0x10000344
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_209 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x344);

        /// address: 0x10000348
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_210 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x348);

        /// address: 0x1000034c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_211 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x34c);

        /// address: 0x10000350
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_212 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x350);

        /// address: 0x10000354
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_213 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x354);

        /// address: 0x10000358
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_214 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x358);

        /// address: 0x1000035c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_215 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x35c);

        /// address: 0x10000360
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_216 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x360);

        /// address: 0x10000364
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_217 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x364);

        /// address: 0x10000368
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_218 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x368);

        /// address: 0x1000036c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_219 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x36c);

        /// address: 0x10000370
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_220 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x370);

        /// address: 0x10000374
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_221 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x374);

        /// address: 0x10000378
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_222 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x378);

        /// address: 0x1000037c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_223 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x37c);

        /// address: 0x10000380
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_224 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x380);

        /// address: 0x10000384
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_225 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x384);

        /// address: 0x10000388
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_226 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x388);

        /// address: 0x1000038c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_227 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x38c);

        /// address: 0x10000390
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_228 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x390);

        /// address: 0x10000394
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_229 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x394);

        /// address: 0x10000398
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_230 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x398);

        /// address: 0x1000039c
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_231 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x39c);

        /// address: 0x100003a0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_232 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3a0);

        /// address: 0x100003a4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_233 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3a4);

        /// address: 0x100003a8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_234 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3a8);

        /// address: 0x100003ac
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_235 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3ac);

        /// address: 0x100003b0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_236 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3b0);

        /// address: 0x100003b4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_237 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3b4);

        /// address: 0x100003b8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_238 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3b8);

        /// address: 0x100003bc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_239 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3bc);

        /// address: 0x100003c0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_240 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3c0);

        /// address: 0x100003c4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_241 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3c4);

        /// address: 0x100003c8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_242 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3c8);

        /// address: 0x100003cc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_243 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3cc);

        /// address: 0x100003d0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_244 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3d0);

        /// address: 0x100003d4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_245 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3d4);

        /// address: 0x100003d8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_246 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3d8);

        /// address: 0x100003dc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_247 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3dc);

        /// address: 0x100003e0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_248 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3e0);

        /// address: 0x100003e4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_249 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3e4);

        /// address: 0x100003e8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_250 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3e8);

        /// address: 0x100003ec
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_251 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3ec);

        /// address: 0x100003f0
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_252 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3f0);

        /// address: 0x100003f4
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_253 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3f4);

        /// address: 0x100003f8
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_254 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3f8);

        /// address: 0x100003fc
        /// PLIC_PRIO_REGn_%s
        pub const PLIC_PRIO_REGn_255 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Priority Support for 32 different levels of priority. Where, a priority
            /// sets to 0 indicates that the interrupt is invalid. Machine mode interrupts have
            /// unconditionally higher priority than super-user mode interrupts. When the
            /// interrupt target mode is the same, priority 1 is the lowest priority, priority
            /// 31 is the highest priority. When multiple interrupts of the same priority are
            /// waiting arbitration, the interrupt source ID is compared. The smaller ID has the
            /// higher priority.
            PLIC_PRIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x3fc);

        /// address: 0x10201004
        /// PLIC Superuser Claim Register
        pub const PLIC_SCLAIM_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Superuser Claim. Read register: Return the current stored ID value of the
            /// register. The read operation indicates that the interrupt of the corresponding
            /// ID starts to perform. The PLIC starts to process the interrupt response. Write
            /// register: Indicate that the interrupt of the corresponding ID is complete. The
            /// writing operation can not update the response/completion register. The PLIC
            /// starts to process the interrupt completion.
            PLIC_SCLAIM: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x201004);

        /// address: 0x10201000
        /// PLIC Superuser Threshold Register
        pub const PLIC_STH_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLIC Superuser Threshold. Indicate the interrupt threshold of the current
            /// interrupt mode. If the threshold is configured to 0, it indicates that all
            /// interrupts are permitted.
            PLIC_STH: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x201000);
    };

    /// Spinlock
    pub const Spinlock = struct {
        pub const base_address = 0x3005000;

        /// address: 0x3005100
        /// SPINLOCKN_LOCK_REG[%s]
        pub const SPINLOCKN_LOCK_REG = @intToPtr(*volatile [32]Mmio(32, packed struct {
            /// Lock State Read 0x0: The lock was previously Not Taken (free). The requester is
            /// granted the lock. Write 0x0: Set the lock to Not Taken (free). Read 0x1: The
            /// lock was previously Taken. The requester is not granted the lock and must retry.
            /// Write 0x1: No update to the lock value.
            TAKEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x100);

        /// address: 0x3005020
        /// Spinlock Interrupt Enable Register
        pub const SPINLOCK_IRQ_EN_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// SpinLock[i] interrupt enable
            /// 0: Disable
            /// 1: Enable
            LOCK_IRQ_EN: u32,
        }), base_address + 0x20);

        /// address: 0x3005040
        /// Spinlock Interrupt Status Register
        pub const SPINLOCK_IRQ_STA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// SpinLock[i] interrupt status
            /// 0: No effect
            /// 1: Pending Writing 1 clears this bit.
            LOCK_IRQ_STATUS: u32,
        }), base_address + 0x40);

        /// address: 0x3005080
        /// SPINLOCK_LOCKIN0_REG
        pub const SPINLOCK_LOCKIN0_REG = @intToPtr(*volatile u32, base_address + 0x80);

        /// address: 0x3005084
        /// SPINLOCK_LOCKIN1_REG
        pub const SPINLOCK_LOCKIN1_REG = @intToPtr(*volatile u32, base_address + 0x84);

        /// address: 0x3005088
        /// SPINLOCK_LOCKIN2_REG
        pub const SPINLOCK_LOCKIN2_REG = @intToPtr(*volatile u32, base_address + 0x88);

        /// address: 0x300508c
        /// SPINLOCK_LOCKIN3_REG
        pub const SPINLOCK_LOCKIN3_REG = @intToPtr(*volatile u32, base_address + 0x8c);

        /// address: 0x3005090
        /// SPINLOCK_LOCKIN4_REG
        pub const SPINLOCK_LOCKIN4_REG = @intToPtr(*volatile u32, base_address + 0x90);

        /// address: 0x3005010
        /// Spinlock Status Register
        pub const SPINLOCK_STATUS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// SpinLock[i] status
            /// 0: The Spinlock is free
            /// 1: The Spinlock is taken
            LOCK_REG_STATUS: u32,
        }), base_address + 0x10);

        /// address: 0x3005000
        /// Spinlock System Status Register
        pub const SPINLOCK_SYSTATUS_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// In-Use flag0, covering lock register0-31
            /// 0: All lock registers 0-31 are in the NotTaken state.
            /// 1: At least one of the lock register 0-31 is in the Taken state.
            IU0: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            /// Number of lock registers implemented
            /// 00: This instance has 256 lock registers
            /// 01: This instance has 32 lock registers
            /// 10: This instance has 64 lock registers
            /// 11: This instance has 128 lock registers
            LOCKS_NUM: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);
    };

    /// THS
    pub const THS = struct {
        pub const base_address = 0x2009400;

        /// address: 0x2009428
        /// THS_ALARM0_INTS
        pub const THS_ALARM0_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm interrupt off pending for sensor Write 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            ALARM_OFF_STS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x28);

        /// address: 0x2009440
        /// THS Alarm Threshold Control Register
        pub const THS_ALARM_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Thermal sensor alarm threshold for hysteresis temperature
            ALARM_T_HYST: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Thermal sensor alarm threshold for hot temperature
            ALARM_T_HOT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x40);

        /// address: 0x2009418
        /// THS Alarm Interrupt Control Register
        pub const THS_ALARM_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the alarm interrupt for the sensor
            /// 0: Disabled
            /// 1: Enabled
            ALARM_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x200942c
        /// THS Alarm Interrupt Status Register
        pub const THS_ALARM_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm interrupt pending for sensor Write 1 to clear the pending status.
            /// 0: No effect
            /// 1: Pending
            ALARM_INT_STS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x2c);

        /// address: 0x20094a0
        /// THS Calibration Data
        pub const THS_CDATA = @intToPtr(*volatile MmioInt(32, u12), base_address + 0xa0);

        /// address: 0x2009400
        /// THS Control Register
        pub const THS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// ADC acquire time CLK_IN/(n + 1) The default value is 2 us.
            TACQ: u16,
        }), base_address + 0x0);

        /// address: 0x20094c0
        /// THS Data Register
        pub const THS_DATA = @intToPtr(*volatile MmioInt(32, u12), base_address + 0xc0);

        /// address: 0x2009410
        /// THS Data Interrupt Control Register
        pub const THS_DATA_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the interrupt of sensor_data update If enabled, when the measured
            /// sensor_data is updated, it will generate an interrupt.
            /// 0: Disabled
            /// 1: Enabled
            THS_DATA_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x2009420
        /// THS Data Interrupt Status Register
        pub const THS_DATA_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the pending status of the sensor’s data interrupt. Write 1 to clear
            /// the pending status.
            /// 0: No effect
            /// 1: Pending
            THS_DATA_IRQ_STS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x20);

        /// address: 0x2009404
        /// THS Enable Register
        pub const THS_EN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4);

        /// address: 0x2009430
        /// THS Median Filter Control Register
        pub const THS_FILTER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Averaging filter type
            /// 00: 2
            /// 01: 4
            /// 10: 8
            /// 11: 16
            FILTER_TYPE: u2,
            /// Filter enable
            /// 0: Disabled
            /// 1: Enabled
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x30);

        /// address: 0x2009408
        /// THS Period Control Register
        pub const THS_PER = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Temperature measurement period 4096*(n + 1)/CLK_IN The default value is 10 ms.
            THERMAL_PER: u20,
        }), base_address + 0x8);

        /// address: 0x2009480
        /// THS Shutdown Threshold Control Register
        pub const THS_SHUTDOWN_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Thermal sensor shutdown threshold for hot temperature
            SHUT_T_HOT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x80);

        /// address: 0x2009414
        /// THS Shut Interrupt Control Register
        pub const THS_SHUT_INTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable the shutdown interrupt for the sensor
            /// 0: Disabled
            /// 1: Enabled
            SHUT_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x2009424
        /// THS Shut Interrupt Status Register
        pub const THS_SHUT_INTS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the pending status of the sensor’s shutdown interrupt. Write 1 to
            /// clear the pending status.
            /// 0: No effect
            /// 1: Pending
            SHUT_INT_STS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x24);
    };

    /// TPADC
    pub const TPADC = struct {
        pub const base_address = 0x2009c00;

        /// address: 0x2009c1c
        /// TP Calibration Data Register
        pub const TP_CALI_DATA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TP Common Data It is used to adjust the tolerance of the internal ADC.
            TP_CDAT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x2009c00
        /// TP_CTRL0
        pub const TP_CTRL0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Touch panel ADC acquire time CLK_IN/(16*(N+1))
            TACQ: u16,
            /// ADC Sample Frequency Divider
            /// 0000: CLK_IN/2
            /// 0001: CLK_IN/2
            /// 0010: CLK_IN/2 ….
            /// 1111: CLK_IN/2
            FS_DIV: u4,
            /// ADC Clock Divider (CLK_IN)
            /// 00: CLK/2
            /// 01: CLK/3
            /// 10: CLK/6
            /// 11: CLK/1
            ADC_CLK_DIVIDER: u2,
            reserved0: u1,
            /// ADC First Convert Delay Mode Select
            /// 0: CLK_IN/16
            /// 1: CLK_IN/16*256
            ADC_FIRST_DLY_MODE: u1,
            /// ADC First Convert Delay Time (T_FCDT) Setting Based on ADC first convert delay
            /// mode select (Bit 23) T_FCDT = *
            ADC_FIRST_DLY: u8,
        }), base_address + 0x0);

        /// address: 0x2009c04
        /// TP Control Register 1
        pub const TP_CTRL_REG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog Input Channel 0 Select
            /// 0: Disable
            /// 1: Enable CHAN0–3 can be selected at the same time. If N channel is selected,
            /// each channel has 1/N full speed of the ADC. If only one channel is selected, it
            /// has the full conversion rate. CHAN0–3 correspond to TP_YN, TP_YP, TP_XN,
            /// TP_XP.
            ADC_CHAN0_SELECT: u1,
            /// Analog Input Channel 1 Select
            /// 0: Disable
            /// 1: Enable
            ADC_CHAN1_SELECT: u1,
            /// Analog Input Channel 2 Select
            /// 0: Disable
            /// 1: Enable
            ADC_CHAN2_SELECT: u1,
            /// Analog Input Channel 3 Select
            /// 0: Disable
            /// 1: Enable
            ADC_CHAN3_SELECT: u1,
            /// Touch Panel Mode and Auxiliary ADC Mode Select
            /// 0: TP
            /// 1: Auxiliary ADC
            TP_MODE_SELECT: u1,
            /// TP Function Enable
            /// 0: Disable
            /// 1: Enable
            TP_EN: u1,
            /// Touch Panel Double Point Enable
            /// 0: Disable
            /// 1: Enable
            TP_DUAL_EN: u1,
            /// Touch Panel Calibration
            /// 1: Start calibration, it is cleared to 0 after calibration
            TOUCH_PAN_CALI_EN: u1,
            /// T-sensor Chopping Enable
            /// 0: Disable
            /// 1: Enable This field is not used when there is no T-sensor in TPADC
            CHOPPER_EN: u1,
            /// Stylus Up Debounce Function Select
            /// 0: Disable
            /// 1: Enable
            STYLUS_UP_DEBOUCE_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Stylus Up De-bounce Time Setting
            /// 0x00: 0 ….
            /// 0xFF: 2N*(CLK_IN/16*256)
            STYLUS_UP_DEBOUNCE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0x2009c08
        /// TP Control Register 2
        pub const TP_CTRL_REG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TP Pressure Measurement Threshold Control 0x000000:least sensitive
            /// 0xFFFFFF: most sensitive This field is used to adjust sensitivity of touch.
            PRE_MEA_THRE_CNT: u24,
            /// TP Pressure Measurement Enable Control
            /// 0: Disable
            /// 1: Enable
            PRE_MEA_EN: u1,
            reserved0: u1,
            /// TP FIFO Access Data Mode Select
            /// 00: FIFO store X1,Y1 data for single touch no pressure mode
            /// 01: FIFO store X1,Y1, X, Y data for dual touch no pressure mode
            /// 10: FIFO store X1,Y1, X2,Y2 data for dual touch no pressure mode
            /// 11: FIFO store X1,Y1, X2,Y2,Z1,Z2 data for dual touch and pressure mode The ADC
            /// output data in single touch mode can store in FIFO with TP_FIFO_MODE_SELECT
            /// configured as 01,10,11. But the data X, Y is theoretically equal to X1,Y1, and
            /// X2,Y2 is equal to 0. When PRE_MEA_EN is set and TP_FIFO_MODE_SELECT is not
            /// configured as 2’b11, X and Y data will not be stored unless x1*(z2- z1)/z1 <
            /// PRE_MEA_THRE_CNT. Z data will always be zero when TP_FIFO_MODE_SELECT is
            /// configured as 2’b11 but PRE_MEA_EN is not set.
            TP_FIFO_MODE_SELECT: u2,
            /// Internal Pull-up Resistor Control
            /// 0000: least sensitive ……
            /// 1111: most sensitive This field is used to adjust sensitivity of pen down
            /// detection.
            TP_SENSITIVE_ADJUST: u4,
        }), base_address + 0x8);

        /// address: 0x2009c0c
        /// TP Control Register 3
        pub const TP_CTRL_REG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter Type
            /// 00: 4/2
            /// 01: 5/3
            /// 10: 8/4
            /// 11: 16/8
            FILTER_TYPE: u2,
            /// Filter Enable
            /// 0: Disable
            /// 1: Enable
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc);

        /// address: 0x2009c24
        /// TP Data Register
        pub const TP_DATA_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Touch Panel X ,Y data or Auxiliary analogy input data converted by the internal
            /// ADC.
            TP_DATA: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x24);

        /// address: 0x2009c10
        /// TP Interrupt FIFO Control Register
        pub const TP_INT_FIFO_CTRL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Touch Panel First Touch (Stylus Down) IRQ Enable
            /// 0: Disable
            /// 1: Enable
            TP_DOWN_IRQ_EN: u1,
            /// Touch Panel Last Touch (Stylus Up) IRQ Enable
            /// 0: Disable
            /// 1: Enable
            TP_UP_IRQ_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// TP FIFO Flush Write ‘1’ to flush TX FIFO, self clear to ‘0’
            TP_FIFO_FLUSH: u1,
            reserved2: u1,
            reserved3: u1,
            /// TP FIFO Data Available DRQ Enable
            /// 0: Disable
            /// 1: Enable
            TP_DATA_DRQ_EN: u1,
            /// TP FIFO Data Available Trigger Level Interrupt and DMA request trigger level for
            /// TP or Auxiliary ADC Trigger Level = TXTL + 1
            TP_FIFO_TRIG_LEVEL: u5,
            /// TP FIFO X,Y Data Interchange Function Select
            /// 0: Disable
            /// 1: Enable
            TP_DATA_XY_CHANGE: u1,
            reserved4: u1,
            reserved5: u1,
            /// TP FIFO Data Available IRQ Enable
            /// 0: Disable
            /// 1: Enable
            TP_DATA_IRQ_EN: u1,
            /// TP FIFO Overrun IRQ Enable
            /// 0: Disable
            /// 1: Enable
            TP_OVERRUN_IRQ_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);

        /// address: 0x2009c14
        /// TP Interrupt FIFO Status Register
        pub const TP_INT_FIFO_STAT_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Touch Panel First Touch (Stylus Down) IRQ Pending bit
            /// 0: No IRQ
            /// 1: IRQ Writing 1 to the bit clears it and its corresponding interrupt if the
            /// interrupt is enabled.
            TP_DOWN_PENDING: u1,
            /// Touch Panel Last Touch (Stylus Up) IRQ Pending bit
            /// 0: No IRQ
            /// 1: IRQ Writing 1 to the bit clears it and its corresponding interrupt if the
            /// interrupt is enabled.
            TP_UP_PENDING: u1,
            /// Touch Panel Idle Flag
            /// 0: idle
            /// 1: not idle
            TP_IDLE_FLG: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// TP FIFO Available Sample Word Counter
            RXA_CNT: u6,
            reserved5: u1,
            reserved6: u1,
            /// TP FIFO Data Available Pending Bit
            /// 0: NO Pending IRQ
            /// 1: FIFO Available Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if FIFO flushed.
            FIFO_DATA_PENDING: u1,
            /// TP FIFO Overrun IRQ pending
            /// 0: No Pending IRQ
            /// 1: FIFO Overrun Pending IRQ Write ‘1’ to clear this interrupt or
            /// automatically clear if interrupt condition fails.
            FIFO_OVERRUN_PENDING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);
    };

    /// TVD_TOP
    pub const TVD_TOP = struct {
        pub const base_address = 0x5c00000;

        /// address: 0x5c00008
        /// TVD 3D DMA CONTROL Register1
        pub const TVD_3D_CTL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TVD Enable 3D DMA
            /// 0: Disable
            /// 1: Enable Set 0x1 when enable 3D comb filter.
            TVD_EN_3D_DMA: u1,
            /// Comb 3D Enable
            /// 0: Disable
            /// 1: Enable
            COMB_3D_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Comb 3D Select
            /// 00: TVD0 Others: Reserved
            COMB_3D_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8);

        /// address: 0x5c0000c
        /// TVD 3D DMA CONTROL Register2
        pub const TVD_3D_CTL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DRAM Trigger
            DRAM_TRIG: u32,
        }), base_address + 0xc);

        /// address: 0x5c00010
        /// TVD 3D DMA CONTROL Register3
        pub const TVD_3D_CTL3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comb 3D Address0
            COMB_3D_ADDR0: u32,
        }), base_address + 0x10);

        /// address: 0x5c00014
        /// TVD 3D DMA CONTROL Register4
        pub const TVD_3D_CTL4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comb 3D Address1
            COMB_3D_ADDR1: u32,
        }), base_address + 0x14);

        /// address: 0x5c00018
        /// TVD 3D DMA CONTROL Register5
        pub const TVD_3D_CTL5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comb 3D Size
            COMB_3D_SIZE: u32,
        }), base_address + 0x18);

        /// address: 0x5c00000
        /// TVD TOP MAP Register
        pub const TVD_TOP_MAP = @intToPtr(*volatile Mmio(32, packed struct {
            /// TVD ADC Map
            /// 01: CVBS_MODE Others: Reserved
            TVD_ADC_MAP: u2,
            reserved0: u1,
            reserved1: u1,
            /// TVIN Select 0:TVIN0 1:TVIN1
            TVIN_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x0);

        pub const _N = @ptrCast(*volatile [4]packed struct {
            /// TVD ADC CONFIGURATION Register
            TVD_ADC_CFG: Mmio(32, packed struct {
                /// Stage1 Ibias Configuration
                STAGE1_IBIAS: u2,
                /// Stage2 Ibias Configuration
                STAGE2_IBIAS: u2,
                /// Stage3 Ibias Configuration
                STAGE3_IBIAS: u2,
                /// Stage4 Ibias Configuration
                STAGE4_IBIAS: u2,
                /// Stage5 Ibias Configuration
                STAGE5_IBIAS: u2,
                /// Stage6 Ibias Configuration
                STAGE6_IBIAS: u2,
                /// Stage7 Ibias Configuration
                STAGE7_IBIAS: u2,
                /// Stage8 Ibias Configuration
                STAGE8_IBIAS: u2,
                /// CLAMP Step Configuration DC level size step for up and down.
                CLP_STEP: u3,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                /// Data Delay Configuration
                /// 0: No delay
                /// 1: Delay ADC output data for half circle
                DATA_DLY: u1,
                reserved9: u1,
                reserved10: u1,
                /// ADC Test Mode Configuration
                /// 0: Normal mode
                /// 1: For ADC test
                ADC_TEST: u1,
            }),

            /// TVD ADC CONTROL Register
            TVD_ADC_CTL: Mmio(32, packed struct {
                /// ADC Enable
                /// 0: Disable ADC circuit
                /// 1: Enable ADC circuit
                ADC_EN: u1,
                /// AFE Enable
                /// 0: Disable AFE circuit
                /// 1: Enable AFE circuit
                AFE_EN: u1,
                /// Low Pass Filter Enable
                /// 0: Disable LPF circuit
                /// 1: Enable LPF circuit
                LPF_EN: u1,
                /// Low Pass Filter Select
                /// 00: 11M
                /// 01: 16M
                LPF_SEL: u2,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }),

            /// TVD TOP CONTROL Register
            TVD_TOP_CTL: Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                /// Low Pass Filter Digital Enable
                /// 0: Disable
                /// 1: Enable
                LPF_DIG_EN: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                /// Low Pass Filter Digital Select
                /// 0: 6M
                /// 1: 8M
                LPF_DIG_SEL: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
            }),
            padding0: u64,
            padding1: u64,
        }, base_address + 0x24);
    };

    /// TVD0
    pub const TVD0 = struct {
        pub const base_address = 0x5c01000;

        /// address: 0x5c01008
        /// TVD CLAMP & AGC CONTROL Register1
        pub const TVD_CLAMP_AGC1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto Gain Control Enable 0 : AGC disable 1 : AGC enable
            AGC_EN: u1,
            /// Auto Gain Control Freqence 0 : AGC gain update once per line 1 : AGC gain update
            /// once per frame
            AGC_FREQUENCE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Auto Gain Control Target When AGC_EN = 1 , the AGC_TARGET is used to directly
            /// digital AGC circuit. When AGC_EN = 0 , the AGC_TARGET is used to directly drive
            /// the analog PGA. (64 represents 1x, 32 represents 0.5x).
            AGC_TARGET: u8,
            /// Cagc Enable 0 : OFF 1 : ON
            CAGC_EN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Cagc Target These bits set the chroma AGC target
            CAGC_TARGET: u8,
        }), base_address + 0x8);

        /// address: 0x5c0100c
        /// TVD CLAMP & AGC CONTROL Register2
        pub const TVD_CLAMP_AGC2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AGC Gate Width
            AGC_GATE_WIDTH: u7,
            reserved0: u1,
            /// AGC Backporch Delay Count from sync tip to back porch gate
            AGC_BACKPORCH_DLY: u8,
            /// AGC Gate Begin Count from hsync to the next line AGC gate
            AGC_GATE_BEGIN: u13,
            reserved1: u1,
            reserved2: u1,
            /// Black Level Clamp
            /// 0: subtraction 0
            /// 1: subtraction 16
            BLACK_LVL_CLP: u1,
        }), base_address + 0xc);

        /// address: 0x5c01030
        /// TVD CHROMA LOCK CONTROL Register1
        pub const TVD_CLOCK1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color Killer Enable
            /// 1: Disable color when chroma unlock
            COLOR_KILLER_EN: u1,
            /// COLOR Standard
            /// 000: NTSC
            /// 001: PAL (I,B,G,H,D,N)
            /// 010: PAL (M)
            /// 011: PAL (CN)
            /// 100: SECAM
            COLOR_STD: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Burst Gate Start Time
            BURST_GATE_START_TIME: u8,
            /// Burst Gate End Time
            BURST_GATE_END_TIME: u8,
            /// Wide Burst_Gate
            /// 0: Narrow burst gate
            /// 1: Wide burst gate
            WIDE_BURST_GATE: u1,
            reserved4: u1,
            /// CHROMA Low Pass Filter
            /// 00: Narrow
            /// 01: Middle
            /// 10: Wide
            /// 11: Reserved
            CHROMA_LPF: u2,
            /// Color Standard Ntsc
            /// 0: NTSC358
            /// 1: NTSC443 Only valid when COLOR_STD set as NTSC
            COLOR_STD_NTSC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x5c01034
        /// TVD CHROMA LOCK CONTROL Register2
        pub const TVD_CLOCK2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// C Sample Step C_SAMPLE_STEP = Fsc/Fin X 2^30
            C_SAMPLE_STEP: u32,
        }), base_address + 0x34);

        /// address: 0x5c01100
        /// TVD DEBUG CONTROL Register1
        pub const TVD_DEBUG1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Afe Gain Value
            AFE_GAIN_VALUE: u8,
            /// Tvin Lock Debug
            TVIN_LOCK_DEBUG: u1,
            /// Tvin Lock High
            TVIN_LOCK_HIGH: u1,
            /// Truncation2 Reset Gain Enable
            TRUNCATION2_RST_GAIN_EN: u1,
            /// Truncation Reset Gain Enable
            TRUNCATION_RST_GAIN_EN: u1,
            /// Unlock Reset Gain Enable
            UNLOCK_RST_GAIN_EN: u1,
            /// Afe Gain Mode
            /// 0: Auto gain mode
            /// 1: Debug mode, AFE gain is determine by AFE_GAIN_VALUE
            AFE_GAIN_MODE: u1,
            /// Clamp Mode
            /// 0: Normal, auto clamp control
            /// 1: Debug mode, clamp control by register
            CLAMP_MODE: u1,
            /// Clamp Up Start Write 0x1 to make clamp up, clamp up value is determine by
            /// CLAMP_UPDN_CYCLES. Note that this bit is only valid when CLAMP_MODE is set as
            /// 0x1.
            CLAMP_UP_START: u1,
            /// Clamp Dn Start Write 0x1 to make clamp up, clamp up value is determine by
            /// CLAMP_UPDN_CYCLES. Note that this bit is only valid when CLAMP_MODE is set as
            /// 0x1.
            CLAMP_DN_START: u1,
            /// Clamp Updn Cycles
            CLAMP_UPDN_CYCLES: u7,
        }), base_address + 0x100);

        /// address: 0x5c01000
        /// TVD MODULE CONTROL Register
        pub const TVD_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// TVD Enable CH
            /// 0: Disable
            /// 1: Enable
            TVD_EN_CH: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear Resample FIFO
            /// 0: Release
            /// 1: Clear Set 0x1 then 0x0 to reset resample FIFO.
            CLR_RSMP_FIFO: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Enable Lock Disable WB1
            EN_LOCK_DISABLE_WB1: u1,
            /// Enable Lock Disable WB2
            EN_LOCK_DISABLE_WB2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x0);

        /// address: 0x5c01050
        /// TVD ENHANCEMENT CONTROL Register1
        pub const TVD_ENHANCE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// YC Delay
            /// 0000: Y and C no delay
            /// 0001: Y delay 1 cycle to C
            /// 0010: Y delay 2 cycle to C
            /// 0011: Y delay 3 cycle to C
            /// 0100: Y delay 4 cycle to C
            /// 0101: Y delay 5 cycle to C
            /// 0110: Y delay 6 cycle to C
            /// 0111: Y delay 7 cycle to C
            /// 1000: Reserved
            /// 1001: Reserved
            /// 1010: Reserved
            /// 1011: C delay 5 cycle to Y
            /// 1100: C delay 4 cycle to Y
            /// 1101: C delay 3 cycle to Y
            /// 1110: C delay 2 cycle to Y
            /// 1111: C delay 1 cycle to Y
            YC_DLY: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Contrast Gain Set 0x00, contrast gain is min ; Set 0x80, contrast gain is 1. Set
            /// 0xFF, contrast gain is max.
            CONTRAST_GAIN: u8,
            /// Bright Offset Set 0x00, brightness offset is -32; Set 0x20, brightness offset is
            /// 0. Set 0xFF, brightness offset is max.
            BRIGHT_OFFSET: u8,
            /// Sharp Enable
            /// 0: Disable
            /// 1: Enable
            SHARP_EN: u1,
            /// Sharp Coef1 Ysharp = Y + YH *(SHARP_COEF1/ SHARP_COEF2)
            SHARP_COEF1: u3,
            /// Sharp Coef2
            SHARP_COEF2: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x50);

        /// address: 0x5c01054
        /// TVD ENHANCEMENT CONTROL Register2
        pub const TVD_ENHANCE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Saturation Gain Set 0x00, saturation gain is min ; Set 0x80, saturation gain is
            /// 1. Set 0xFF, saturation gain is max.
            SATURATION_GAIN: u8,
            /// Chroma Enhance Enable
            /// 0: Disable
            /// 1: Enable
            CHROMA_ENHANCE_EN: u1,
            /// Chroma Enhance Strength
            /// 00: Mild
            /// 01: Low
            /// 10: Middle
            /// 11: High
            CHROMA_ENHANCE_STRENGTH: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x54);

        /// address: 0x5c01058
        /// TVD ENHANCEMENT CONTROL Register3
        pub const TVD_ENHANCE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cb Gain
            CB_GAIN: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Cr Gain
            CR_GAIN: u12,
            /// Cb Cr Gain Enable
            CB_CR_GAIN_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x58);

        /// address: 0x5c01010
        /// TVD HLOCK CONTROL Register1
        pub const TVD_HLOCK1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// H Sample Step H_SAMPLE_STEP = Fout/Fin X 2^30
            H_SAMPLE_STEP: u32,
        }), base_address + 0x10);

        /// address: 0x5c01014
        /// TVD HLOCK CONTROL Register2
        pub const TVD_HLOCK2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Total Pixels Per Line
            /// 0: 858
            /// 1: 864 2~7: Reserved
            HTOL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// HSYNC Filter Gate Start Time These bits specify the beginning of the
            /// horizontal-blank-interval window. Default/Hex = -42
            HS_FILTER_GATE_START_TIME: u8,
            /// HSYNC Filter Gate End Time These bits specify the end of the
            /// horizontal-blank-interval window. Default/Hex = 78
            HS_FILTER_GATE_END_TIME: u8,
        }), base_address + 0x14);

        /// address: 0x5c01018
        /// TVD HLOCK CONTROL Register3
        pub const TVD_HLOCK3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSYNC Rising Detect Window Start Time
            HS_RISING_DETECT_WINDOW_START_TIME: u8,
            /// HSYNC Rising Detect Window End Time
            HS_RISING_DET_WIN_END_TIME: u8,
            /// HSYNC Tip Detect Window Start Time
            HS_TIP_DET_WIN_START_TIME: u8,
            /// HSYNC Tip Detect Window End Time
            HS_TIP_DET_WIN_END_TIME: u8,
        }), base_address + 0x18);

        /// address: 0x5c0101c
        /// TVD HLOCK CONTROL Register4
        pub const TVD_HLOCK4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSYNC Detect Window Start Time For Coarse Detect
            HS_DET_WIN_START_TIME_FOR_COARSE_DET: u8,
            /// HSYNC Detect Window End Time For Corase Detect
            HS_DET_WIN_END_TIME_FOR_CORASE_DET: u8,
            /// HSYNC Rising Time For Fine Detect
            HS_RISING_TIME_FOR_FINE_DET: u8,
            /// HSYNC Fine To Coarse Offset
            HS_FINE_TO_COARSE_OFFSET: u8,
        }), base_address + 0x1c);

        /// address: 0x5c01020
        /// TVD HLOCK CONTROL Register5
        pub const TVD_HLOCK5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hactive Start
            HACT_START: u8,
            /// Hactive Width
            HACT_WIDTH: u8,
            /// Backporch Detect Window Start Time
            BACKPORCH_DET_WIN_START_TIME: u8,
            /// Backporch Detect Window End Time
            BACKPORCH_DET_WIN_END_TIME: u8,
        }), base_address + 0x20);

        /// address: 0x5c01080
        /// TVD DMA Interrupt Control Register
        pub const TVD_IRQ_CTL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Lock Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            LOCK_EN: u1,
            /// Unlock Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            UNLOCK_EN: u1,
            reserved0: u1,
            /// FIFO PR Overflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_PR_O_EN: u1,
            /// FIFO PB Overflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_PB_O_EN: u1,
            /// FIFO Y Overflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_Y_O_EN: u1,
            /// FIFO PR Underflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_PR_U_EN: u1,
            /// FIFO PB Underflow ENable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_PB_U_EN: u1,
            /// FIFO Y Underflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_Y_U_EN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Frame End Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FRAME_END_EN: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// FIFO 3D RX Underflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_3D_RX_U_EN: u1,
            /// FIFO 3D RX Overflow ENable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_3D_RX_O_EN: u1,
            /// FIFO 3D TX Underflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_3D_TX_U_EN: u1,
            /// FIFO 3D TX Overflow Enable
            /// 0: IRQ disable
            /// 1: IRQ enable
            FIFO_3D_TX_O_EN: u1,
        }), base_address + 0x80);

        /// address: 0x5c01090
        /// TVD DMA Interrupt Status Register
        pub const TVD_IRQ_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Lock
            /// 0: TVD status no change
            /// 1: TVD status change from unlock to lock
            LOCK: u1,
            /// Unlock
            /// 0: TVD status no change
            /// 1: TVD status change from lock to unlock
            UNLOCK: u1,
            reserved0: u1,
            reserved1: u1,
            /// FIFO C Overflow
            /// 0: FIFO work normal
            /// 1: FIFO overflow Write 0x1 to clear this bit.
            FIFO_C_O: u1,
            /// FIFO Y Overflow
            /// 0: FIFO work normal
            /// 1: FIFO overflow Write 0x1 to clear this bit.
            FIFO_Y_O: u1,
            reserved2: u1,
            /// FIFO C Underflow
            /// 0: FIFO work normal
            /// 1: FIFO underflow Write 0x1 to clear this bit.
            FIFO_C_U: u1,
            /// FIFO Y Underflow
            /// 0: FIFO work normal
            /// 1: FIFO underflow Write 0x1 to clear this bit.
            FIFO_Y_U: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// WB Address Change_Error Write back address change error
            WB_ADDR_CHANGE_ERR: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Frame End This bit is auto set every write back frame. Set 0x1 to clear this
            /// bit.
            FRAME_END: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// FIFO 3D RX Underflow
            /// 0: FIFO work normal
            /// 1: FIFO underflow Write 0x1 to clear this bit.
            FIFO_3D_RX_U: u1,
            /// FIFO 3D RX Overflow
            /// 0: FIFO work normal
            /// 1: FIFO overflow Write 0x1 to clear this bit.
            FIFO_3D_RX_O: u1,
            /// FIFO 3D TX Underflow
            /// 0: FIFO work normal
            /// 1: FIFO underflow Write 0x1 to clear this bit.
            FIFO_3D_TX_U: u1,
            /// FIFO 3D TX Overflow
            /// 0: FIFO work normal
            /// 1: FIFO overflow Write 0x1 to clear this bit.
            FIFO_3D_TX_O: u1,
        }), base_address + 0x90);

        /// address: 0x5c01004
        /// TVD MODE CONTROL Register
        pub const TVD_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Ypbpr Mode 0 : Disable the component input 1 : Enable the component input
            YPBPR_MODE: u1,
            /// Svideo Mode 0 : CVBS 1 : S-Video
            SVIDEO_MODE: u1,
            /// Progressive Mode
            /// 0: Interlace mode
            /// 1: Progressive mode
            PROGRESSIVE_MODE: u1,
            reserved0: u1,
            /// Blue Display Mode 00 : Disabled 01 : Enabled 10 : Auto 11 : Reserved
            BLUE_DISPLAY_MODE: u2,
            reserved1: u1,
            reserved2: u1,
            /// Blue Mode Color
            /// 0: Blue
            /// 1: Black
            BLUE_MODE_COLOR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x4);

        /// address: 0x5c01180
        /// TVD DEBUG STATUS Register1
        pub const TVD_STATUS1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits contain the analog AGC gain value.
            AGC_ANALOG_GAIN_STATUS: u8,
            /// These bits contain the digital AGC gain value.
            AGC_DEGITAL_GAIN_STATUS: u8,
            /// These bits contain the chroma magnitude.
            CHROMA_MAGNITUDE_STATUS: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x180);

        /// address: 0x5c01184
        /// TVD DEBUG STATUS Register2
        pub const TVD_STATUS2 = @intToPtr(*volatile Mmio(32, packed struct {
            CHROMA_SYNC_DTO_STATUS: u32,
        }), base_address + 0x184);

        /// address: 0x5c01188
        /// TVD DEBUG STATUS Register3
        pub const TVD_STATUS3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Sync Dto Status
            H_SYNC_DTO_STS: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x188);

        /// address: 0x5c0118c
        /// TVD DEBUG STATUS Register4
        pub const TVD_STATUS4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// No Signal Detected 0 : Signal Detected 1 :No Signal Detected
            NO_SIG_DET: u1,
            /// Horizontal line locked
            /// 0: Unlock
            /// 1: Locked
            H_LINE_LOCK: u1,
            /// Vertical Lock
            /// 0: Unlock
            /// 1: Locked
            V_LOCK: u1,
            /// Chroma Pll Locked To Color Burst
            /// 0: Unlock
            /// 1: Locked
            CHROMA_PLL_LOCKED_TO_COLOR_BURST: u1,
            /// Macrovision Vbi Pseudo Sync Pulses Detect
            /// 0: Undetected
            /// 1: Detected
            MACROVISION_VBI_PSEUDO_SYNC_PULSES_DET: u1,
            /// The Number Indicates The Number Of Color Stripe lines in each group
            MACROVISION_COLOR_STRIPES_DET: u3,
            /// Progressive Scan Detected
            PROSCAN_DET: u1,
            /// Horizontal Frequency Non-Standard Input Signal Detected
            HNON_STANDARD: u1,
            /// Vertical Frequency Non-Standard Input Signal Detected
            VNON_STANDARD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PAL Colour Mode Detected
            PAL_DET: u1,
            /// SECAM Colour Mode Detected
            SECAM_DET: u1,
            /// Detect 625 Line
            /// 0: 525 lines
            /// 1: 625 lines
            DET_625_LINE: u1,
            /// Noisy Signal Detected. This bit is set when the detected noise value (status
            /// register 7Fh) is greater than the value programmed into the “noise_thresh”
            /// register (05h).
            NOISY: u1,
            /// VCR Detected
            VCR: u1,
            /// VCR Trick-Mode Detected
            VCR_TRICK: u1,
            /// VCR Fast-Forward Detected
            VCR_FF: u1,
            /// VCR Rewind Detected
            VCR_REW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18c);

        /// address: 0x5c01190
        /// TVD DEBUG STATUS Register5
        pub const TVD_STATUS5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC Data Value
            ADC_DAT_VAL: u10,
            reserved0: u1,
            /// ADC Data Show
            ADC_DAT_SH: u1,
            /// Sync Level
            SYNC_LVL: u10,
            /// Blank Level
            BLK_LVL: u10,
        }), base_address + 0x190);

        /// address: 0x5c01194
        /// TVD DEBUG STATUS Register6
        pub const TVD_STATUS6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto Detect Finish 7 Memory
            /// ...................................................................................................................................................................
            /// 589 7.1 SDRAM Controller (DRAMC)
            /// ...........................................................................................................................
            /// 589 7.2 SD/MMC Host Controller (SMHC)
            /// ...................................................................................................................
            /// 590 7.2.1 Overview
            /// .............................................................................................................................................
            /// 590 7.2.2 Block Diagram
            /// .....................................................................................................................................
            /// 590 7.2.3 Functional Description
            /// ........................................................................................................................
            /// 591 7.2.4 Programming Guidelines
            /// .....................................................................................................................
            /// 604 7.2.5 Register List
            /// .........................................................................................................................................
            /// 609 7.2.6 Register Description
            /// ............................................................................................................................
            /// 611 Figure 7-1 SMHC Block Diagram
            /// .......................................................................................................................................
            /// 591 Figure 7-2 Command Token Format
            /// .................................................................................................................................
            /// 594 Figure 7-3 Response Token Format
            /// ..................................................................................................................................
            /// 594 Figure 7-4 Data Packet Format for SDR
            /// ............................................................................................................................
            /// 595 Figure 7-5 Data Packet Format for DDR
            /// ............................................................................................................................
            /// 596 Figure 7-6 Data Packet Format for DDR in HS400 Mode
            /// ..................................................................................................
            /// 597 Figure 7-7 Single-Block and Multi-Block Read Operation
            /// .................................................................................................
            /// 598 Figure 7-8 Single-Block and Multi-Block Read Operation
            /// .................................................................................................
            /// 598 Figure 7-9 Phase Offset of Command and Data in SDR Mode
            /// ..........................................................................................
            /// 599 Figure 7-10 Phase Offset of Command and Data in DDR4 Mode (SMHC_NTSR[31] =
            /// 0) ................................................. 600 Figure 7-11 Phase
            /// Offset of Command and Data in DDR4 Mode
            /// .....................................................................................
            /// 600 Figure 7-12 Phase Offset of Command and Data in DDR4 (2x Mode)
            /// (SMHC_NTSR[31] = 1) .......................................... 601 Figure 7-13
            /// IDMAC Descriptor Structure Diagram
            /// ............................................................................................................
            /// 602 Table 7-1 SMHC Sub-blocks
            /// ..............................................................................................................................................
            /// 591 Table 7-2 SMHC External Signals
            /// .......................................................................................................................................
            /// 592 Table 7-3 SMHC0/1 Clock Sources
            /// ....................................................................................................................................
            /// 592 Table 7-4 SMHC2 Clock Sources
            /// ........................................................................................................................................
            /// 592 Table 7-5 Speed Modes Supported by SD 3.0
            /// ...................................................................................................................
            /// 598 Table 7-6 Speed Modes Supported by eMMC 5.0
            /// ............................................................................................................
            /// 599 Table 7-7 Phase Offset of Command and Data in SDR Mode
            /// ...........................................................................................
            /// 600 Table 7-8 Phase Offset of Command and Data in DDR4 (2x) Mode
            /// .................................................................................
            /// 601 Table 7-9 DES0 Definition
            /// .................................................................................................................................................
            /// 602 Table 7-10 DES1 Definition
            /// ...............................................................................................................................................
            /// 603 Table 7-11 DES2 Definition
            /// ...............................................................................................................................................
            /// 603 Table 7-12 DES3 Definition
            /// ...............................................................................................................................................
            /// 603
            AUTO_DET_FINISH: u1,
            /// TV Standard
            /// 001: V525_NTSC
            /// 010: V625_PAL
            /// 011: V525_PALM
            /// 100: V625_PALN
            /// 101: V525_PAL60
            /// 110: V525_NTSC443
            /// 111: V625_SECAM
            TV_STD: u3,
            /// Auto Detect Enable
            /// 0: Disable
            /// 1: Enable
            AUTO_DET_EN: u1,
            /// Mask Palm
            MASK_PALM: u1,
            /// Mask Palcn
            MASK_PALCN: u1,
            /// Mask PAL60
            MASK_PAL60: u1,
            /// Mask NTSC443
            MASK_NTSC443: u1,
            /// Mask Secam
            MASK_SECAM: u1,
            /// Mask Unknown
            MASK_UNKNOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x194);

        /// address: 0x5c01024
        /// TVD VLOCK CONTROL Register1
        pub const TVD_VLOCK1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Total Line Per Frame 0 : 525 line 1 : 625 line
            VTOL: u3,
            reserved0: u1,
            /// VACT START
            VACTIVE_START: u11,
            reserved1: u1,
            /// Vactive Height
            VACT_HEIGHT: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x24);

        /// address: 0x5c01028
        /// TVD VLOCK CONTROL Register2
        pub const TVD_VLOCK2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hsync Dectector Disable Start Line
            HS_DET_DISABLE_START_LINE: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Hsync Detector Disable End Line
            HS_DET_DISABLE_END_LINE: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x28);

        /// address: 0x5c01060
        /// TVD WB DMA CONTROL Register1
        pub const TVD_WB1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// WB Enable
            /// 0: Disable
            /// 1: Enable
            WB_EN: u1,
            /// WB Format
            /// 0: YUV420
            /// 1: YUV422
            WB_FMT: u1,
            /// Field_Select
            /// 0: field 0 only
            /// 1: filed 1 only
            FIELD_SEL: u1,
            /// Hyscale_Enable
            HYSCALE_EN: u1,
            /// WB MB Mode
            /// 0: Planar mode
            /// 1: Mb mode
            WB_MB_MODE: u1,
            /// WB Frame Mode
            /// 0: Odd field or even field (decided by bit2)
            /// 1: Frame
            WB_FRAME_MODE: u1,
            /// Flip Field This bit flips even/odd fields
            FLIP_FIELD: u1,
            reserved0: u1,
            /// WB Address Valid
            /// 0: Invalid
            /// 1: Valid
            WB_ADDR_VALID: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Hactive Stride Horizontal active line stride
            HACT_STRIDE: u12,
            /// YUV420 Filter Enable
            /// 0: disable YUV420 WB data from YUV422 without chroma filter
            /// 1: enable YUV420 WB data from YUV422 with chroma filter
            YUV420_FILTER_EN: u1,
            reserved8: u1,
            reserved9: u1,
            /// UV Sequence
            /// 0: UVUV
            /// 1: VUVU
            UV_SEQ: u1,
        }), base_address + 0x60);

        /// address: 0x5c01064
        /// TVD WB DMA CONTROL Register2
        pub const TVD_WB2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal active pixel number
            HACT_NUM: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Vertical active line number
            VACT_NUM: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x64);

        /// address: 0x5c01068
        /// TVD WB DMA CONTROL Register3
        pub const TVD_WB3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Ch1 Y Address
            CH1_Y_ADDR: u32,
        }), base_address + 0x68);

        /// address: 0x5c0106c
        /// TVD WB DMA CONTROL Register4
        pub const TVD_WB4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Ch1 C Address
            CH1_C_ADDR: u32,
        }), base_address + 0x6c);

        /// address: 0x5c01040
        /// TVD YC SEPERATION CONROL Register1
        pub const TVD_YC_SEP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 3D Comb_Filter Mode
            /// 000: 2D mode
            /// 001: 3D YC separation mode1 010~011: reserved
            /// 0100: 3D YC separation mode2
            @"3D_COMB_FILTER_MODE": u3,
            /// 3D Comb Filter Disable
            /// 0: Enable 3D comb filter
            /// 1: Disable 3D comb filter
            @"3D_COMB_FILTER_DIS": u1,
            /// 2D Comb Filter Mode For NTSC:
            /// 0000: 2D comb 0001~0010: Reserved
            /// 0011: 1D comb 0100~1000: Reserved For PAL: 0000:2D comb filter1
            /// 0001: 1D comb filter1
            /// 0010: 2D comb filter2
            /// 0011: 1D comb filter2
            /// 0100: 1D comb filter3
            /// 0101: Reserved
            /// 0110: 2D comb filter3 0111~1000:Reserved
            @"2D_COMB_FILTER_MODE": u4,
            /// Notch bandwidth 0 : Narrow 1 : Wide
            SECAM_NOTCH_WIDE: u1,
            /// Chroma Bandpass Filter Enable
            /// 0: Disable
            /// 1: Enable
            CHROMA_BANDPASS_FILTER_EN: u1,
            /// PAL Chroma Level Chroma level threshold for chroma comb filter select
            PAL_CHROMA_LVL: u6,
            /// Comb Filter Buffer Clear
            /// 0: Not clear
            /// 1: Clear
            COMB_FILTER_BUF_CLR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Notch Factor
            NOTCH_FACTOR: u3,
            /// 2D Comb Factor
            @"2D_COMB_FACTOR": u3,
            /// 3D Comb Factor
            @"3D_COMB_FACTOR": u3,
            /// Chroma Coring Enable
            CHROMA_CORING_EN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x40);

        /// address: 0x5c01044
        /// TVD YC SEPERATION CONROL Register2
        pub const TVD_YC_SEP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal Luma Filter Gain
            H_LUMA_FILTER_GAIN: u2,
            /// Horizontal Chroma Filter Gain
            H_CHROMA_FILTER_GAIN: u2,
            /// Luma Vertical Filter Gain
            LUMA_V_FILTER_GAIN: u2,
            /// Chroma Vertical Filter Gain
            CHROMA_V_FILTER_GAIN: u2,
            /// Motion Detect Noise Detect Enable
            MOTION_DET_NOISE_DET_EN: u1,
            /// Motion Detect Noise Threshold
            MOTION_DET_NOISE_THRESHOLD: u7,
            /// Noise Detect Enable
            NOISE_DET_EN: u1,
            /// Noise Threshold
            NOISE_THRESHOLD: u7,
            /// Luma Noise Factor
            LUMA_NOISE_FACTOR: u2,
            /// Chroma Noise Factor
            CHROMA_NOISE_FACTOR: u2,
            /// Burst Noise Factor
            BURST_NOISE_FACTOR: u2,
            /// Vertical Noise Factor
            V_NOISE_FACTOR: u2,
        }), base_address + 0x44);
    };

    /// TVE_TOP
    pub const TVE_TOP = struct {
        pub const base_address = 0x5600000;

        /// address: 0x5600028
        /// TV Encoder DAC CFG0 Register
        pub const TVE_DAC_CFG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable
            /// 1: Enable
            DAC_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// 0: Disable
            /// 1: Enable (A_EN_RESREF)
            BIAS_REF_INT_EN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// 0: Disable
            /// 1: Enable (A_SEL_BIAS_RES)
            BIAS_INT_SEL: u1,
            /// 0: Disable
            /// 1: Enable (A_SEL_BIAS_ADDA)
            BIAS_EXT_SEL: u1,
            reserved6: u1,
            reserved7: u1,
            /// 500 uA to 4 mA
            LOW_BIAS: u4,
            CALI_IN: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// 0: Not invert
            /// 1: Invert
            DAC_CLOCK_INVERT: u1,
        }), base_address + 0x28);

        /// address: 0x560002c
        /// TV Encoder DAC CFG1 Register
        pub const TVE_DAC_CFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0000: 0.50 V
            /// 0001: 0.55 V
            /// 0010: 0.60 V
            /// 0011: 0.65 V
            /// 0100: 0.70 V
            /// 0101: 0.75 V
            /// 0110: 0.80 V
            /// 0111: 0.85 V
            /// 1000: 0.90 V
            /// 1001: 0.95 V
            /// 1010: 1.00 V
            /// 1011: 1.05 V
            /// 1100: 1.10 V
            /// 1101: 1.15 V
            /// 1110: 1.20 V
            /// 1111: 1.25 V (a_refslct1<3:0>) The reference voltage is used for hot plug detect
            /// function.
            REF1_SEL: u4,
            /// 00: 0.25 V
            /// 01: 0.30 V
            /// 10: 0.35 V
            /// 11: 0.40 V (a_refslct2<1:0>)
            REF2_SEL: u2,
            reserved0: u1,
            reserved1: u1,
            /// 0: Disable
            /// 1: Enable (A_SEL_DETREF_RES)
            REF_INT_SEL: u1,
            /// 0: Disable
            /// 1: Enable (A_SEL_DETREF_LDO)
            REF_EXT_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x2c);

        /// address: 0x5600030
        /// TV Encoder DAC CFG2 Register
        pub const TVE_DAC_CFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            R_SET: u6,
            S2S1: u2,
            /// ( I config output current for different peak voltage)
            AB: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x30);

        /// address: 0x5600034
        /// TV Encoder DAC CFG2 Register
        pub const TVE_DAC_CFG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: DAC input data from TVE
            /// 1: DAC input data from FORCE_DATA_SET
            FORCE_DATA_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Force DAC input data
            FORCE_DATA_SET: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x34);

        /// address: 0x5600020
        /// TV Encoder DAC MAP Register
        pub const TVE_DAC_MAP = @intToPtr(*volatile Mmio(32, packed struct {
            /// 00: Reserved
            /// 01: TVE0
            /// 10: Reserved
            /// 11: Reserved
            DAC_SEL: u2,
            reserved0: u1,
            reserved1: u1,
            /// 000: OUT0 Others: Reserved
            DAC_MAP: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x20);

        /// address: 0x5600024
        /// TV Encoder DAC STAUTS Register
        pub const TVE_DAC_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// 00: Unconnected
            /// 01: Connected
            /// 11: Short to ground
            /// 10: Reserved
            DAC_STATUS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x24);

        /// address: 0x56000f0
        /// TV Encoder DAC TEST Register
        pub const TVE_DAC_TEST = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Reserved
            /// 1: Repeat DAC data from DAC sram
            DAC_TEST_ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// 00: DAC0 Others: Reserved
            DAC_TEST_SEL: u2,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// DAC TEST DATA LENGTH
            DAC_TEST_LENGTH: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xf0);
    };

    /// TVE
    pub const TVE = struct {
        pub const base_address = 0x5604000;

        /// address: 0x5604000
        /// TV Encoder Clock Gating Register
        pub const TVE_000_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: Disable
            /// 1: Enable Video Encoder enable, default disable, write 1 to take it out of the
            /// reset state
            TVE_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Out up sample
            /// 00: 27 MHz
            /// 01: 54 MHz
            /// 10: 108 MHz
            /// 11: 216 MHz
            UPSAMPLE_FOR_CVBS: u2,
            /// 0: 1x
            /// 1: 2x
            UPSAMPLE_FOR_YPBPR: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// 0: Normal mode
            /// 1: Bist mode
            BIST_EN: u1,
            reserved24: u1,
            reserved25: u1,
            /// 0: Enable
            /// 1: Disable
            CLOCK_GATE_DIS: u1,
        }), base_address + 0x0);

        /// address: 0x5604004
        /// TV Encoder Configuration Register
        pub const TVE_004_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TVMode_Select
            /// 0000: NTSC
            /// 0001: PAL
            /// 0010: Reserved
            /// 0011: Reserved
            /// 01xx: Reserved
            /// 100x: Reserved
            /// 101x: Reserved
            /// 110x: Reserved
            /// 111x: Reserved Note: Changing this register value will cause some relative
            /// register setting to relative value.
            TVMODE_SELECT: u4,
            /// Mode_1080i_1250Line_Sel
            /// 0: 1125 Line mode
            /// 1: 1250 Line mode
            MODE_1080I_1250LINE_SEL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Standard Color bar input selection
            /// 0: The Video Encoder input is coming from the Display Engineer
            /// 1: The Video Encoder input is coming from an internal standard color bar
            /// generator. This bit selects whether the Video Encoder video data input is
            /// replaced by an internal standard color bar generator or not.
            COLOR_BAR_MODE: u1,
            /// 0: 75/7.5/75/7.5 (NTSC), 100/0/75/0(PAL)
            /// 1: 100/7.5/100/7.5(NTSC), 100/0/100/0(PAL)
            COLOR_BAR_TYPE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Composite video enables selection
            /// 0: Composite video is disabled, Only Y/C is enabled
            /// 1: Composite video is enabled., CVBS and Y/C are enabled This bit selects
            /// whether the composite video output (CVBS) is enabled or disabled.
            CVBS_EN: u1,
            /// S-port Video enable Selection.
            /// 0: Y/C is disable
            /// 1: Reserved This bit selects whether the S-port(Y/C) video output is enabled or
            /// disabled.
            YC_EN: u1,
            /// 0: CVBS
            /// 1: Reserved
            YUV_RGB_OUTPUT_EN: u1,
            /// 0: 4:4:4
            /// 1: 4:2:2
            INPUT_CHROMA_DATA_SAMPLING_RATE_SEL: u1,
            /// Cb_Cr_Seq_For_422_Mode
            /// 0: Cb first
            /// 1: Cr first
            CB_CR_SEQ_FOR_422_MODE: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// 0: Using 27 MHz clock or 74.25 MHz clock depend on CCU setting
            /// 1: Using 54 MHz clock or 148.5 MHz clock depend on CCU setting
            CORE_CONTROL_LOGIC_CLOCK_SEL: u1,
            /// 0: Using 27 MHz clock or 74.25 MHz clock depend on CCU setting
            /// 1: Using 54 MHz clock or 148.5 MHz clock depend on CCU setting
            CORE_DATAPATH_LOGIC_CLOCK_SEL: u1,
            /// 0: Using 27 MHz clock or 74.25 MHz clock depend on CCU setting
            /// 1: Using 54 MHz clock or 148.5 MHz clock depend on CCU setting
            DAC_CONTROL_LOGIC_CLOCK_SEL: u1,
            /// 00: TV Encoder
            /// 01: LCD controller, override all other TV encoder setting, the DAC clock can
            /// from LCD controller.
            /// 10: DAC test mode, DAC using DAC clock
            /// 11: DAC test mode, DAC using AHB clock
            DAC_SRC_SEL: u2,
            /// 0: Disable
            /// 1: Enable
            BYPASS_TV: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0x5604008
        /// TV Encoder DAC Register1
        pub const TVE_008_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 000: Composite Others: Reserved
            DAC0_SRC_SEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x8);

        /// address: 0x560400c
        /// TV Encoder Notch and DAC Delay Register
        pub const TVE_00C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            C_DELAY_BEFORE_DITHER: u4,
            /// 0: The luma notch filter is bypassed
            /// 1: The luma notch filter is operating Luma notch filter on/off selection Note:
            /// This bit selects if the luma notch filter is operating or bypassed.
            NOTCH_EN: u1,
            /// 0: Luma Filter Enable
            /// 1: Luma Filter bypass
            LUMA_FILTER_BYPASS: u1,
            /// Chroma_Filter_Stage_3_Bypass
            /// 0: Chroma Filter Stage 3 Enable
            /// 1: Chroma Filter Stage 3 bypass
            CHROMA_FILTER_STAGE_3_BYPASS: u1,
            /// Chroma_Filter_Stage_2_Bypass
            /// 0: Chroma Filter Stage 2 Enable
            /// 1: Chroma Filter Stage 2 bypass
            CHROMA_FILTER_STAGE_2_BYPASS: u1,
            /// Chroma_Filter_Stage_1_Bypass
            /// 0: Chroma Filter Stage 1 Enable
            /// 1: Chroma Filter Stage 1 bypass
            CHROMA_FILTER_STAGE_1_BYPASS: u1,
            /// 0: Chroma HD Filter Disable
            /// 1: Chroma HD Filter Enable
            CHROMA_HD_MODE_FILTER_EN: u1,
            /// Chroma_Filter_1_444_En
            /// 0: Chroma Filter 1 444 Disable
            /// 1: Chroma Filter 1 444 Enable
            CHROMA_FILTER_1_444_EN: u1,
            /// 0: Bypass Enable
            /// 1: Bypass Disable
            HD_MODE_CR_FILTER_BYPASS: u1,
            /// 0: Bypass Enable
            /// 1: Bypass Disable
            HD_MODE_CB_FILTER_BYPASS: u1,
            Y_DELAY_BEFORE_DITHER: u3,
            reserved12: u1,
            reserved13: u1,
            /// Luma_filter_lti_enable
            /// 0: Disable Luma filter lti
            /// 1: Enable Luma filter lti
            LUMA_FILTER_LTI_ENABLE: u1,
            /// 0: Disable
            /// 1: Enable
            CHROMA_FILTER_ACTIVE_VALID: u1,
        }), base_address + 0xc);

        /// address: 0x5604010
        /// TV Encoder Chroma Frequency Register
        pub const TVE_010_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the ratio between the color burst frequency. 32 bits unsigned fraction.
            /// The default value is h21f07c1f, which is compatible with NTSC spec. 3.5795455
            /// MHz (X‘21F07C1F’): NTSC-M, NTSC-J 4.43361875 MHz(X‘2A098ACB’): PAL-B, D,
            /// G, H,I, N 3.582056 MHz (X‘21F69446’): PAL-N(Argentina) 3.579611 MHz
            /// (X‘21E6EFE3’): PAL-M
            CHROMA_FREQ: u32,
        }), base_address + 0x10);

        /// address: 0x5604014
        /// TV Encoder Front/Back Porch Register
        pub const TVE_014_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Must be even Specify the width of the front porch in encoder clock cycles. 6
            /// bits unsigned even integer. Allowed range is form 10 to 62. The default value is
            /// 32. For 1080i mode, the value is 44.
            FRONT_PORCH: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Specify the width of the back porch in encoder clock cycles. Min value is
            /// (burst_width+breeze_way+17). 8 bits unsigned integer. The default value is 118.
            /// For 720p mode, the value is 260. For 1080i/p mode, the value is 192.
            BACK_PORCH: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x14);

        /// address: 0x5604018
        /// TV Encoder HD Mode VSYNC Register
        pub const TVE_018_REG = @intToPtr(*volatile Mmio(32, packed struct {
            FRONT_PORCH_LIKE_IN_HD_MODE_VSYNC: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            BROAD_PLUS_CYCLE_NUMBER_IN_HD_MODE_VSYNC: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x18);

        /// address: 0x560401c
        /// TV Encoder Line Number Register
        pub const TVE_01C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the total number of lines in a video frame. 11 bits unsigned integer.
            /// Allowed range is 0 to 2048. For interlaced video: When NTSC, and FirstVideoLine
            /// is greater than 20, then NumLines is restricted to be greater than
            /// 2*(FirstVideoLine+18). When NTSC, and FirstVideoLine is not greater than 20,
            /// then NumLines is restricted to be greater than 77. When PAL, and FirstVideoLine
            /// is greater than 22, then NumLines is restricted to be greater than
            /// 2*(FirstVideoLine+18). When PAL, and FirstVideoLine is not greater than 22, then
            /// NumLines is restricted to be greater than 81. If NumLines is even, then it is
            /// restricted to be divisible by 4. If NumLines is odd, then it is restricted to be
            /// divisible by 4 with a remainder of 1.
            NUM_LINES: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Specify the index of the first line in a field/frame to have active video. 8
            /// bits unsigned integer. For interlaced video: When VSync5=B‘0’,
            /// FirstVideoLine is restricted to be greater than 7. When VSync5=B‘1’,
            /// FirstVideoLine is restricted to be greater than 9.
            FIRST_VIDEO_LINE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x1c);

        /// address: 0x5604020
        /// TV Encoder Level Register
        pub const TVE_020_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the black level setting. This is 10 bits unsigned integer. Allowed range
            /// is from 240 to 1023.
            BLACK_LEVEL: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Specify the blank level setting for active lines. This is 10 bits unsigned
            /// integer. Allowed range is from 0 to 1023.
            BLANK_LEVEL: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x20);

        /// address: 0x5604030
        /// TV Encoder Auto Detection Enable Register
        pub const TVE_030_REG = @intToPtr(*volatile Mmio(32, packed struct {
            DAC0_AUTO_DETECT_ENABLE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            DAC0_AUTO_DETECT_INTERRUPT_EN: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// 0: Old Mode
            /// 1: New Mode
            DAC_AUTO_DETECT_MODE_SEL: u1,
        }), base_address + 0x30);

        /// address: 0x5604034
        /// TV Encoder Auto Detection Interrupt Status Register
        pub const TVE_034_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write 1 to inactive DAC0 auto detection interrupt
            DAC0_AUTO_DETECT_INTERRUPT_ACTIVE_FLAG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x34);

        /// address: 0x5604038
        /// TV Encoder Auto Detection Status Register
        pub const TVE_038_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// 00: Unconnected
            /// 01: Connected
            /// 11: Short to ground
            /// 10: Reserved
            DAC0_STATUS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x38);

        /// address: 0x560403c
        /// TV Encoder Auto Detection De-bounce Setting Register
        pub const TVE_03C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The de_bounce time for hot plug detect function.
            DAC0_DE_BOUNCE_TIMES: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// DAC test register.
            DAC_TEST_REGISTER: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x3c);

        /// address: 0x56040f8
        /// TV Encoder Auto Detect Configuration Register0
        pub const TVE_0F8_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Use for DAC data input at auto detect pluse. Set the pulse amplitude.
            DETECT_PULSE_VALUE: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0xf8);

        /// address: 0x56040fc
        /// TV Encoder Auto Detect Configuration Register1
        pub const TVE_0FC_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Detect signal start time
            DETECT_PULSE_START: u15,
            reserved0: u1,
            /// Use 32K clock
            DETECT_PULSE_PERIODS: u15,
            padding0: u1,
        }), base_address + 0xfc);

        /// address: 0x5604100
        /// TV Encoder Color Burst Phase Reset Configuration Register
        pub const TVE_100_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Color burst phase period selection These bits select the number of fields or
            /// lines after which the color burst phase is reset to its initial value as
            /// specified by the ChromaPhase parameter, This parameter is application only for
            /// interlaced video.
            /// 00: 8 field
            /// 01: 4 field
            /// 10: 2 lines
            /// 11: only once
            COLOR_PHASE_RESET: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x100);

        /// address: 0x5604104
        /// TV Encoder VSYNC Number Register
        pub const TVE_104_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// VSync5 Number of equalization pulse selection This bit selects whether the
            /// number of equalization pulses is 5 or 6. This parameter is applicable only for
            /// interlaced video.
            /// 0: 5 equalization pulse(default)
            /// 1: 6 equalization pulses
            VSYNC5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x5604108
        /// TV Encoder Notch Filter Frequency Register
        pub const TVE_108_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Luma notch filter center frequency selection These bits select the luma notch
            /// filter (which is a band-reject filter) center frequency. In two of the
            /// selections, the filter width affects also the selection of the center frequency.
            /// 000: 1.1875
            /// 001: 1.1406
            /// 010: 1.0938. When notch_wide value is B‘1’ (this selection is proper for
            /// CCIR-NTSC), or 1.0000 when notch_wide value is B‘0’.
            /// 011: 0.9922. This selection is proper for NTSC with square pixels.
            /// 100: 0.9531. This selection is proper for PAL with square pixel.
            /// 101: 0.8359 when notch_wide value is B‘1’ (this selection is proper for
            /// CCIR-PAL), or 0.7734 when notch_wide value is B‘0’.
            /// 110: 0.7813
            /// 111: 0.7188
            NOTCH_FREQ: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x108);

        /// address: 0x560410c
        /// TV Encoder Cb/Cr Level/Gain Register
        pub const TVE_10C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the amplitude of the Cb burst. 8 bit 2’s complement integer. Allowed
            /// range is from (-127) to 127.
            CB_BURST_LEVEL: u8,
            /// Specify the amplitude of the Cr burst. 8 bit 2’s complement integer. Allowed
            /// range is from (-127) to 127.
            CR_BURST_LEVEL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x5604110
        /// TV Encoder Tint and Color Burst Phase Register
        pub const TVE_110_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the color burst initial phase (ChromaPhase). 8.8 bit unsigned fraction.
            /// Units are cycles of the color burst frequency. The color burst is set to this
            /// phase at the first HSYNC and then reset to the same value at further HSYNCs as
            /// specified by the CPhaseRset bits of the EncConfig5 parameter (see above)
            CHROMA_PHASE: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Tint Specify the tint adjustment of the chroma signal for CVBS and Y/C outputs.
            /// The adjustment is effected by setting the sub- carrier phase to the value of
            /// this parameter. 8.8 bit unsigned fraction. Units are cycles of the color burst
            /// frequency.
            TINT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x110);

        /// address: 0x5604114
        /// TV Encoder Burst Width Register
        pub const TVE_114_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSync_Width Specify the width of the horizontal sync pulse in encoder clock
            /// cycles. Min value is 16. Max value is (FrontPorch + ActiveLine - BackPorch).
            /// Default value is 126. The sum of HSyncSize and BackPorch is restricted to be
            /// divisible by 4. For 720p mode, the value is 40. For 1080i/p mode, the value is
            /// 44.
            HSYNC_WIDTH: u8,
            /// Specify the width of the color frequency burst in encoder clock cycles. 7 bit
            /// unsigned integer. Allowed range is 0 to 127. In hd mode, it is ignored.
            BURST_WIDTH: u7,
            reserved0: u1,
            /// Breezeway Must be even Specify the width of the breezeway in encoder clock
            /// cycles. 5 bit unsigned integer. Allowed range is 0 to 31. For 1080i mode, the
            /// value is 44. For 1080p mode, the value is 44. For 720p mode, the value is 40.
            BREEZEWAY: u7,
            reserved1: u1,
            /// Breezeway like in HD mode VSync For 720p mode, the value is 220 For 2080i/p
            /// mode, the value is 88 (default)
            BACK_PORCH: u8,
        }), base_address + 0x114);

        /// address: 0x5604118
        /// TV Encoder Cb/Cr Gain Register
        pub const TVE_118_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the Cb color gain. 8-bit unsigned fraction.
            CB_GAIN: u8,
            /// Specify the Cr color gain. 8-bit unsigned fraction.
            CR_GAIN: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x560411c
        /// TV Encoder Sync and VBI Level Register
        pub const TVE_11C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// VBlank_Level Specify the blank level setting for non active lines. 10-bit
            /// unsigned integer. Allow range is from 0 to 1023.
            VBLANK_LEVEL: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Specify the sync pulse level setting. 8-bit unsigned integer. Allowed range is
            /// from 0 to ABlankLevel-1 or VBlankLevel-1 (whichever is smaller).
            SYNC_LEVEL: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x11c);

        /// address: 0x5604120
        /// TV Encoder White Level Register
        pub const TVE_120_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the white level setting. 10-bit unsigned integer. Allowed range is from
            /// black_level+1 or vbi_blank_level +1 (whichever is greater) to 1023.
            WHITE_LEVEL: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Specify the breezeway level setting. 10-bit unsigned integer. Allowed range is
            /// from 0 to 1023.
            HD_SYNC_BREEZEWAY_LEVEL: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x120);

        /// address: 0x5604124
        /// TV Encoder Video Active Line Register
        pub const TVE_124_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Specify the width of the video line in encoder clock cycles. 12- bit unsigned
            /// multiple of 4 integer. Allowed range is from 0 to 4092.
            ACTIVE_LINE: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x124);

        /// address: 0x5604128
        /// TV Encoder Video Chroma BW and CompGain Register
        pub const TVE_128_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Chroma gain selection for the composite video signal. These bits specify the
            /// gain of the chroma signal for composing with the luma signal to generate the
            /// composite video signal:
            /// 00: 100%
            /// 01: 25%
            /// 10: 50%
            /// 11: 75%
            COMP_CH_GAIN: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Chroma filter bandwidth selection This bit specifies whether the bandwidth of
            /// the chroma filter is:
            /// 00: Narrow width 0.6 MHz
            /// 01: Wide width 1.2 MHz
            /// 10: Extra width 1.8 MHz
            /// 11: Ultra width 2.5 MHz
            CHROMA_BW: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x128);

        /// address: 0x560412c
        /// TV Encoder Register
        pub const TVE_12C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit selects if the components video output are the RGB components or the
            /// YUV components.
            /// 0: The three component outputs are the RGB components.
            /// 1: The three component outputs are the YUV components, (i.e. the color
            /// conversion unit is bypassed)
            COMP_YUV_EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Luma notch filter width selection This bit selects the luma notch filter (which
            /// is a band-reject filter) width.
            /// 0: Narrow
            /// 1: Wide
            NOTCH_WIDTH: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x12c);

        /// address: 0x5604130
        /// TV Encoder Re-sync Parameters Register
        pub const TVE_130_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Re-sync line pixel from TCON
            RE_SYNC_PIXEL_NUM: u11,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Re-sync line number from TCON
            RE_SYNC_LINE_NUM: u11,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// 0: Re-Sync Enable
            /// 1: Re-Sync Disable
            RE_SYNC_DIS: u1,
            /// Re-sync field
            RE_SYNC_FIELD: u1,
        }), base_address + 0x130);

        /// address: 0x5604134
        /// TV Encoder Slave Parameter Register
        pub const TVE_134_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection This bit selects whether the Video Encoder is sync slave,
            /// partial slave or sync master. It should be set to B‘0’.
            /// 0: The Video Encoder is not a full sync slave (i.e. it is a partial sync slave
            /// or a sync master)
            /// 1: Reserved
            SLAVE_MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Horizontal line adjustment threshold selection This bit selects whether the
            /// number of lines after which the Video Encoder starts the horizontal line length
            /// adjustment is slave mode is 0 or 30.
            /// 0: Number of lines is 0
            /// 1: Number of lines is 30
            SLAVE_THRESH: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x134);

        /// address: 0x5604138
        /// TV Encoder Configuration Register0
        pub const TVE_138_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit selects if the sample order at the chroma input to the Video Encoder is
            /// Cb first (i.e. Cb 0 Cr 0 Cb 1 Cr 1) or Cr first (i.e. Cr 0 Cb 0 Cr 1 Cb 1).
            /// 0: The chroma sample input order is Cb first
            /// 1: The chroma sample input order is Cr first
            UV_ORDER: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Field parity input signal (top_field) polarity selection. This bit selects
            /// whether the top field is indicated by a high level of the field parity signal or
            /// by the low level. The bit is applicable both when the Video Encoder is the sync
            /// master and when the Video Encoder is the sync slave.
            /// 0: Top field is indicated by low level
            /// 1: Top field is indicated by high level
            INVERT_TOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x138);

        /// address: 0x560413c
        /// TV Encoder Configuration Register1
        pub const TVE_13C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Y input clamping selection This bit selects whether the Video Encoder Y input is
            /// clamped to 64 to 940 or not. When not clamped the expected range is 0 to 1023.
            /// The U and V inputs are always clamped to the range 64 to 960.
            /// 0: The Video Encoder Y input is clamped
            /// 1: The Video Encoder Y input is not clamped
            BYPASS_YCLAMP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// “Set-up” enable for RGB outputs. This bit specifies if the “set-up”
            /// implied value (black_level – blank_level) specified for the CVBS signal is
            /// used also for the RGB signals.
            /// 0: The “set-up” is not used, or i.e. comp_yuv is equal to b‘1’.
            /// 1: The implied “set-up” is used for the RGB signals
            RGB_SETUP: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// R, G and B signals sync embedding selection. These bits specify whether the sync
            /// signal is added to each of the R, G and B components (b‘1’) or not
            /// (b‘0’). The bit[26] specify if the R signal has embedded syncs, the bit[25]
            /// specify if the G signal has embedded syncs and the bit[24] specify if the B
            /// signal has embedded syncs. When comp_yuv is equal to b‘1’, these bits are
            /// N.A. and should be set to b‘000’. When the value is different from
            /// b‘000’, RGB_Setup should be set to b‘1’.
            RGB_SYNC: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x13c);

        /// address: 0x5604380
        /// TV Encoder Low Pass Control Register
        pub const TVE_380_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// LP function enable
            /// 0: Disable
            /// 1: Enable
            EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Enable_deflicker
            /// 0: Disable deflicker
            /// 1: Enable deflicker
            ENABLE_DEFLICKER: u1,
            /// Fix_coef_deflicker
            /// 0: Auto deflicker
            /// 1: User deflicker
            FIX_COEF_DEFLICKER: u1,
            /// User_deflicker_coef up: coef/32 Center: 1-coef/16 Down: coef/32
            USER_DEFLICKER_COEF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x380);

        /// address: 0x5604384
        /// TV Encoder Low Pass Filter Control Register
        pub const TVE_384_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Default band-pass filter1 ratio In two complement, the range is from -31 to 31.
            BP1_RATIO: u6,
            reserved0: u1,
            reserved1: u1,
            /// Default band-pass filter0 ratio In two complement, the range is from -31 to 31.
            BP0_RATIO: u6,
            reserved2: u1,
            reserved3: u1,
            /// Default high-pass filter ratio In two complement, the range is from -31 to 31.
            HP_RATIO: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x384);

        /// address: 0x5604388
        /// TV Encoder Low Pass Gain Register
        pub const TVE_388_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peaking gain setting.
            GAIN: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x388);

        /// address: 0x560438c
        /// TV Encoder Low Pass Gain Control Register
        pub const TVE_38C_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Gain control: large gain limitation.
            BETA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Gain control: limitation threshold.
            DIF_UP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x38c);

        /// address: 0x5604390
        /// TV Encoder Low Pass Shoot Control Register
        pub const TVE_390_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Undershoot gain control.
            NEG_GAIN: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x390);

        /// address: 0x5604394
        /// TV Encoder Low Pass Coring Register
        pub const TVE_394_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Coring threshold.
            CORTHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x394);

        /// address: 0x56043a0
        /// TV Encoder Noise Reduction Register
        pub const TVE_3A0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            T_VALUE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x3a0);
    };

    /// TCON_TV0
    pub const TCON_TV0 = struct {
        pub const base_address = 0x5470000;

        /// address: 0x5470094
        /// TV Basic Timing Register0
        pub const TV_BASIC0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Source Height Is Y+1
            HEIGHT_YI: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Source Width Is X+1
            WIDTH_XI: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x94);

        /// address: 0x5470098
        /// TV Basic Timing Register1
        pub const TV_BASIC1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Width Is LS_YO+1 Note: This version LS_YO = TV_YI
            LS_YO: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Width Is LS_XO+1
            LS_XO: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x98);

        /// address: 0x547009c
        /// TV Basic Timing Register2
        pub const TV_BASIC2_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Height is TV_YO+1
            TV_YO: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Width is TV_XO+1
            TV_XO: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x9c);

        /// address: 0x54700a0
        /// TV Basic Timing Register3
        pub const TV_BASIC3_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Horizontal back porch Thbp = (HBP +1) * Thdclk
            H_BP: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Horizontal total time Thcycle = (HT+1) * Thdclk
            H_T: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xa0);

        /// address: 0x54700a4
        /// TV Basic Timing Register4
        pub const TV_BASIC4_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// horizontal back porch (in HD line) Tvbp = (VBP +1) * Th
            V_BP: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// horizontal total time (in HD line) Tvt = VT/2 * Th
            V_T: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xa4);

        /// address: 0x54700a8
        /// TV Basic Timing Register5
        pub const TV_BASIC5_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vertical Sync Pulse Width (in lines) Tvspw = (VSPW+1) * Th Note: VT/2 > (VSPW+1)
            V_SPW: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Horizontal Sync Pulse Width (in dclk) Thspw = (HSPW+1) * Tdclk Note: HT>
            /// (HSPW+1)
            H_SPW: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xa8);

        /// address: 0x5470110
        /// TV_CEU_COEF_MUL_REG[%s]
        pub const TV_CEU_COEF_MUL_REG = @intToPtr(*volatile [11]Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Note: 1.CEU_Coef_Mul_Value only can be 0 or 1. 2. REG Map: N=0: Rr N=1: Rg N=2:
            /// Rb N=4: Gr N=5: Gg N=6: Gb N=8: Br N=9: Bg N=10: Bb
            CEU_COEF_MUL_VALUE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x110);

        /// address: 0x5470100
        /// TV CEU Control Register
        pub const TV_CEU_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// CEU Enable
            /// 0: Bypass
            /// 1: Enable
            CEU_EN: u1,
        }), base_address + 0x100);

        /// address: 0x5470090
        /// TV Control Register
        pub const TV_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// TV Source Select
            /// 0: Reserved
            /// 1: BLUE data Note: The priority of this bit is higher than TV_SRC_SEL(bit[2:0])
            /// in TV_SRC_CTL_REG.
            TV_SRC_SEL: u1,
            reserved1: u1,
            reserved2: u1,
            /// This is for DE0 and DE1.
            START_DELAY: u5,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// When enable TCON_TV, this bit and the 0x0000[bit31] need to be enabled.
            /// 0: Disable
            /// 1: Enable
            TV_EN: u1,
        }), base_address + 0x90);

        /// address: 0x5470330
        /// TCON Data IO Polarity Control0
        pub const TV_DATA_IO_POL0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// G Y Channel Data Inv
            /// 0: normal polarity
            /// 1: invert the specify output
            G_Y_CH_DATA_INV: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// R CB Channel Data Inv
            /// 0: normal polarity
            /// 1: invert the specify output
            R_CB_CH_DATA_INV: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x330);

        /// address: 0x5470334
        /// TCON Data IO Polarity Control1
        pub const TV_DATA_IO_POL1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// B CR CHANNE DATA INV
            /// 0: Normal polarity
            /// 1: Invert the specify output
            B_CR_CH_DATA_INV: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x334);

        /// address: 0x5470338
        /// TCON Data IO Enable Control0
        pub const TV_DATA_IO_TRI0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// G Y Channel Data Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            G_Y_CH_DATA_OUT_TRI_EN: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// R CB Channel Data Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            R_CB_CH_DATA_OUT_TRI_EN: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x338);

        /// address: 0x547033c
        /// TCON Data IO Enable Control1
        pub const TV_DATA_IO_TRI1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// B CR Channel Data Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            B_CR_CH_DATA_OUT_TRI_EN: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x33c);

        /// address: 0x54700fc
        /// TV Debug Register
        pub const TV_DEBUG_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TV Current Line
            TV_CURRENT_LINE: u12,
            reserved0: u1,
            /// Line Buf fer Bypass
            /// 0: Used
            /// 1: Bypass
            LINE_BUF_BYPASS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TV Field Polarity
            /// 0: Second field
            /// 1: First field
            TV_FIELD_POL: u1,
            reserved15: u1,
            /// TV FIFO Underflow
            TV_FIFO_U: u1,
            padding0: u1,
        }), base_address + 0xfc);

        /// address: 0x5470300
        /// TV Fill Data Control Register
        pub const TV_FILL_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// TV Fill Enable
            /// 0: Bypass
            /// 1: Enable
            TV_FILL_EN: u1,
        }), base_address + 0x300);

        /// address: 0x5470000
        /// TV Global Control Register
        pub const TV_GCTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// CEC DDC PAD Select
            /// 1: TCON_TV internal pad for cec scl sal
            /// 0: GPIO pad for cec scl sal
            CEC_DDC_PAD_SEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// When it is disabled, the module will be reset to idle state.
            /// 0: Disable
            /// 1: Enable
            TV_EN: u1,
        }), base_address + 0x0);

        /// address: 0x5470004
        /// TV Global Interrupt Register0
        pub const TV_GINT0_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// TV Line Interrupt Flag Trigger when SY1 match the current TV scan line Write 0
            /// to clear it.
            TV_LINE_INT_FLAG: u1,
            reserved12: u1,
            /// TV Vb Interrupt Flag Asserted during vertical no-display period every frame.
            /// Write 0 to clear it.
            TV_VB_INT_FLAG: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// TV Line Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TV_LINE_INT_EN: u1,
            reserved26: u1,
            /// TV Vb Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            TV_VB_INT_EN: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x5470008
        /// TV Global Interrupt Register1
        pub const TV_GINT1_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scan line for TV line trigger(including inactive lines) Setting it for the
            /// specified line for trigger 1. Note: SY1 is writable only when LINE_TRG1 is
            /// disabled.
            TV_LINE_INT_NUM: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x5470088
        /// TV SYNC Signal Polarity Register
        pub const TV_IO_POL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// IO0 Invert
            /// 0: Not invert
            /// 1: Invert
            IO0_INV: u1,
            /// IO1 Invert
            /// 0: Not invert
            /// 1: Invert
            IO1_INV: u1,
            /// IO2 Invert
            /// 0: Not invert
            /// 1: Invert
            IO2_INV: u1,
            /// IO3 Invert
            /// 0: Not invert
            /// 1: Invert
            IO3_INV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x88);

        /// address: 0x547008c
        /// TV SYNC Signal IO Control Register
        pub const TV_IO_TRI_REG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// IO0 Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            IO0_OUTPUT_TRI_EN: u1,
            /// IO1 Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            IO1_OUTPUT_TRI_EN: u1,
            /// IO2 Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            IO2_OUTPUT_TRI_EN: u1,
            /// IO3 Output Trigger Enable
            /// 1: Disable
            /// 0: Enable
            IO3_OUTPUT_TRI_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x8c);

        /// address: 0x5470340
        /// TV Pixeldepth Mode Control Register
        pub const TV_PIXELDEPTH_MODE_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Colorbar Pixeldepth mode
            /// 0: 8 bit mode When data source is the embedded colorbar, the 8-bit colorbar
            /// pattern is transmitted.
            /// 1: 10 bit mode When data source is the embedded colorbar, the 10-bit colorbar
            /// pattern is transmitted.
            COLORBAR_PD_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x340);

        /// address: 0x54701f0
        /// TV Safe Period Register
        pub const TV_SAFE_PERIOD_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Safe Period Mode
            /// 000: unsafe
            /// 001: safe
            /// 010: safe at line_buf_curr_num > safe_period_fifo_num
            /// 011: safe at 2 and safe at sync active
            /// 100: safe at line
            SAFE_PERIOD_MODE: u3,
            reserved0: u1,
            /// Safe Period Line
            SAFE_PERIOD_LINE: u12,
            /// Safe Period FIFO Number
            SAFE_PERIOD_FIFO_NUM: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x1f0);

        /// address: 0x5470040
        /// TV Source Control Register
        pub const TV_SRC_CTL_REG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TV Source Select
            /// 000: DE
            /// 001: Color Check
            /// 010: Grayscale Check
            /// 011: Black by White Check
            /// 100: Reserved
            /// 101: Reserved
            /// 111: Gridding Check
            TV_SRC_SEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x40);
    };

    /// TWI0
    pub const TWI0 = struct {
        pub const base_address = 0x2502000;

        /// address: 0x2502000
        /// TWI Slave Address Register
        pub const TWI_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call Address Enable
            /// 0: Disable
            /// 1: Enable
            GCE: u1,
            /// Slave Address For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLA: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2502014
        /// TWI Clock Control Register
        pub const TWI_CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The TWI bus is sampled by the TWI at the frequency defined by F0: Fsamp = F0 =
            /// Fin/2^CLK_N The TWI SCL output frequency, in master mode, is F1/10: F1 =
            /// F0/(CLK_M + 1) Fscl = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce. For
            /// Example: Fin = 24 MHz (APB clock input) For 400 kHz full speed 2-wire, CLK_N =
            /// 1, CLK_M = 2 F0 = 24 MHz/2^1 = 12 MHz, F1 = F0/(10*(2+1)) = 0.4 MHz For 100 kHz
            /// standard speed 2-wire, CLK_N = 1, CLK_M = 11 F0 = 24 MHz/2^1 = 12 MHz, F1 =
            /// F0/(10*(11+1)) = 0.1 MHz
            CLK_N: u3,
            /// The TWI SCL output frequency, in master mode, is F1/10: F1 = F0/(CLK_M + 1) Fscl
            /// = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl = F1/11 when CLK_M=0
            /// and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// Setting duty cycle of clock as master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x250200c
        /// TWI Control Register
        pub const TWI_CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            reserved0: u1,
            /// Assert Acknowledge When A_ACK is set to ‘1’, an Acknowledge (low level on
            /// SDA) will be sent during the acknowledge clock pulse on the TWI bus if: (1).
            /// Either the whole of a matching 7-bit slave address or the first or the second
            /// byte of a matching 10-bit slave address has been received. (2). The general call
            /// address has been received and the GCE bit in the ADDR register is set to
            /// ‘1’. (3). A data byte has been received in master or slave mode. When A_ACK
            /// is ‘0’, a Not Acknowledge (high level on SDA) will be sent when a data byte
            /// is received in master or slave mode. If A_ACK is cleared to ‘0’ in slave
            /// transmitter mode, the byte in the DATA register is assumed to be the ‘last
            /// byte’. After this byte has been transmitted, the TWI will enter state C8h then
            /// return to the idle state (status code F8h) when INT_FLAG is cleared. The TWI
            /// will not respond as a slave unless A_ACK is set.
            A_ACK: u1,
            /// Interrupt Flag The INT_FLAG is automatically set to ‘1’ when any of the 28
            /// (out of the possible 29) states is entered (see ‘STAT Register’ below). The
            /// state that does not set INT_FLAG is state F8h. If the INT_EN bit is set, the
            /// interrupt line goes high when INT_FLAG is set to ‘1’. If the TWI is
            /// operating in slave mode, the data transfer is suspended when INT_FLAG is set and
            /// the low period of the TWI bus clock line (SCL) is stretched until ‘1’ is
            /// written to INT_FLAG. The TWI clock line is then released and the interrupt line
            /// goes low.
            INT_FLAG: u1,
            /// Master Mode Stop If the M_STP is set to ‘1’ in master mode, a STOP condition
            /// is transmitted on the TWI bus. If the M_STP bit is set to ‘1’ in slave mode,
            /// the TWI will indicate if a STOP condition has been received, but no STOP
            /// condition will be transmitted on the TWI bus. If both M_STA and M_STP bits are
            /// set, the TWI will first transmit the STOP condition (if in master mode), then
            /// transmit the START condition. The M_STP bit is cleared automatically. Writing a
            /// ‘0’ to this bit has no effect.
            M_STP: u1,
            /// Master Mode Start When the M_STA is set to ‘1’, the TWI controller enters
            /// master mode and will transmit a START condition on the bus when the bus is free.
            /// If the M_STA bit is set to ‘1’ when the TWI controller is already in master
            /// mode and one or more bytes have been transmitted, then a repeated START
            /// condition will be sent. If the M_STA bit is set to ‘1’ when the TWI is
            /// accessed in slave mode, the TWI will complete the data transfer in slave mode
            /// then enter master mode when the bus has been released. The M_STA bit is cleared
            /// automatically after a START condition has been sent. Writing a ‘0’ to this
            /// bit has no effect.
            M_STA: u1,
            /// TWI Bus Enable
            /// 0: The TWI bus SDA/SCL is ignored and the TWI controller will not respond to any
            /// address on the bus.
            /// 1: The TWI will respond to call to its slave address – and to the general call
            /// address if the GCE bit in the ADDR register is set.
            BUS_EN: u1,
            /// Interrupt Enable
            /// 0: The interrupt line always low
            /// 1: The interrupt line will go high when INT_FLAG is set.
            INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2502008
        /// TWI Data Byte Register
        pub const TWI_DATA = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

        /// address: 0x2502210
        /// TWI_DRV Bus Control Register
        pub const TWI_DRV_BUS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDA manual output enable
            SDA_MOE: u1,
            /// SCL manual output enable
            SCL_MOE: u1,
            /// SDA manual output value
            SDA_MOV: u1,
            /// SCL manual output value
            SCL_MOV: u1,
            reserved0: u1,
            reserved1: u1,
            /// SDA current status
            SDA_STA: u1,
            /// SCL current status
            SCL_STA: u1,
            /// TWI_DRV output SCL frequency is F =F1/10=(F0/(CLK_M+1))/10 Specially, Foscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// TWI_DRV bus sampling clock F0=24MHz/2^CLK_N
            CLK_N: u3,
            /// Setting duty cycle of clock as Master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            /// Clock count mode
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x210);

        /// address: 0x2502204
        /// TWI_DRV Transmission Configuration Register
        pub const TWI_DRV_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The FIFO data is transmitted as PACKET_CNT packets in current format.
            PACKET_CNT: u16,
            /// Define the interval between each packet for PKT_INTERVAL F cycles.
            PKT_INTERVAL: u16,
        }), base_address + 0x204);

        /// address: 0x2502200
        /// TWI_DRV Control Register
        pub const TWI_DRV_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI driver enable
            /// 0: Module disable
            /// 1: Module enable (only use in TWI Master Mode)
            TWI_DRV_EN: u1,
            /// Software reset
            /// 0: Normal
            /// 1: Reset
            SOFT_RESET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Timeout number When sending the 9 clock, assert fail signal when the slave
            /// device does not respond after N*F cycles. And the software must do a reset to
            /// the TWI_DRV module and send a stop condition to slave.
            TIMEOUT_N: u8,
            /// TWI status
            /// 0x00: bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK received
            /// 0x58: Data byte received in master mode, ACK not received
            /// 0x01: Timeout when sending the 9 SCL clock Other: Reserved
            TWI_STA: u8,
            /// Transition result
            /// 000: OK
            /// 001: FAIL Other: Reserved
            TRAN_RESULT: u4,
            /// Read transition mode
            /// 0: Send slave_id+W
            /// 1: Not send slave_id+W Setting this bit to 1 if reading from a slave in which
            /// the register width is equal to 0.
            READ_TRAN_MODE: u1,
            /// Restart mode
            /// 0: RESTART
            /// 1: STOP+START Define the TWI_DRV action after sending the register address.
            RESTART_MODE: u1,
            reserved6: u1,
            /// Start transmission
            /// 0: Transmission idle
            /// 1: Start transmission Automatically cleared to ‘0’ when finished. If the
            /// slave is not responding for the expected status over the time defined by
            /// TIMEOUT, the current transmission will stop. All setting formats and data will
            /// be loaded from registers and FIFO when the transmission starts.
            START_TRAN: u1,
        }), base_address + 0x200);

        /// address: 0x2502218
        /// TWI_DRV DMA Configure Register
        pub const TWI_DRV_DMA_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX trigger When DMA_TX_EN is set, send DMA TX Req when the space of SEND_FIFO
            /// (FIFO Level – data volume) reaches TX_TRIG.
            TX_TRIG: u6,
            reserved0: u1,
            reserved1: u1,
            /// DMA TX Enable
            DMA_TX_EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// RX trigger When DMA_RX_EN is set, send DMA RX Req when the data byte number in
            /// RECV_FIFO reaches RX_TRIG, or the read transmission is completed, the data of
            /// RECV_FIFO does not reach RX_TRIG but as long as the RECV_FIFO is not empty.
            RX_TRIG: u6,
            reserved9: u1,
            reserved10: u1,
            /// DMA RX Enable
            DMA_RX_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x218);

        /// address: 0x250221c
        /// TWI_DRV FIFO Content Register
        pub const TWI_DRV_FIFO_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// The number of data in SEND_FIFO
            SEND_FIFO_CONTENT: u6,
            /// Set this bit to clear SEND_FIFO pointer, and this bit is cleared automatically.
            SEND_FIFO_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// The number of data in RECV_FIFO
            RECV_FIFO_CONTENT: u6,
            /// Set this bit to clear RECV_FIFO pointer, and this bit is cleared automatically.
            RECV_FIFO_CLEAR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x21c);

        /// address: 0x250220c
        /// TWI_DRV Packet Format Register
        pub const TWI_DRV_FMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// How many bytes be sent/received as data 1~65535
            DATA_BYTE: u16,
            /// How many bytes be sent as slave device reg address 0~255
            ADDR_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x20c);

        /// address: 0x2502214
        /// TWI_DRV Interrupt Control Register
        pub const TWI_DRV_INT_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet transmission completion pending
            TRAN_COM_PD: u1,
            /// Packet transmission failure pending
            TRAN_ERR_PD: u1,
            /// Set when there is no less than DMA_TX_TRIG empty byte number in SEND_FIFO.
            TX_REQ_PD: u1,
            /// Set when the data byte number in RECV_FIFO reaches RX_TRIG.
            RX_REQ_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// If set, an interrupt is sent when TRAN_COM_PD sets.
            TRAN_COM_INT_EN: u1,
            /// If set, an interrupt is sent when TRAN_ERR_PD sets.
            TRAN_ERR_INT_EN: u1,
            /// If set, an interrupt is sent when TX_REQ_PD sets.
            TX_REQ_INT_EN: u1,
            /// If set, an interrupt is sent when RX_REQ_PD sets.
            RX_REQ_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x214);

        /// address: 0x2502304
        /// TWI_DRV_RECV_FIFO_ACC
        pub const TWI_DRV_RECV_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 RECV_FIFO, which stores data received from the slave device.
            RECV_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x2502300
        /// TWI_DRV_SEND_FIFO_ACC
        pub const TWI_DRV_SEND_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 SEND_FIFO, which stores reg address and data sending to the
            /// slave device.
            SEND_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x2502208
        /// TWI_DRV Slave ID Register
        pub const TWI_DRV_SLV = @intToPtr(*volatile Mmio(32, packed struct {
            /// SLAX[7:0] The low 8 bits for slave device ID with 10-bit addressing.
            SLV_ID_X: u8,
            /// R/W operation to slave device
            /// 0: Write
            /// 1: Read
            CMD: u1,
            /// Slave device ID For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLV_ID: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x208);

        /// address: 0x250201c
        /// TWI Enhance Feature Register
        pub const TWI_EFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Byte Number Follow Read Command Control
            /// 00: No data byte can be written after the read command
            /// 01: Only 1-byte data can be written after the read command
            /// 10: 2-bytes data can be written after the read command
            /// 11: 3-bytes data can be written after the read command
            DBN: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1c);

        /// address: 0x2502020
        /// TWI Line Control Register
        pub const TWI_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI_SDA Line State Control Enable When this bit is set, the state of TWI_SDA is
            /// controlled by the value of bit[1].
            /// 0: Disable TWI_SDA line control mode
            /// 1: Enable TWI_SDA line control mode
            SDA_CTL_EN: u1,
            /// TWI_SDA Line State Control Bit When the line control mode is enabled (bit[0] is
            /// set), this bit decides the output level of TWI_SDA.
            /// 0: Output low level
            /// 1: Output high level
            SDA_CTL: u1,
            /// TWI_SCL Line State Control Enable When this bit is set, the state of TWI_SCL is
            /// controlled by the value of bit[3].
            /// 0: Disable TWI_SCL line control mode
            /// 1: Enable TWI_SCL line control mode
            SCL_CTL_EN: u1,
            /// TWI_SCL Line State Control Bit When the line control mode is enabled (bit[2] is
            /// set), this bit decides the output level of TWI_SCL.
            /// 0: Output low level
            /// 1: Output high level
            SCL_CTL: u1,
            /// Current State of TWI_SDA
            /// 0: Low
            /// 1: High
            SDA_STATE: u1,
            /// Current State of TWI_SCL
            /// 0: Low
            /// 1: High
            SCL_STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x20);

        /// address: 0x2502018
        /// TWI Software Reset Register
        pub const TWI_SRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Soft Reset Write ‘1’ to this bit to reset the TWI and clear to ‘0’ when
            /// completing Soft Reset operation.
            SOFT_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x2502010
        /// TWI Status Register
        pub const TWI_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status Information Byte Code Status
            /// 0x00: Bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK transmitted
            /// 0x58: Data byte received in master mode, not ACK transmitted
            /// 0x60: Slave address + Write bit received, ACK transmitted
            /// 0x68: Arbitration lost in the address as master, slave address + Write bit
            /// received, ACK transmitted
            /// 0x70: General Call address received, ACK transmitted
            /// 0x78: Arbitration lost in the address as master, General Call address received,
            /// ACK transmitted
            /// 0x80: Data byte received after slave address received, ACK transmitted
            /// 0x88: Data byte received after slave address received, not ACK transmitted
            /// 0x90: Data byte received after General Call received, ACK transmitted
            /// 0x98: Data byte received after General Call received, not ACK transmitted
            /// 0xA0: STOP or repeated START condition received in slave mode
            /// 0xA8: Slave address + Read bit received, ACK transmitted
            /// 0xB0: Arbitration lost in the address as master, slave address + Read bit
            /// received, ACK transmitted
            /// 0xB8: Data byte transmitted in slave mode, ACK received
            /// 0xC0: Data byte transmitted in slave mode, ACK not received
            /// 0xC8: The Last byte transmitted in slave mode, ACK received
            /// 0xD0: Second Address byte + Write bit transmitted, ACK received
            /// 0xD8: Second Address byte + Write bit transmitted, ACK not received
            /// 0xF8: No relevant status information, INT_FLAG=0 Others: Reserved
            STA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2502004
        /// TWI Extended Slave Address Register
        pub const TWI_XADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extend Slave Address SLAX[7:0]
            SLAX: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);
    };

    /// TWI1
    pub const TWI1 = struct {
        pub const base_address = 0x2502400;

        /// address: 0x2502400
        /// TWI Slave Address Register
        pub const TWI_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call Address Enable
            /// 0: Disable
            /// 1: Enable
            GCE: u1,
            /// Slave Address For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLA: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2502414
        /// TWI Clock Control Register
        pub const TWI_CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The TWI bus is sampled by the TWI at the frequency defined by F0: Fsamp = F0 =
            /// Fin/2^CLK_N The TWI SCL output frequency, in master mode, is F1/10: F1 =
            /// F0/(CLK_M + 1) Fscl = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce. For
            /// Example: Fin = 24 MHz (APB clock input) For 400 kHz full speed 2-wire, CLK_N =
            /// 1, CLK_M = 2 F0 = 24 MHz/2^1 = 12 MHz, F1 = F0/(10*(2+1)) = 0.4 MHz For 100 kHz
            /// standard speed 2-wire, CLK_N = 1, CLK_M = 11 F0 = 24 MHz/2^1 = 12 MHz, F1 =
            /// F0/(10*(11+1)) = 0.1 MHz
            CLK_N: u3,
            /// The TWI SCL output frequency, in master mode, is F1/10: F1 = F0/(CLK_M + 1) Fscl
            /// = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl = F1/11 when CLK_M=0
            /// and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// Setting duty cycle of clock as master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x250240c
        /// TWI Control Register
        pub const TWI_CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            reserved0: u1,
            /// Assert Acknowledge When A_ACK is set to ‘1’, an Acknowledge (low level on
            /// SDA) will be sent during the acknowledge clock pulse on the TWI bus if: (1).
            /// Either the whole of a matching 7-bit slave address or the first or the second
            /// byte of a matching 10-bit slave address has been received. (2). The general call
            /// address has been received and the GCE bit in the ADDR register is set to
            /// ‘1’. (3). A data byte has been received in master or slave mode. When A_ACK
            /// is ‘0’, a Not Acknowledge (high level on SDA) will be sent when a data byte
            /// is received in master or slave mode. If A_ACK is cleared to ‘0’ in slave
            /// transmitter mode, the byte in the DATA register is assumed to be the ‘last
            /// byte’. After this byte has been transmitted, the TWI will enter state C8h then
            /// return to the idle state (status code F8h) when INT_FLAG is cleared. The TWI
            /// will not respond as a slave unless A_ACK is set.
            A_ACK: u1,
            /// Interrupt Flag The INT_FLAG is automatically set to ‘1’ when any of the 28
            /// (out of the possible 29) states is entered (see ‘STAT Register’ below). The
            /// state that does not set INT_FLAG is state F8h. If the INT_EN bit is set, the
            /// interrupt line goes high when INT_FLAG is set to ‘1’. If the TWI is
            /// operating in slave mode, the data transfer is suspended when INT_FLAG is set and
            /// the low period of the TWI bus clock line (SCL) is stretched until ‘1’ is
            /// written to INT_FLAG. The TWI clock line is then released and the interrupt line
            /// goes low.
            INT_FLAG: u1,
            /// Master Mode Stop If the M_STP is set to ‘1’ in master mode, a STOP condition
            /// is transmitted on the TWI bus. If the M_STP bit is set to ‘1’ in slave mode,
            /// the TWI will indicate if a STOP condition has been received, but no STOP
            /// condition will be transmitted on the TWI bus. If both M_STA and M_STP bits are
            /// set, the TWI will first transmit the STOP condition (if in master mode), then
            /// transmit the START condition. The M_STP bit is cleared automatically. Writing a
            /// ‘0’ to this bit has no effect.
            M_STP: u1,
            /// Master Mode Start When the M_STA is set to ‘1’, the TWI controller enters
            /// master mode and will transmit a START condition on the bus when the bus is free.
            /// If the M_STA bit is set to ‘1’ when the TWI controller is already in master
            /// mode and one or more bytes have been transmitted, then a repeated START
            /// condition will be sent. If the M_STA bit is set to ‘1’ when the TWI is
            /// accessed in slave mode, the TWI will complete the data transfer in slave mode
            /// then enter master mode when the bus has been released. The M_STA bit is cleared
            /// automatically after a START condition has been sent. Writing a ‘0’ to this
            /// bit has no effect.
            M_STA: u1,
            /// TWI Bus Enable
            /// 0: The TWI bus SDA/SCL is ignored and the TWI controller will not respond to any
            /// address on the bus.
            /// 1: The TWI will respond to call to its slave address – and to the general call
            /// address if the GCE bit in the ADDR register is set.
            BUS_EN: u1,
            /// Interrupt Enable
            /// 0: The interrupt line always low
            /// 1: The interrupt line will go high when INT_FLAG is set.
            INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2502408
        /// TWI Data Byte Register
        pub const TWI_DATA = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

        /// address: 0x2502610
        /// TWI_DRV Bus Control Register
        pub const TWI_DRV_BUS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDA manual output enable
            SDA_MOE: u1,
            /// SCL manual output enable
            SCL_MOE: u1,
            /// SDA manual output value
            SDA_MOV: u1,
            /// SCL manual output value
            SCL_MOV: u1,
            reserved0: u1,
            reserved1: u1,
            /// SDA current status
            SDA_STA: u1,
            /// SCL current status
            SCL_STA: u1,
            /// TWI_DRV output SCL frequency is F =F1/10=(F0/(CLK_M+1))/10 Specially, Foscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// TWI_DRV bus sampling clock F0=24MHz/2^CLK_N
            CLK_N: u3,
            /// Setting duty cycle of clock as Master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            /// Clock count mode
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x210);

        /// address: 0x2502604
        /// TWI_DRV Transmission Configuration Register
        pub const TWI_DRV_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The FIFO data is transmitted as PACKET_CNT packets in current format.
            PACKET_CNT: u16,
            /// Define the interval between each packet for PKT_INTERVAL F cycles.
            PKT_INTERVAL: u16,
        }), base_address + 0x204);

        /// address: 0x2502600
        /// TWI_DRV Control Register
        pub const TWI_DRV_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI driver enable
            /// 0: Module disable
            /// 1: Module enable (only use in TWI Master Mode)
            TWI_DRV_EN: u1,
            /// Software reset
            /// 0: Normal
            /// 1: Reset
            SOFT_RESET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Timeout number When sending the 9 clock, assert fail signal when the slave
            /// device does not respond after N*F cycles. And the software must do a reset to
            /// the TWI_DRV module and send a stop condition to slave.
            TIMEOUT_N: u8,
            /// TWI status
            /// 0x00: bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK received
            /// 0x58: Data byte received in master mode, ACK not received
            /// 0x01: Timeout when sending the 9 SCL clock Other: Reserved
            TWI_STA: u8,
            /// Transition result
            /// 000: OK
            /// 001: FAIL Other: Reserved
            TRAN_RESULT: u4,
            /// Read transition mode
            /// 0: Send slave_id+W
            /// 1: Not send slave_id+W Setting this bit to 1 if reading from a slave in which
            /// the register width is equal to 0.
            READ_TRAN_MODE: u1,
            /// Restart mode
            /// 0: RESTART
            /// 1: STOP+START Define the TWI_DRV action after sending the register address.
            RESTART_MODE: u1,
            reserved6: u1,
            /// Start transmission
            /// 0: Transmission idle
            /// 1: Start transmission Automatically cleared to ‘0’ when finished. If the
            /// slave is not responding for the expected status over the time defined by
            /// TIMEOUT, the current transmission will stop. All setting formats and data will
            /// be loaded from registers and FIFO when the transmission starts.
            START_TRAN: u1,
        }), base_address + 0x200);

        /// address: 0x2502618
        /// TWI_DRV DMA Configure Register
        pub const TWI_DRV_DMA_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX trigger When DMA_TX_EN is set, send DMA TX Req when the space of SEND_FIFO
            /// (FIFO Level – data volume) reaches TX_TRIG.
            TX_TRIG: u6,
            reserved0: u1,
            reserved1: u1,
            /// DMA TX Enable
            DMA_TX_EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// RX trigger When DMA_RX_EN is set, send DMA RX Req when the data byte number in
            /// RECV_FIFO reaches RX_TRIG, or the read transmission is completed, the data of
            /// RECV_FIFO does not reach RX_TRIG but as long as the RECV_FIFO is not empty.
            RX_TRIG: u6,
            reserved9: u1,
            reserved10: u1,
            /// DMA RX Enable
            DMA_RX_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x218);

        /// address: 0x250261c
        /// TWI_DRV FIFO Content Register
        pub const TWI_DRV_FIFO_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// The number of data in SEND_FIFO
            SEND_FIFO_CONTENT: u6,
            /// Set this bit to clear SEND_FIFO pointer, and this bit is cleared automatically.
            SEND_FIFO_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// The number of data in RECV_FIFO
            RECV_FIFO_CONTENT: u6,
            /// Set this bit to clear RECV_FIFO pointer, and this bit is cleared automatically.
            RECV_FIFO_CLEAR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x21c);

        /// address: 0x250260c
        /// TWI_DRV Packet Format Register
        pub const TWI_DRV_FMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// How many bytes be sent/received as data 1~65535
            DATA_BYTE: u16,
            /// How many bytes be sent as slave device reg address 0~255
            ADDR_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x20c);

        /// address: 0x2502614
        /// TWI_DRV Interrupt Control Register
        pub const TWI_DRV_INT_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet transmission completion pending
            TRAN_COM_PD: u1,
            /// Packet transmission failure pending
            TRAN_ERR_PD: u1,
            /// Set when there is no less than DMA_TX_TRIG empty byte number in SEND_FIFO.
            TX_REQ_PD: u1,
            /// Set when the data byte number in RECV_FIFO reaches RX_TRIG.
            RX_REQ_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// If set, an interrupt is sent when TRAN_COM_PD sets.
            TRAN_COM_INT_EN: u1,
            /// If set, an interrupt is sent when TRAN_ERR_PD sets.
            TRAN_ERR_INT_EN: u1,
            /// If set, an interrupt is sent when TX_REQ_PD sets.
            TX_REQ_INT_EN: u1,
            /// If set, an interrupt is sent when RX_REQ_PD sets.
            RX_REQ_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x214);

        /// address: 0x2502704
        /// TWI_DRV_RECV_FIFO_ACC
        pub const TWI_DRV_RECV_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 RECV_FIFO, which stores data received from the slave device.
            RECV_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x2502700
        /// TWI_DRV_SEND_FIFO_ACC
        pub const TWI_DRV_SEND_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 SEND_FIFO, which stores reg address and data sending to the
            /// slave device.
            SEND_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x2502608
        /// TWI_DRV Slave ID Register
        pub const TWI_DRV_SLV = @intToPtr(*volatile Mmio(32, packed struct {
            /// SLAX[7:0] The low 8 bits for slave device ID with 10-bit addressing.
            SLV_ID_X: u8,
            /// R/W operation to slave device
            /// 0: Write
            /// 1: Read
            CMD: u1,
            /// Slave device ID For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLV_ID: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x208);

        /// address: 0x250241c
        /// TWI Enhance Feature Register
        pub const TWI_EFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Byte Number Follow Read Command Control
            /// 00: No data byte can be written after the read command
            /// 01: Only 1-byte data can be written after the read command
            /// 10: 2-bytes data can be written after the read command
            /// 11: 3-bytes data can be written after the read command
            DBN: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1c);

        /// address: 0x2502420
        /// TWI Line Control Register
        pub const TWI_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI_SDA Line State Control Enable When this bit is set, the state of TWI_SDA is
            /// controlled by the value of bit[1].
            /// 0: Disable TWI_SDA line control mode
            /// 1: Enable TWI_SDA line control mode
            SDA_CTL_EN: u1,
            /// TWI_SDA Line State Control Bit When the line control mode is enabled (bit[0] is
            /// set), this bit decides the output level of TWI_SDA.
            /// 0: Output low level
            /// 1: Output high level
            SDA_CTL: u1,
            /// TWI_SCL Line State Control Enable When this bit is set, the state of TWI_SCL is
            /// controlled by the value of bit[3].
            /// 0: Disable TWI_SCL line control mode
            /// 1: Enable TWI_SCL line control mode
            SCL_CTL_EN: u1,
            /// TWI_SCL Line State Control Bit When the line control mode is enabled (bit[2] is
            /// set), this bit decides the output level of TWI_SCL.
            /// 0: Output low level
            /// 1: Output high level
            SCL_CTL: u1,
            /// Current State of TWI_SDA
            /// 0: Low
            /// 1: High
            SDA_STATE: u1,
            /// Current State of TWI_SCL
            /// 0: Low
            /// 1: High
            SCL_STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x20);

        /// address: 0x2502418
        /// TWI Software Reset Register
        pub const TWI_SRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Soft Reset Write ‘1’ to this bit to reset the TWI and clear to ‘0’ when
            /// completing Soft Reset operation.
            SOFT_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x2502410
        /// TWI Status Register
        pub const TWI_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status Information Byte Code Status
            /// 0x00: Bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK transmitted
            /// 0x58: Data byte received in master mode, not ACK transmitted
            /// 0x60: Slave address + Write bit received, ACK transmitted
            /// 0x68: Arbitration lost in the address as master, slave address + Write bit
            /// received, ACK transmitted
            /// 0x70: General Call address received, ACK transmitted
            /// 0x78: Arbitration lost in the address as master, General Call address received,
            /// ACK transmitted
            /// 0x80: Data byte received after slave address received, ACK transmitted
            /// 0x88: Data byte received after slave address received, not ACK transmitted
            /// 0x90: Data byte received after General Call received, ACK transmitted
            /// 0x98: Data byte received after General Call received, not ACK transmitted
            /// 0xA0: STOP or repeated START condition received in slave mode
            /// 0xA8: Slave address + Read bit received, ACK transmitted
            /// 0xB0: Arbitration lost in the address as master, slave address + Read bit
            /// received, ACK transmitted
            /// 0xB8: Data byte transmitted in slave mode, ACK received
            /// 0xC0: Data byte transmitted in slave mode, ACK not received
            /// 0xC8: The Last byte transmitted in slave mode, ACK received
            /// 0xD0: Second Address byte + Write bit transmitted, ACK received
            /// 0xD8: Second Address byte + Write bit transmitted, ACK not received
            /// 0xF8: No relevant status information, INT_FLAG=0 Others: Reserved
            STA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2502404
        /// TWI Extended Slave Address Register
        pub const TWI_XADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extend Slave Address SLAX[7:0]
            SLAX: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);
    };

    /// TWI2
    pub const TWI2 = struct {
        pub const base_address = 0x2502800;

        /// address: 0x2502800
        /// TWI Slave Address Register
        pub const TWI_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call Address Enable
            /// 0: Disable
            /// 1: Enable
            GCE: u1,
            /// Slave Address For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLA: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2502814
        /// TWI Clock Control Register
        pub const TWI_CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The TWI bus is sampled by the TWI at the frequency defined by F0: Fsamp = F0 =
            /// Fin/2^CLK_N The TWI SCL output frequency, in master mode, is F1/10: F1 =
            /// F0/(CLK_M + 1) Fscl = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce. For
            /// Example: Fin = 24 MHz (APB clock input) For 400 kHz full speed 2-wire, CLK_N =
            /// 1, CLK_M = 2 F0 = 24 MHz/2^1 = 12 MHz, F1 = F0/(10*(2+1)) = 0.4 MHz For 100 kHz
            /// standard speed 2-wire, CLK_N = 1, CLK_M = 11 F0 = 24 MHz/2^1 = 12 MHz, F1 =
            /// F0/(10*(11+1)) = 0.1 MHz
            CLK_N: u3,
            /// The TWI SCL output frequency, in master mode, is F1/10: F1 = F0/(CLK_M + 1) Fscl
            /// = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl = F1/11 when CLK_M=0
            /// and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// Setting duty cycle of clock as master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x250280c
        /// TWI Control Register
        pub const TWI_CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            reserved0: u1,
            /// Assert Acknowledge When A_ACK is set to ‘1’, an Acknowledge (low level on
            /// SDA) will be sent during the acknowledge clock pulse on the TWI bus if: (1).
            /// Either the whole of a matching 7-bit slave address or the first or the second
            /// byte of a matching 10-bit slave address has been received. (2). The general call
            /// address has been received and the GCE bit in the ADDR register is set to
            /// ‘1’. (3). A data byte has been received in master or slave mode. When A_ACK
            /// is ‘0’, a Not Acknowledge (high level on SDA) will be sent when a data byte
            /// is received in master or slave mode. If A_ACK is cleared to ‘0’ in slave
            /// transmitter mode, the byte in the DATA register is assumed to be the ‘last
            /// byte’. After this byte has been transmitted, the TWI will enter state C8h then
            /// return to the idle state (status code F8h) when INT_FLAG is cleared. The TWI
            /// will not respond as a slave unless A_ACK is set.
            A_ACK: u1,
            /// Interrupt Flag The INT_FLAG is automatically set to ‘1’ when any of the 28
            /// (out of the possible 29) states is entered (see ‘STAT Register’ below). The
            /// state that does not set INT_FLAG is state F8h. If the INT_EN bit is set, the
            /// interrupt line goes high when INT_FLAG is set to ‘1’. If the TWI is
            /// operating in slave mode, the data transfer is suspended when INT_FLAG is set and
            /// the low period of the TWI bus clock line (SCL) is stretched until ‘1’ is
            /// written to INT_FLAG. The TWI clock line is then released and the interrupt line
            /// goes low.
            INT_FLAG: u1,
            /// Master Mode Stop If the M_STP is set to ‘1’ in master mode, a STOP condition
            /// is transmitted on the TWI bus. If the M_STP bit is set to ‘1’ in slave mode,
            /// the TWI will indicate if a STOP condition has been received, but no STOP
            /// condition will be transmitted on the TWI bus. If both M_STA and M_STP bits are
            /// set, the TWI will first transmit the STOP condition (if in master mode), then
            /// transmit the START condition. The M_STP bit is cleared automatically. Writing a
            /// ‘0’ to this bit has no effect.
            M_STP: u1,
            /// Master Mode Start When the M_STA is set to ‘1’, the TWI controller enters
            /// master mode and will transmit a START condition on the bus when the bus is free.
            /// If the M_STA bit is set to ‘1’ when the TWI controller is already in master
            /// mode and one or more bytes have been transmitted, then a repeated START
            /// condition will be sent. If the M_STA bit is set to ‘1’ when the TWI is
            /// accessed in slave mode, the TWI will complete the data transfer in slave mode
            /// then enter master mode when the bus has been released. The M_STA bit is cleared
            /// automatically after a START condition has been sent. Writing a ‘0’ to this
            /// bit has no effect.
            M_STA: u1,
            /// TWI Bus Enable
            /// 0: The TWI bus SDA/SCL is ignored and the TWI controller will not respond to any
            /// address on the bus.
            /// 1: The TWI will respond to call to its slave address – and to the general call
            /// address if the GCE bit in the ADDR register is set.
            BUS_EN: u1,
            /// Interrupt Enable
            /// 0: The interrupt line always low
            /// 1: The interrupt line will go high when INT_FLAG is set.
            INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2502808
        /// TWI Data Byte Register
        pub const TWI_DATA = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

        /// address: 0x2502a10
        /// TWI_DRV Bus Control Register
        pub const TWI_DRV_BUS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDA manual output enable
            SDA_MOE: u1,
            /// SCL manual output enable
            SCL_MOE: u1,
            /// SDA manual output value
            SDA_MOV: u1,
            /// SCL manual output value
            SCL_MOV: u1,
            reserved0: u1,
            reserved1: u1,
            /// SDA current status
            SDA_STA: u1,
            /// SCL current status
            SCL_STA: u1,
            /// TWI_DRV output SCL frequency is F =F1/10=(F0/(CLK_M+1))/10 Specially, Foscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// TWI_DRV bus sampling clock F0=24MHz/2^CLK_N
            CLK_N: u3,
            /// Setting duty cycle of clock as Master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            /// Clock count mode
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x210);

        /// address: 0x2502a04
        /// TWI_DRV Transmission Configuration Register
        pub const TWI_DRV_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The FIFO data is transmitted as PACKET_CNT packets in current format.
            PACKET_CNT: u16,
            /// Define the interval between each packet for PKT_INTERVAL F cycles.
            PKT_INTERVAL: u16,
        }), base_address + 0x204);

        /// address: 0x2502a00
        /// TWI_DRV Control Register
        pub const TWI_DRV_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI driver enable
            /// 0: Module disable
            /// 1: Module enable (only use in TWI Master Mode)
            TWI_DRV_EN: u1,
            /// Software reset
            /// 0: Normal
            /// 1: Reset
            SOFT_RESET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Timeout number When sending the 9 clock, assert fail signal when the slave
            /// device does not respond after N*F cycles. And the software must do a reset to
            /// the TWI_DRV module and send a stop condition to slave.
            TIMEOUT_N: u8,
            /// TWI status
            /// 0x00: bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK received
            /// 0x58: Data byte received in master mode, ACK not received
            /// 0x01: Timeout when sending the 9 SCL clock Other: Reserved
            TWI_STA: u8,
            /// Transition result
            /// 000: OK
            /// 001: FAIL Other: Reserved
            TRAN_RESULT: u4,
            /// Read transition mode
            /// 0: Send slave_id+W
            /// 1: Not send slave_id+W Setting this bit to 1 if reading from a slave in which
            /// the register width is equal to 0.
            READ_TRAN_MODE: u1,
            /// Restart mode
            /// 0: RESTART
            /// 1: STOP+START Define the TWI_DRV action after sending the register address.
            RESTART_MODE: u1,
            reserved6: u1,
            /// Start transmission
            /// 0: Transmission idle
            /// 1: Start transmission Automatically cleared to ‘0’ when finished. If the
            /// slave is not responding for the expected status over the time defined by
            /// TIMEOUT, the current transmission will stop. All setting formats and data will
            /// be loaded from registers and FIFO when the transmission starts.
            START_TRAN: u1,
        }), base_address + 0x200);

        /// address: 0x2502a18
        /// TWI_DRV DMA Configure Register
        pub const TWI_DRV_DMA_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX trigger When DMA_TX_EN is set, send DMA TX Req when the space of SEND_FIFO
            /// (FIFO Level – data volume) reaches TX_TRIG.
            TX_TRIG: u6,
            reserved0: u1,
            reserved1: u1,
            /// DMA TX Enable
            DMA_TX_EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// RX trigger When DMA_RX_EN is set, send DMA RX Req when the data byte number in
            /// RECV_FIFO reaches RX_TRIG, or the read transmission is completed, the data of
            /// RECV_FIFO does not reach RX_TRIG but as long as the RECV_FIFO is not empty.
            RX_TRIG: u6,
            reserved9: u1,
            reserved10: u1,
            /// DMA RX Enable
            DMA_RX_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x218);

        /// address: 0x2502a1c
        /// TWI_DRV FIFO Content Register
        pub const TWI_DRV_FIFO_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// The number of data in SEND_FIFO
            SEND_FIFO_CONTENT: u6,
            /// Set this bit to clear SEND_FIFO pointer, and this bit is cleared automatically.
            SEND_FIFO_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// The number of data in RECV_FIFO
            RECV_FIFO_CONTENT: u6,
            /// Set this bit to clear RECV_FIFO pointer, and this bit is cleared automatically.
            RECV_FIFO_CLEAR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x21c);

        /// address: 0x2502a0c
        /// TWI_DRV Packet Format Register
        pub const TWI_DRV_FMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// How many bytes be sent/received as data 1~65535
            DATA_BYTE: u16,
            /// How many bytes be sent as slave device reg address 0~255
            ADDR_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x20c);

        /// address: 0x2502a14
        /// TWI_DRV Interrupt Control Register
        pub const TWI_DRV_INT_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet transmission completion pending
            TRAN_COM_PD: u1,
            /// Packet transmission failure pending
            TRAN_ERR_PD: u1,
            /// Set when there is no less than DMA_TX_TRIG empty byte number in SEND_FIFO.
            TX_REQ_PD: u1,
            /// Set when the data byte number in RECV_FIFO reaches RX_TRIG.
            RX_REQ_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// If set, an interrupt is sent when TRAN_COM_PD sets.
            TRAN_COM_INT_EN: u1,
            /// If set, an interrupt is sent when TRAN_ERR_PD sets.
            TRAN_ERR_INT_EN: u1,
            /// If set, an interrupt is sent when TX_REQ_PD sets.
            TX_REQ_INT_EN: u1,
            /// If set, an interrupt is sent when RX_REQ_PD sets.
            RX_REQ_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x214);

        /// address: 0x2502b04
        /// TWI_DRV_RECV_FIFO_ACC
        pub const TWI_DRV_RECV_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 RECV_FIFO, which stores data received from the slave device.
            RECV_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x2502b00
        /// TWI_DRV_SEND_FIFO_ACC
        pub const TWI_DRV_SEND_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 SEND_FIFO, which stores reg address and data sending to the
            /// slave device.
            SEND_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x2502a08
        /// TWI_DRV Slave ID Register
        pub const TWI_DRV_SLV = @intToPtr(*volatile Mmio(32, packed struct {
            /// SLAX[7:0] The low 8 bits for slave device ID with 10-bit addressing.
            SLV_ID_X: u8,
            /// R/W operation to slave device
            /// 0: Write
            /// 1: Read
            CMD: u1,
            /// Slave device ID For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLV_ID: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x208);

        /// address: 0x250281c
        /// TWI Enhance Feature Register
        pub const TWI_EFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Byte Number Follow Read Command Control
            /// 00: No data byte can be written after the read command
            /// 01: Only 1-byte data can be written after the read command
            /// 10: 2-bytes data can be written after the read command
            /// 11: 3-bytes data can be written after the read command
            DBN: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1c);

        /// address: 0x2502820
        /// TWI Line Control Register
        pub const TWI_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI_SDA Line State Control Enable When this bit is set, the state of TWI_SDA is
            /// controlled by the value of bit[1].
            /// 0: Disable TWI_SDA line control mode
            /// 1: Enable TWI_SDA line control mode
            SDA_CTL_EN: u1,
            /// TWI_SDA Line State Control Bit When the line control mode is enabled (bit[0] is
            /// set), this bit decides the output level of TWI_SDA.
            /// 0: Output low level
            /// 1: Output high level
            SDA_CTL: u1,
            /// TWI_SCL Line State Control Enable When this bit is set, the state of TWI_SCL is
            /// controlled by the value of bit[3].
            /// 0: Disable TWI_SCL line control mode
            /// 1: Enable TWI_SCL line control mode
            SCL_CTL_EN: u1,
            /// TWI_SCL Line State Control Bit When the line control mode is enabled (bit[2] is
            /// set), this bit decides the output level of TWI_SCL.
            /// 0: Output low level
            /// 1: Output high level
            SCL_CTL: u1,
            /// Current State of TWI_SDA
            /// 0: Low
            /// 1: High
            SDA_STATE: u1,
            /// Current State of TWI_SCL
            /// 0: Low
            /// 1: High
            SCL_STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x20);

        /// address: 0x2502818
        /// TWI Software Reset Register
        pub const TWI_SRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Soft Reset Write ‘1’ to this bit to reset the TWI and clear to ‘0’ when
            /// completing Soft Reset operation.
            SOFT_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x2502810
        /// TWI Status Register
        pub const TWI_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status Information Byte Code Status
            /// 0x00: Bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK transmitted
            /// 0x58: Data byte received in master mode, not ACK transmitted
            /// 0x60: Slave address + Write bit received, ACK transmitted
            /// 0x68: Arbitration lost in the address as master, slave address + Write bit
            /// received, ACK transmitted
            /// 0x70: General Call address received, ACK transmitted
            /// 0x78: Arbitration lost in the address as master, General Call address received,
            /// ACK transmitted
            /// 0x80: Data byte received after slave address received, ACK transmitted
            /// 0x88: Data byte received after slave address received, not ACK transmitted
            /// 0x90: Data byte received after General Call received, ACK transmitted
            /// 0x98: Data byte received after General Call received, not ACK transmitted
            /// 0xA0: STOP or repeated START condition received in slave mode
            /// 0xA8: Slave address + Read bit received, ACK transmitted
            /// 0xB0: Arbitration lost in the address as master, slave address + Read bit
            /// received, ACK transmitted
            /// 0xB8: Data byte transmitted in slave mode, ACK received
            /// 0xC0: Data byte transmitted in slave mode, ACK not received
            /// 0xC8: The Last byte transmitted in slave mode, ACK received
            /// 0xD0: Second Address byte + Write bit transmitted, ACK received
            /// 0xD8: Second Address byte + Write bit transmitted, ACK not received
            /// 0xF8: No relevant status information, INT_FLAG=0 Others: Reserved
            STA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2502804
        /// TWI Extended Slave Address Register
        pub const TWI_XADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extend Slave Address SLAX[7:0]
            SLAX: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);
    };

    /// TWI3
    pub const TWI3 = struct {
        pub const base_address = 0x2502c00;

        /// address: 0x2502c00
        /// TWI Slave Address Register
        pub const TWI_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// General Call Address Enable
            /// 0: Disable
            /// 1: Enable
            GCE: u1,
            /// Slave Address For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLA: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2502c14
        /// TWI Clock Control Register
        pub const TWI_CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The TWI bus is sampled by the TWI at the frequency defined by F0: Fsamp = F0 =
            /// Fin/2^CLK_N The TWI SCL output frequency, in master mode, is F1/10: F1 =
            /// F0/(CLK_M + 1) Fscl = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce. For
            /// Example: Fin = 24 MHz (APB clock input) For 400 kHz full speed 2-wire, CLK_N =
            /// 1, CLK_M = 2 F0 = 24 MHz/2^1 = 12 MHz, F1 = F0/(10*(2+1)) = 0.4 MHz For 100 kHz
            /// standard speed 2-wire, CLK_N = 1, CLK_M = 11 F0 = 24 MHz/2^1 = 12 MHz, F1 =
            /// F0/(10*(11+1)) = 0.1 MHz
            CLK_N: u3,
            /// The TWI SCL output frequency, in master mode, is F1/10: F1 = F0/(CLK_M + 1) Fscl
            /// = F1/10 = Fin/(2^CLK_N * (CLK_M + 1)*10) Specially, Fscl = F1/11 when CLK_M=0
            /// and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// Setting duty cycle of clock as master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2502c0c
        /// TWI Control Register
        pub const TWI_CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            reserved0: u1,
            /// Assert Acknowledge When A_ACK is set to ‘1’, an Acknowledge (low level on
            /// SDA) will be sent during the acknowledge clock pulse on the TWI bus if: (1).
            /// Either the whole of a matching 7-bit slave address or the first or the second
            /// byte of a matching 10-bit slave address has been received. (2). The general call
            /// address has been received and the GCE bit in the ADDR register is set to
            /// ‘1’. (3). A data byte has been received in master or slave mode. When A_ACK
            /// is ‘0’, a Not Acknowledge (high level on SDA) will be sent when a data byte
            /// is received in master or slave mode. If A_ACK is cleared to ‘0’ in slave
            /// transmitter mode, the byte in the DATA register is assumed to be the ‘last
            /// byte’. After this byte has been transmitted, the TWI will enter state C8h then
            /// return to the idle state (status code F8h) when INT_FLAG is cleared. The TWI
            /// will not respond as a slave unless A_ACK is set.
            A_ACK: u1,
            /// Interrupt Flag The INT_FLAG is automatically set to ‘1’ when any of the 28
            /// (out of the possible 29) states is entered (see ‘STAT Register’ below). The
            /// state that does not set INT_FLAG is state F8h. If the INT_EN bit is set, the
            /// interrupt line goes high when INT_FLAG is set to ‘1’. If the TWI is
            /// operating in slave mode, the data transfer is suspended when INT_FLAG is set and
            /// the low period of the TWI bus clock line (SCL) is stretched until ‘1’ is
            /// written to INT_FLAG. The TWI clock line is then released and the interrupt line
            /// goes low.
            INT_FLAG: u1,
            /// Master Mode Stop If the M_STP is set to ‘1’ in master mode, a STOP condition
            /// is transmitted on the TWI bus. If the M_STP bit is set to ‘1’ in slave mode,
            /// the TWI will indicate if a STOP condition has been received, but no STOP
            /// condition will be transmitted on the TWI bus. If both M_STA and M_STP bits are
            /// set, the TWI will first transmit the STOP condition (if in master mode), then
            /// transmit the START condition. The M_STP bit is cleared automatically. Writing a
            /// ‘0’ to this bit has no effect.
            M_STP: u1,
            /// Master Mode Start When the M_STA is set to ‘1’, the TWI controller enters
            /// master mode and will transmit a START condition on the bus when the bus is free.
            /// If the M_STA bit is set to ‘1’ when the TWI controller is already in master
            /// mode and one or more bytes have been transmitted, then a repeated START
            /// condition will be sent. If the M_STA bit is set to ‘1’ when the TWI is
            /// accessed in slave mode, the TWI will complete the data transfer in slave mode
            /// then enter master mode when the bus has been released. The M_STA bit is cleared
            /// automatically after a START condition has been sent. Writing a ‘0’ to this
            /// bit has no effect.
            M_STA: u1,
            /// TWI Bus Enable
            /// 0: The TWI bus SDA/SCL is ignored and the TWI controller will not respond to any
            /// address on the bus.
            /// 1: The TWI will respond to call to its slave address – and to the general call
            /// address if the GCE bit in the ADDR register is set.
            BUS_EN: u1,
            /// Interrupt Enable
            /// 0: The interrupt line always low
            /// 1: The interrupt line will go high when INT_FLAG is set.
            INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2502c08
        /// TWI Data Byte Register
        pub const TWI_DATA = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x8);

        /// address: 0x2502e10
        /// TWI_DRV Bus Control Register
        pub const TWI_DRV_BUS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// SDA manual output enable
            SDA_MOE: u1,
            /// SCL manual output enable
            SCL_MOE: u1,
            /// SDA manual output value
            SDA_MOV: u1,
            /// SCL manual output value
            SCL_MOV: u1,
            reserved0: u1,
            reserved1: u1,
            /// SDA current status
            SDA_STA: u1,
            /// SCL current status
            SCL_STA: u1,
            /// TWI_DRV output SCL frequency is F =F1/10=(F0/(CLK_M+1))/10 Specially, Foscl =
            /// F1/11 when CLK_M=0 and CLK_DUTY=40% due to the delay of SCL sample debounce.
            CLK_M: u4,
            /// TWI_DRV bus sampling clock F0=24MHz/2^CLK_N
            CLK_N: u3,
            /// Setting duty cycle of clock as Master
            /// 0: 50%
            /// 1: 40%
            CLK_DUTY: u1,
            /// Clock count mode
            /// 0: scl clock high period count on oscl
            /// 1: scl clock high period count on iscl
            CLK_COUNT_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x210);

        /// address: 0x2502e04
        /// TWI_DRV Transmission Configuration Register
        pub const TWI_DRV_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The FIFO data is transmitted as PACKET_CNT packets in current format.
            PACKET_CNT: u16,
            /// Define the interval between each packet for PKT_INTERVAL F cycles.
            PKT_INTERVAL: u16,
        }), base_address + 0x204);

        /// address: 0x2502e00
        /// TWI_DRV Control Register
        pub const TWI_DRV_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI driver enable
            /// 0: Module disable
            /// 1: Module enable (only use in TWI Master Mode)
            TWI_DRV_EN: u1,
            /// Software reset
            /// 0: Normal
            /// 1: Reset
            SOFT_RESET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Timeout number When sending the 9 clock, assert fail signal when the slave
            /// device does not respond after N*F cycles. And the software must do a reset to
            /// the TWI_DRV module and send a stop condition to slave.
            TIMEOUT_N: u8,
            /// TWI status
            /// 0x00: bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK received
            /// 0x58: Data byte received in master mode, ACK not received
            /// 0x01: Timeout when sending the 9 SCL clock Other: Reserved
            TWI_STA: u8,
            /// Transition result
            /// 000: OK
            /// 001: FAIL Other: Reserved
            TRAN_RESULT: u4,
            /// Read transition mode
            /// 0: Send slave_id+W
            /// 1: Not send slave_id+W Setting this bit to 1 if reading from a slave in which
            /// the register width is equal to 0.
            READ_TRAN_MODE: u1,
            /// Restart mode
            /// 0: RESTART
            /// 1: STOP+START Define the TWI_DRV action after sending the register address.
            RESTART_MODE: u1,
            reserved6: u1,
            /// Start transmission
            /// 0: Transmission idle
            /// 1: Start transmission Automatically cleared to ‘0’ when finished. If the
            /// slave is not responding for the expected status over the time defined by
            /// TIMEOUT, the current transmission will stop. All setting formats and data will
            /// be loaded from registers and FIFO when the transmission starts.
            START_TRAN: u1,
        }), base_address + 0x200);

        /// address: 0x2502e18
        /// TWI_DRV DMA Configure Register
        pub const TWI_DRV_DMA_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX trigger When DMA_TX_EN is set, send DMA TX Req when the space of SEND_FIFO
            /// (FIFO Level – data volume) reaches TX_TRIG.
            TX_TRIG: u6,
            reserved0: u1,
            reserved1: u1,
            /// DMA TX Enable
            DMA_TX_EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// RX trigger When DMA_RX_EN is set, send DMA RX Req when the data byte number in
            /// RECV_FIFO reaches RX_TRIG, or the read transmission is completed, the data of
            /// RECV_FIFO does not reach RX_TRIG but as long as the RECV_FIFO is not empty.
            RX_TRIG: u6,
            reserved9: u1,
            reserved10: u1,
            /// DMA RX Enable
            DMA_RX_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x218);

        /// address: 0x2502e1c
        /// TWI_DRV FIFO Content Register
        pub const TWI_DRV_FIFO_CON = @intToPtr(*volatile Mmio(32, packed struct {
            /// The number of data in SEND_FIFO
            SEND_FIFO_CONTENT: u6,
            /// Set this bit to clear SEND_FIFO pointer, and this bit is cleared automatically.
            SEND_FIFO_CLEAR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// The number of data in RECV_FIFO
            RECV_FIFO_CONTENT: u6,
            /// Set this bit to clear RECV_FIFO pointer, and this bit is cleared automatically.
            RECV_FIFO_CLEAR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x21c);

        /// address: 0x2502e0c
        /// TWI_DRV Packet Format Register
        pub const TWI_DRV_FMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// How many bytes be sent/received as data 1~65535
            DATA_BYTE: u16,
            /// How many bytes be sent as slave device reg address 0~255
            ADDR_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x20c);

        /// address: 0x2502e14
        /// TWI_DRV Interrupt Control Register
        pub const TWI_DRV_INT_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet transmission completion pending
            TRAN_COM_PD: u1,
            /// Packet transmission failure pending
            TRAN_ERR_PD: u1,
            /// Set when there is no less than DMA_TX_TRIG empty byte number in SEND_FIFO.
            TX_REQ_PD: u1,
            /// Set when the data byte number in RECV_FIFO reaches RX_TRIG.
            RX_REQ_PD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// If set, an interrupt is sent when TRAN_COM_PD sets.
            TRAN_COM_INT_EN: u1,
            /// If set, an interrupt is sent when TRAN_ERR_PD sets.
            TRAN_ERR_INT_EN: u1,
            /// If set, an interrupt is sent when TX_REQ_PD sets.
            TX_REQ_INT_EN: u1,
            /// If set, an interrupt is sent when RX_REQ_PD sets.
            RX_REQ_INT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x214);

        /// address: 0x2502f04
        /// TWI_DRV_RECV_FIFO_ACC
        pub const TWI_DRV_RECV_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 RECV_FIFO, which stores data received from the slave device.
            RECV_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x304);

        /// address: 0x2502f00
        /// TWI_DRV_SEND_FIFO_ACC
        pub const TWI_DRV_SEND_FIFO_ACC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address of a 32x8 SEND_FIFO, which stores reg address and data sending to the
            /// slave device.
            SEND_DATA_FIFO: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x300);

        /// address: 0x2502e08
        /// TWI_DRV Slave ID Register
        pub const TWI_DRV_SLV = @intToPtr(*volatile Mmio(32, packed struct {
            /// SLAX[7:0] The low 8 bits for slave device ID with 10-bit addressing.
            SLV_ID_X: u8,
            /// R/W operation to slave device
            /// 0: Write
            /// 1: Read
            CMD: u1,
            /// Slave device ID For 7-bit addressing, the bit[7:1] indicates: SLA6, SLA5, SLA4,
            /// SLA3, SLA2, SLA1, SLA0 For 10-bit addressing, the bit[7:1] indicates: 1, 1, 1,
            /// 1, 0, SLAX[9:8]
            SLV_ID: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x208);

        /// address: 0x2502c1c
        /// TWI Enhance Feature Register
        pub const TWI_EFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Byte Number Follow Read Command Control
            /// 00: No data byte can be written after the read command
            /// 01: Only 1-byte data can be written after the read command
            /// 10: 2-bytes data can be written after the read command
            /// 11: 3-bytes data can be written after the read command
            DBN: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1c);

        /// address: 0x2502c20
        /// TWI Line Control Register
        pub const TWI_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TWI_SDA Line State Control Enable When this bit is set, the state of TWI_SDA is
            /// controlled by the value of bit[1].
            /// 0: Disable TWI_SDA line control mode
            /// 1: Enable TWI_SDA line control mode
            SDA_CTL_EN: u1,
            /// TWI_SDA Line State Control Bit When the line control mode is enabled (bit[0] is
            /// set), this bit decides the output level of TWI_SDA.
            /// 0: Output low level
            /// 1: Output high level
            SDA_CTL: u1,
            /// TWI_SCL Line State Control Enable When this bit is set, the state of TWI_SCL is
            /// controlled by the value of bit[3].
            /// 0: Disable TWI_SCL line control mode
            /// 1: Enable TWI_SCL line control mode
            SCL_CTL_EN: u1,
            /// TWI_SCL Line State Control Bit When the line control mode is enabled (bit[2] is
            /// set), this bit decides the output level of TWI_SCL.
            /// 0: Output low level
            /// 1: Output high level
            SCL_CTL: u1,
            /// Current State of TWI_SDA
            /// 0: Low
            /// 1: High
            SDA_STATE: u1,
            /// Current State of TWI_SCL
            /// 0: Low
            /// 1: High
            SCL_STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x20);

        /// address: 0x2502c18
        /// TWI Software Reset Register
        pub const TWI_SRST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Soft Reset Write ‘1’ to this bit to reset the TWI and clear to ‘0’ when
            /// completing Soft Reset operation.
            SOFT_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x2502c10
        /// TWI Status Register
        pub const TWI_STAT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status Information Byte Code Status
            /// 0x00: Bus error
            /// 0x08: START condition transmitted
            /// 0x10: Repeated START condition transmitted
            /// 0x18: Address + Write bit transmitted, ACK received
            /// 0x20: Address + Write bit transmitted, ACK not received
            /// 0x28: Data byte transmitted in master mode, ACK received
            /// 0x30: Data byte transmitted in master mode, ACK not received
            /// 0x38: Arbitration lost in address or data byte
            /// 0x40: Address + Read bit transmitted, ACK received
            /// 0x48: Address + Read bit transmitted, ACK not received
            /// 0x50: Data byte received in master mode, ACK transmitted
            /// 0x58: Data byte received in master mode, not ACK transmitted
            /// 0x60: Slave address + Write bit received, ACK transmitted
            /// 0x68: Arbitration lost in the address as master, slave address + Write bit
            /// received, ACK transmitted
            /// 0x70: General Call address received, ACK transmitted
            /// 0x78: Arbitration lost in the address as master, General Call address received,
            /// ACK transmitted
            /// 0x80: Data byte received after slave address received, ACK transmitted
            /// 0x88: Data byte received after slave address received, not ACK transmitted
            /// 0x90: Data byte received after General Call received, ACK transmitted
            /// 0x98: Data byte received after General Call received, not ACK transmitted
            /// 0xA0: STOP or repeated START condition received in slave mode
            /// 0xA8: Slave address + Read bit received, ACK transmitted
            /// 0xB0: Arbitration lost in the address as master, slave address + Read bit
            /// received, ACK transmitted
            /// 0xB8: Data byte transmitted in slave mode, ACK received
            /// 0xC0: Data byte transmitted in slave mode, ACK not received
            /// 0xC8: The Last byte transmitted in slave mode, ACK received
            /// 0xD0: Second Address byte + Write bit transmitted, ACK received
            /// 0xD8: Second Address byte + Write bit transmitted, ACK not received
            /// 0xF8: No relevant status information, INT_FLAG=0 Others: Reserved
            STA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2502c04
        /// TWI Extended Slave Address Register
        pub const TWI_XADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extend Slave Address SLAX[7:0]
            SLAX: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);
    };

    /// UART0
    pub const UART0 = struct {
        pub const base_address = 0x2500000;

        /// address: 0x25000b4
        /// UART Debug DLH Register
        pub const UART_DBG_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLH
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x25000b0
        /// UART Debug DLL Register
        pub const UART_DBG_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLL
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x2500004
        /// UART Divisor Latch High Register
        pub const UART_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch High Upper 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( [7]) is set and the UART is not busy ( [0] is 0). The output
            /// baud rate is equal to the serial clock (SCLK) frequency divided by sixteen times
            /// the value of the baud rate divisor, as follows: . Note that when the Divisor
            /// Latch Registers ( and ) is set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLH is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500000
        /// UART Divisor Latch Low Register
        pub const UART_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch Low Lower 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( ) is set and the UART is not busy ( is 0). The output baud
            /// rate is equal to the serial clock (SCLK) frequency divided by sixteen times the
            /// value of the baud rate divisor, as follows: . Note that when the Divisor Latch
            /// Registers ( and ) are set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLL is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250008c
        /// UART DMA Request Enable Register
        pub const UART_DMA_REQ_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA RX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_RX_REQ_ENABLE: u1,
            /// DMA TX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TX_REQ_ENABLE: u1,
            /// DMA Timeout Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TIMEOUT_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8c);

        /// address: 0x25000f0
        /// UART_FCC
        pub const UART_FCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            RX: u1,
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            TX: u1,
            /// Clock Mode
            /// 0: Sync mode, writing/reading clocks use apb clock
            /// 1: Sync mode, writing clock uses apb clock, reading clock uses ahb clock
            RXFIFO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Depth Indicates the depth of TX/RX FIFO
            FIFO: u24,
        }), base_address + 0xf0);

        /// address: 0x2500008
        /// UART FIFO Control Register
        pub const UART_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable FIFOs The bit enables/disables the transmitting (XMIT) and receiving
            /// (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR
            /// controller part of FIFOs is reset.
            FIFOE: u1,
            /// RCVR FIFO Reset The bit resets the control part of the receive FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA RX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            RFIFOR: u1,
            /// XMIT FIFO Reset The bit resets the control part of the transfer FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA TX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            XFIFOR: u1,
            /// DMA Mode
            /// 0: Mode 0 In this mode, when the PTE in UART_HALT is high and TX FIFO is
            /// enabled, the TX DMA request will be set when the TFL in UART_TFL is less than or
            /// equal to FIFO Trigger Level (otherwise it will be cleared). When the PTE is high
            /// and TX FIFO is disabled, the TX DMA request will be set only if the THR in
            /// UART_THR is empty. If the PTE is low, the TX DMA request will be set only if the
            /// TX FIFO (TX FIFO enabled) or THR (TX FIFO disabled) is empty. When the
            /// DMA_PTE_RX in UART_HALT is high and RX FIFO is enabled, the RX DRQ will be set
            /// only if the RFL in UART_RFL is equal to or more than FIFO Trigger Level,
            /// otherwise, it will be cleared.
            /// 1: Mode 1 In this mode, TX FIFO should be enabled. If the PTE in is high, the TX
            /// DMA request will be set when the TFL in is less than or equal to FIFO Trigger
            /// Level; If the PTE is low, the TX DMA request will be set when TX FIFO is empty.
            /// Once the request is set, it is cleared only when TX FIFO is full. If the RFL in
            /// UART_RFL is equal to or more than FIFO Trigger Level or there is a character
            /// timeout, the RX DRQ will be set; Once the RX DRQ is set, it is cleared only when
            /// RX FIFO (RX FIFO enabled) or RBR (RX FIFO disabled) is empty.
            DMAM: u1,
            /// TX Empty Trigger This is used to select the empty threshold level when the THRE
            /// Interrupts are generated and the mode is active. It also determines when the
            /// dma_tx_req_n signal is asserted in certain modes of operation.
            /// 00: FIFO empty
            /// 01: 2 characters in the FIFO
            /// 10: FIFO ¼ full
            /// 11: FIFO ½ full
            TFT: u2,
            /// RCVR Trigger This is used to select the trigger level in the receiver FIFO when
            /// the Received Data Available Interrupt is generated. In the autoflow control
            /// mode, it is used to determine when the rts_n signal is de-asserted. It also
            /// determines when the dma_rx_req_n signal is asserted in certain modes of
            /// operation.
            /// 00: 1 character in the FIFO
            /// 01: FIFO ¼ full
            /// 10: FIFO ½ full
            /// 11: FIFO-2 less than full
            RT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x25000a4
        /// UART Halt TX Register
        pub const UART_HALT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Halt TX This register is used to halt transmissions for testing, so that the
            /// transmit FIFO can be filled by the master when FIFOs are implemented and
            /// enabled. 0 : Halt TX disabled 1 : Halt TX enabled
            HALT_TX: u1,
            /// This is an enable bit for the user to change LCR register configuration and baud
            /// rate register (UART_DLH and UART_DLL) when the UART is busy.
            /// 1: Enable change when busy
            CHCFG_AT_BUSY: u1,
            /// After the user uses UART_HALT[1] to change the baud rate or LCR configuration,
            /// write 1 to update the configuration and wait this bit to self-clear to 0 to
            /// finish update process. Writing 0 to this bit has no effect.
            /// 1: Update trigger, self-clear to 0 when finish update.
            CHANGE_UPDATE: u1,
            reserved0: u1,
            /// SIR TX Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            SIR_TX_INVERT: u1,
            /// SIR RX Pulse Polarity Invert
            /// 0: Not invert receiver signal
            /// 1: Invert receiver signal
            SIR_RX_INVERT: u1,
            /// The Transmission of RX_DRQ In DMA1 mode, when RFL is more than or equal to the
            /// trigger value, or a receive timeout has occurred, the controller sends DRQ. In
            /// DMA0 mode, when DMA_PTE_RX = 1 and FIFO is on, if RFL is more than or equal to
            /// trig, the controller sends DRQ, else DRQ is cleared. In other cases, once the
            /// received data is valid, the controller sends DRQ.
            DMA_PTE_RX: u1,
            /// The sending of TX_REQ In DMA1 mode (FIFO on), if the PTE is set to 1 when the
            /// TFL in UART_TFL is less than or equal to the trigger value, the controller sends
            /// the DMA request. If the PTE is set to 0, when FIFO is empty, the controller
            /// sends the DMA request. The DMA request will stop when FIFO is full. In DMA0
            /// mode, if the PTE is set to 1 and FIFO is on, when the TFL in UART_TFL is less
            /// than or equal to the trigger value, the controller sends DMA request. If the PTE
            /// is set to 1 and FIFO off, when the THR in UART_THR is empty, the controller
            /// sends DMA request. If the PTE is set to 0, when FIFO(FIFO Enable) or THR(FIFO
            /// Enable) is empty, the controller sends DMA request. Otherwise, the DMA request
            /// is cleared.
            PTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x2500088
        /// UART DMA Handshake Configuration Register
        pub const UART_HSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake configuration
            /// 0xA5: DMA wait cycle mode
            /// 0xE5: DMA handshake mode
            HANDSHAKE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x2500004
        /// UART Interrupt Enable Register
        pub const UART_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Received Data Available Interrupt This is used to enable/disable the
            /// generation of Received Data Available Interrupt and the Character Timeout
            /// Interrupt (if in FIFO mode and FIFOs enabled). These are the second-highest
            /// priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ERBFI: u1,
            /// Enable Transmit Holding Register Empty Interrupt This is used to enable/disable
            /// the generation of Transmitter Holding Register Empty Interrupt. This is the
            /// third-highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ETBEI: u1,
            /// Enable Receiver Line Status Interrupt This is used to enable/disable the
            /// generation of Receiver Line Status Interrupt. This is the highest priority
            /// interrupt.
            /// 0: Disable
            /// 1: Enable
            ELSI: u1,
            /// Enable Modem Status Interrupt This is used to enable/disable the generation of
            /// Modem Status Interrupt. This is the fourth highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            EDSSI: u1,
            /// RS485 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RS485_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Programmable THRE Interrupt Mode Enable This is used to enable/disable the
            /// generation of THRE Interrupt.
            /// 0: Disable
            /// 1: Enable
            PTIME: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500008
        /// UART Interrupt Identity Register
        pub const UART_IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID This indicates the highest priority pending interrupt which can be
            /// one of the following types.
            /// 0000: modem status
            /// 0001: no interrupt pending
            /// 0010: THR empty
            /// 0011: RS485 Interrupt
            /// 0100: received data available
            /// 0110: receiver line status
            /// 0111: busy detect
            /// 1100: character timeout The bit 3 indicates an interrupt can only occur when the
            /// FIFOs are enabled and used to distinguish a Character Timeout condition
            /// interrupt.
            IID: u4,
            reserved0: u1,
            reserved1: u1,
            /// FIFOs Enable Flag This is used to indicate whether the FIFOs are enabled or
            /// disabled.
            /// 00: Disable
            /// 11: Enable
            FEFLAG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x250000c
        /// UART Line Control Register
        pub const UART_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Length Select It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the count of bits in a transmitted
            /// or received frame.
            /// 00: 5 bits
            /// 01: 6 bits
            /// 10: 7 bits
            /// 11: 8 bits
            DLS: u2,
            /// Number of stop bits It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the number of stop bits per
            /// character that the peripheral transmits and receives. If set to 0, one stop bit
            /// is transmitted in the serial data. If set to 1 and the data bits are set to 5
            /// (UART_LCR[1:0] is 0), one and a half stop bit is transmitted. Otherwise, two
            /// stop bits are transmitted. Note that regardless of the number of stop bits
            /// selected, the receiver checks only the first stop bit.
            /// 0: 1 stop bit
            /// 1: 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit
            STOP: u1,
            /// Parity Enable It is writable only when UART is not busy (UART_USR[0] is 0) and
            /// always readable. This bit is used to enable and disable parity generation and
            /// detection in transmitted and received serial characters respectively.
            /// 0: Parity disabled
            /// 1: Parity enabled
            PEN: u1,
            /// Even Parity Select It is writable only when UART is not busy (UART_USR[0] is 0).
            /// This is used to select the even and odd parity when the PEN is enabled (the
            /// UART_LCR[3] is set to 1). Setting the UART_LCR[5] is unset to reverse the
            /// LCR[4].
            /// 00: Odd Parity
            /// 01: Even Parity 1X: Reverse LCR[4] In RS485 mode, it is the 9th bit--address
            /// bit.
            /// 11: 9th bit = 0, indicates that this is a data byte.
            /// 10: 9th bit = 1, indicates that this is an address byte.
            EPS: u2,
            /// Break Control Bit This is used to cause a break condition to be transmitted to
            /// the receiving device. If set to 0, the serial output is forced to the spacing
            /// (logic 0) state. When not in Loopback mode, as determined by UART_MCR[4], the
            /// SOUT line is forced low until the Break bit is cleared. If SIR_MODE is enabled
            /// and active (UART_MCR[6] is set to 1), the sir_out_n line is continuously pulsed.
            /// When in Loopback mode, the break condition is internally looped back to the
            /// receiver and the sir_out_n line is forced low.
            BC: u1,
            /// Divisor Latch Access Bit It is writable only when UART is not busy (UART_USR[0]
            /// is 0) and always readable. This bit is used to enable the reading and writing of
            /// the Divisor Latch register (UART_DLL and UART_DLH) to set the baud rate of the
            /// UART. This bit must be cleared after the initial baud rate setup in order to
            /// access other registers.
            /// 0: Select RX Buffer Register (UART_RBR)/TX Holding Register (UART_THR) and
            /// Interrupt Enable Register (UART_IER)
            /// 1: Select Divisor Latch LS Register (UART_DLL) and Divisor Latch MS Register
            /// (UART_DLM)
            DLAB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2500014
        /// UART Line Status Register
        pub const UART_LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready This is used to indicate that the receiver contains at least one
            /// character in the UART_RBR or the receiver FIFO.
            /// 0: no data ready
            /// 1: data ready This bit is cleared when the UART_RBR is read in non-FIFO mode, or
            /// when the receiver FIFO is empty, in FIFO mode.
            DR: u1,
            /// Overrun Error This occurs if a new data character was received before the
            /// previous data was read. In the non-FIFO mode, the OE bit is set when a new
            /// character arrives in the receiver before the previous character was read from
            /// the UART_RBR. When this happens, the data in the UART_RBR is overwritten. In the
            /// FIFO mode, an overrun error occurs when the FIFO is full and a new character
            /// arrives at the receiver. The data in the FIFO is retained and the data in the
            /// receive shift register is lost.
            /// 0: no overrun error
            /// 1: overrun error Reading the UART_LSR clears the OE bit.
            OE: u1,
            /// Parity Error This is used to indicate the occurrence of a parity error in the
            /// receiver if the Parity Enable (PEN) bit (UART_LCR[3]) is set. In the FIFO mode,
            /// since the parity error is associated with a character received, it is revealed
            /// when the character with the parity error arrives at the top of the FIFO. It
            /// should be noted that the Parity Error (PE) bit (UART_LSR[2]) is set if a break
            /// interrupt has occurred, as indicated by Break Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no parity error
            /// 1: parity error Reading the UART_LSR clears the PE bit.
            PE: u1,
            /// Framing Error This is used to indicate the occurrence of a framing error in the
            /// receiver. A framing error occurs when the receiver does not detect a valid STOP
            /// bit in the received data. In the FIFO mode, since the framing error is
            /// associated with a character received, it is revealed when the character with the
            /// framing error is at the top of the FIFO. When a framing error occurs, the UART
            /// tries to resynchronize. It does this by assuming that the error was due to the
            /// start bit of the next character and then continues receiving the other bit i.e.
            /// data, and/or parity and stop. It should be noted that the Framing Error (FE) bit
            /// (UART_LSR[3]) is set if a break interrupt has occurred, as indicated by Break
            /// Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no framing error
            /// 1: framing error Reading the UART_LSR clears the FE bit.
            FE: u1,
            /// Break Interrupt This is used to indicate the detection of a break sequence on
            /// the serial input data. If in UART mode (SIR_MODE == Disabled), it is set when
            /// the serial input, sir_in, is held in a logic '0' state for longer than the sum
            /// of + + + . If in infrared mode (SIR_MODE == Enabled), it is set when the serial
            /// input, sir_in, is continuously pulsed to logic '0' for longer than the sum of +
            /// + + . A break condition on serial input causes one and only one character,
            /// consisting of all zeros, to be received by the UART. In the FIFO mode, the
            /// character associated with the break condition is carried through the FIFO and is
            /// revealed when the character is at the top of the FIFO. Reading the UART_LSR
            /// clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately
            /// and persists until the UART_LSR is read.
            BI: u1,
            /// TX Holding Register Empty If the FIFOs are disabled, this bit is set to "1" when
            /// the TX Holding Register (UART_THR) is empty and ready to accept new data and it
            /// is cleared when the CPU writes to the TX Holding Register. If the FIFOs are
            /// enabled, this bit is set to "1" whenever the TX FIFO is empty and it is cleared
            /// when at least one byte is written to the TX FIFO.
            THRE: u1,
            /// Transmitter Empty If the FIFOs are disabled, this bit is set to "1" whenever the
            /// TX Holding Register (UART_THR) and the TX Shift Register are empty. If the FIFOs
            /// are enabled, this bit is set whenever the TX FIFO and the TX Shift Register are
            /// empty. In both cases, this bit is cleared when a byte is written to the TX data
            /// channel.
            TEMT: u1,
            /// RX Data Error in FIFO When FIFOs are disabled, this bit is always 0. When FIFOs
            /// are enabled, this bit is set to “1” when there is at least one PE, FE, or BI
            /// in the RX FIFO. It is cleared by reading from the UART_LSR register, there are
            /// no subsequent errors in the FIFO.
            FIFOERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2500010
        /// UART Modem Control Register
        pub const UART_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Terminal Ready This is used to directly control the Data Terminal Ready
            /// (dtr_n) output. The value written to this location is inverted and driven out on
            /// dtr_n.
            /// 0: dtr_n de-asserted (logic 1)
            /// 1: dtr_n asserted (logic 0) The DTR output is used to inform the modem or data
            /// set that the UART is ready to establish communications. Note that in Loopback
            /// mode (UART_MCR[4] is set to 1), the dtr_n output is held inactive high while the
            /// value of this location is internally looped back to an input.
            DTR: u1,
            /// Request to Send This is used to directly control the Request to Send (rts_n)
            /// output. The RTS (rts_n) output is used to inform the modem or data set that the
            /// UART is ready to exchange data. When Auto RTS Flow Control is not enabled ( is
            /// set to 0), the rts_n signal is set low by programming UART_MCR[1] (RTS) to a
            /// high. In Auto Flow Control, AFCE_MODE == Enabled and active ( is set to 1) and
            /// FIFOs enable (UART_FCR[0] is set to 1), the rts_n output is controlled in the
            /// same way, but is also gated with the receiver FIFO threshold trigger (rts_n is
            /// inactive high when above the threshold). The rts_n signal is de-asserted when
            /// UART_MCR[1] is set low.
            /// 0: rts_n de-asserted (logic 1)
            /// 1: rts_n asserted (logic 0) Note that in Loopback mode (UART_MCR[4] is set to
            /// 1), the rts_n output is held inactive high while the value of this location is
            /// internally looped back to an input.
            RTS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Loop Back Mode
            /// 0: Normal Mode
            /// 1: Loop Back Mode This is used to put the UART into a diagnostic mode for test
            /// purposes. If operating in UART mode (SIR_MODE != Enabled or not active,
            /// UART_MCR[6] is set to 0), the data on the SOUT line is held high, while serial
            /// data output is looped back to the sin line, internally. In this mode, all the
            /// interrupts are fully functional. Also, in loopback mode, the modem control
            /// inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control
            /// outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs,
            /// internally. If operating in infrared mode (SIR_MODE == Enabled AND active,
            /// UART_MCR[6] is set to 1), the data on the sir_out_n line is held low, while
            /// serial data output is inverted and looped back to the sir_in line.
            LOOP: u1,
            /// Auto Flow Control Enable When FIFOs are enabled and the AFCE bit is set, the
            /// AutoFlow Control is enabled.
            /// 0: Auto Flow Control mode disabled
            /// 1: Auto Flow Control mode enabled
            AFCE: u1,
            /// Select IrDA or RS485
            /// 00: UART Mode
            /// 01: IrDA SIR Mode
            /// 10: RS485 Mode
            /// 11: Reserved
            UART_FUNCTION: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2500018
        /// UART Modem Status Register
        pub const UART_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta Clear to Send This is used to indicate that the modem control line cts_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on ctsdsr_n since the last read of UART_MSR
            /// 1: change on ctsdsr_n since the last read of UART_MSR Reading the UART_MSR
            /// clears the DCTS bit. In Loopback Mode (UART_MCR[4] = 1), the DCTS reflects
            /// changes on the RTS (UART_MCR[1]).
            DCTS: u1,
            /// Delta Data Set Ready This is used to indicate that the modem control line dsr_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on dsr_n since the last read of UART_MSR
            /// 1: change on dsr_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDSR bit. In Loopback Mode (UART_MCR[4] = 1), the DDSR reflects changes on
            /// the DTR (UART_MCR[0] .
            DDSR: u1,
            /// Trailing Edge Ring Indicator This is used to indicate that a change in the input
            /// ri_n (from an active-low to an inactive-high state) has occurred since the last
            /// time the UART_MSR was read.
            /// 0: no change on ri_n since the last read of UART_MSR
            /// 1: change on ri_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the TERI bit.
            TERI: u1,
            /// Delta Data Carrier Detect This is used to indicate that the modem control line
            /// dcd_n has changed since the last time the UART_MSR was read.
            /// 0: no change on dcd_n since the last read of UART_MSR
            /// 1: change on dcd_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDCD bit.
            DDCD: u1,
            /// Line State of Clear To Send This is used to indicate the current state of the
            /// modem control line cts_n. This bit is the complement of cts_n. When the Clear to
            /// Send input (cts_n) is asserted, it is an indication that the modem or data set
            /// is ready to exchange data with UART.
            /// 0: cts_n input is de-asserted (logic 1)
            /// 1: cts_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] = 1), the CTS
            /// is the same as the RTS (UART_MCR[1]).
            CTS: u1,
            /// Line State of Data Set Ready This is used to indicate the current state of the
            /// modem control line dsr_n. This bit is the complement of the dsr_n. When the Data
            /// Set Ready input (dsr_n) is asserted, it is an indication that the modem or data
            /// set is ready to establish communication with UART.
            /// 0: dsr_n input is de-asserted (logic 1)
            /// 1: dsr_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] is set to 1),
            /// the DSR is the same as the DTR (UART_MCR[0]).
            DSR: u1,
            /// Line State of Ring Indicator This is used to indicate the current state of the
            /// modem control line ri_n. This bit is the complement of ri_n. When the Ring
            /// Indicator input (ri_n) is asserted it is an indication that a telephone ringing
            /// signal has been received by setting the modem or data.
            /// 0: ri_n input is de-asserted (logic 1)
            /// 1: ri_n input is asserted (logic 0)
            RI: u1,
            /// Line State of Data Carrier Detect This is used to indicate the current state of
            /// the modem control line dcd_n. This bit is the complement of dcd_n. When the Data
            /// Carrier Detect input (dcd_n) is asserted it is an indication that the carrier
            /// has been detected by the modem or data set.
            /// 0: dcd_n input is de-asserted (logic 1)
            /// 1: dcd_n input is asserted (logic 0)
            DCD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2500000
        /// UART Receive Buffer Register
        pub const UART_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Buffer Register Data byte received on the serial input port (sin) in
            /// UART mode, or the serial infrared input (sir_in) in infrared mode. The data in
            /// this register is valid only if the Data Ready (DR) bit in is set. If in FIFO
            /// mode and FIFOs are enabled (The [0] is set to 1), this register accesses the
            /// head of the receive FIFO. If the receive FIFO is full and this register can not
            /// read before the next data character arrives, then the data already in the FIFO
            /// are preserved, but any incoming data are lost and an overrun error occurs.
            RBR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2500084
        /// UART Receive FIFO Level Register
        pub const UART_RFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Level The bit indicates the number of data entries in the RX FIFO.
            /// UART_RXDMA_CTRL
            RFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x84);

        /// address: 0x2500118
        /// UART_RXDMA_BL
        pub const UART_RXDMA_BL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Length Unit is byte Note that this field is only configurable while RXDMA
            /// Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x2500100
        /// UART_RXDMA_CTRL
        pub const UART_RXDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            /// 0: RXDMA Disable
            /// 1: RXDMA Enable Note that if the software turns off this bit, the RXDMA will
            /// stop after the current block transfer completes, then the software should do a
            /// reset to the RX FIFO before re-enable.
            RXDMA: u1,
            /// Mode
            /// 0: Continous
            /// 1: Limited When data transferred reaches the limited count set in RXDMA LIMIT,
            /// the DMA stops and the RXDMA Start bit is cleared automatically. Note that this
            /// field is only configurable while RXDMA Busy is 0.
            RXDMA: u1,
            /// BLK SIZE Every time when data entries in RX FIFO reach BLK_SIZE, start a DMA
            /// block transfer. It is recommended that the block size no more than RX FIFO
            /// Depth.
            /// 00: 8 bytes
            /// 01: 16 bytes
            /// 10: 32 bytes
            /// 11: 64 bytes Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// AHB Burst Mode Set for AHB port burst supported INCR8 is recommended, while
            /// INCR16 may be unsupported due to the system bus.
            /// 00: SIGNLE
            /// 01: INCR4
            /// 10: INCR8
            /// 11: INCR16 Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// Timeout Enable Once enable, the DMA starts a transfer even the data entries in
            /// RX FIFO do not reach BLK_SIZE. Note that this field is only configurable when
            /// RXDMA Busy is 0.
            RXDMA: u1,
            reserved0: u1,
            /// Timeout Threshold Unit is 1 UART bit time Note that this field is only
            /// configurable when RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x2500138
        /// UART_RXDMA_DCNT
        pub const UART_RXDMA_DCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Count Only valid while RXDMA Mode is set to 1, it is used for counting the
            /// data transferred by RXDMA, and is cleared when reaches RXDMA Limit Size. Its
            /// unit is byte.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x2500120
        /// UART_RXDMA_IE
        pub const UART_RXDMA_IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done RXDMA Limit Done Interrupt Enable
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done RXDMA BLK Done Interrupt Enable
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done RXDMA Timeout Done Interrupt Enable
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun RXDMA Buffer Overrun Interrupt Enable
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x2500124
        /// UART_RXDMA_IS
        pub const UART_RXDMA_IS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done Asserted when data transferred reaches limit size in RXDMA
            /// Limit Mode.
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done Asserted when a DMA block transfer is done.
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done Asserted when a DMA transfer caused by timeout is done.
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun Asserted when the RXDMA buffer is overflow.
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x250010c
        /// UART_RXDMA_LMT
        pub const UART_RXDMA_LMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit Size Only valid when RXDMA Mode is set to 1, and the unit is byte. Note
            /// that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x2500134
        /// UART_RXDMA_RADDRH
        pub const UART_RXDMA_RADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[33:32] Software should update this register after reading
            /// data in RXDMA Buffer in time. It is byte address. The software should not update
            /// Buffer Read Address Register until until UART_RXDMA_STA[1] is 0. The software
            /// should update Read Address High Register first and then Read Address Low
            /// Register , even there is no change on Read Address High Register.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x2500130
        /// UART_RXDMA_RADDRL
        pub const UART_RXDMA_RADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[31:0] Software should update this register after reading
            /// data in RXDMA Buffer in time It is byte address. The software should not update
            /// Buffer Read Address Register until UART_RXDMA_STA[1] is 0. The software should
            /// update Read Address High Register first, and then Read Address Low Register,
            /// even there is no change on Read Address High Register.
            RXDMA: u32,
        }), base_address + 0x130);

        /// address: 0x2500114
        /// UART_RXDMA_SADDRH
        pub const UART_RXDMA_SADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [33:32] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x114);

        /// address: 0x2500110
        /// UART_RXDMA_SADDRL
        pub const UART_RXDMA_SADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [31:0] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u32,
        }), base_address + 0x110);

        /// address: 0x2500108
        /// UART_RXDMA_STA
        pub const UART_RXDMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// BUSY
            /// 0: RXDMA is idle
            /// 1: RXDMA is busy
            RXDMA: u1,
            /// Buffer Read Address Updating
            /// 0: Buffer Read Address Register is ready for updating
            /// 1: Buffer Read Address Register is busy for updating The software should not
            /// update Buffer Read Address Register until this bit is 0.
            BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x108);

        /// address: 0x2500104
        /// UART_RXDMA_STR
        pub const UART_RXDMA_STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Only valid when RXDMA mode is set to 1, it is auto cleared when data
            /// transferred reaches the RXDMA Limit Size.
            RXDMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x250012c
        /// UART_RXDMA_WADDRH
        pub const UART_RXDMA_WADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[33:32] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x12c);

        /// address: 0x2500128
        /// UART_RXDMA_WADDRL
        pub const UART_RXDMA_WADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[31:0] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u32,
        }), base_address + 0x128);

        /// address: 0x250001c
        /// UART Scratch Register
        pub const UART_SCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scratch Register This register is for programmers to use as a temporary storage
            /// space. It has no defined purpose in the UART.
            SCRATCH_REG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x2500080
        /// UART Transmit FIFO Level Register
        pub const UART_TFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Level The bit indicates the number of data entries in the TX FIFO.
            TFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x80);

        /// address: 0x2500000
        /// UART Transmit Holding Register
        pub const UART_THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Holding Register Data is transmitted on the serial output port (SOUT)
            /// in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data
            /// should only be written to the when the THRE bit ( ) is set. If in FIFO mode and
            /// FIFOs are enabled ( = 1) and THRE is set, the 16 number of characters data may
            /// be written to the before the FIFO is full. When the FIFO is full, any written
            /// data results in the written data being lost.
            THR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250007c
        /// UART Status Register
        pub const UART_USR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART Busy Bit
            /// 0: Idle or inactive
            /// 1: Busy
            BUSY: u1,
            /// TX FIFO Not Full This is used to indicate that the TX FIFO is not full.
            /// 0: TX FIFO is full
            /// 1: TX FIFO is not full This bit is cleared when the TX FIFO is full.
            TFNF: u1,
            /// TX FIFO Empty This is used to indicate that the TX FIFO is completely empty.
            /// 0: TX FIFO is not empty
            /// 1: TX FIFO is empty This bit is cleared when the TX FIFO is no longer empty.
            TFE: u1,
            /// RX FIFO Not Empty This is used to indicate that the RX FIFO contains one or more
            /// entries.
            /// 0: RX FIFO is empty
            /// 1: RX FIFO is not empty This bit is cleared when the RX FIFO is empty.
            RFNE: u1,
            /// RX FIFO Full This is used to indicate that the RX FIFO is completely full.
            /// 0: RX FIFO not full
            /// 1: RX FIFO Full This bit is cleared when the RX FIFO is no longer full.
            RFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);
    };

    /// UART1
    pub const UART1 = struct {
        pub const base_address = 0x2500400;

        /// address: 0x25004b4
        /// UART Debug DLH Register
        pub const UART_DBG_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLH
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x25004b0
        /// UART Debug DLL Register
        pub const UART_DBG_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLL
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x2500404
        /// UART Divisor Latch High Register
        pub const UART_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch High Upper 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( [7]) is set and the UART is not busy ( [0] is 0). The output
            /// baud rate is equal to the serial clock (SCLK) frequency divided by sixteen times
            /// the value of the baud rate divisor, as follows: . Note that when the Divisor
            /// Latch Registers ( and ) is set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLH is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500400
        /// UART Divisor Latch Low Register
        pub const UART_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch Low Lower 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( ) is set and the UART is not busy ( is 0). The output baud
            /// rate is equal to the serial clock (SCLK) frequency divided by sixteen times the
            /// value of the baud rate divisor, as follows: . Note that when the Divisor Latch
            /// Registers ( and ) are set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLL is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250048c
        /// UART DMA Request Enable Register
        pub const UART_DMA_REQ_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA RX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_RX_REQ_ENABLE: u1,
            /// DMA TX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TX_REQ_ENABLE: u1,
            /// DMA Timeout Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TIMEOUT_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8c);

        /// address: 0x25004f0
        /// UART_FCC
        pub const UART_FCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            RX: u1,
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            TX: u1,
            /// Clock Mode
            /// 0: Sync mode, writing/reading clocks use apb clock
            /// 1: Sync mode, writing clock uses apb clock, reading clock uses ahb clock
            RXFIFO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Depth Indicates the depth of TX/RX FIFO
            FIFO: u24,
        }), base_address + 0xf0);

        /// address: 0x2500408
        /// UART FIFO Control Register
        pub const UART_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable FIFOs The bit enables/disables the transmitting (XMIT) and receiving
            /// (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR
            /// controller part of FIFOs is reset.
            FIFOE: u1,
            /// RCVR FIFO Reset The bit resets the control part of the receive FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA RX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            RFIFOR: u1,
            /// XMIT FIFO Reset The bit resets the control part of the transfer FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA TX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            XFIFOR: u1,
            /// DMA Mode
            /// 0: Mode 0 In this mode, when the PTE in UART_HALT is high and TX FIFO is
            /// enabled, the TX DMA request will be set when the TFL in UART_TFL is less than or
            /// equal to FIFO Trigger Level (otherwise it will be cleared). When the PTE is high
            /// and TX FIFO is disabled, the TX DMA request will be set only if the THR in
            /// UART_THR is empty. If the PTE is low, the TX DMA request will be set only if the
            /// TX FIFO (TX FIFO enabled) or THR (TX FIFO disabled) is empty. When the
            /// DMA_PTE_RX in UART_HALT is high and RX FIFO is enabled, the RX DRQ will be set
            /// only if the RFL in UART_RFL is equal to or more than FIFO Trigger Level,
            /// otherwise, it will be cleared.
            /// 1: Mode 1 In this mode, TX FIFO should be enabled. If the PTE in is high, the TX
            /// DMA request will be set when the TFL in is less than or equal to FIFO Trigger
            /// Level; If the PTE is low, the TX DMA request will be set when TX FIFO is empty.
            /// Once the request is set, it is cleared only when TX FIFO is full. If the RFL in
            /// UART_RFL is equal to or more than FIFO Trigger Level or there is a character
            /// timeout, the RX DRQ will be set; Once the RX DRQ is set, it is cleared only when
            /// RX FIFO (RX FIFO enabled) or RBR (RX FIFO disabled) is empty.
            DMAM: u1,
            /// TX Empty Trigger This is used to select the empty threshold level when the THRE
            /// Interrupts are generated and the mode is active. It also determines when the
            /// dma_tx_req_n signal is asserted in certain modes of operation.
            /// 00: FIFO empty
            /// 01: 2 characters in the FIFO
            /// 10: FIFO ¼ full
            /// 11: FIFO ½ full
            TFT: u2,
            /// RCVR Trigger This is used to select the trigger level in the receiver FIFO when
            /// the Received Data Available Interrupt is generated. In the autoflow control
            /// mode, it is used to determine when the rts_n signal is de-asserted. It also
            /// determines when the dma_rx_req_n signal is asserted in certain modes of
            /// operation.
            /// 00: 1 character in the FIFO
            /// 01: FIFO ¼ full
            /// 10: FIFO ½ full
            /// 11: FIFO-2 less than full
            RT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x25004a4
        /// UART Halt TX Register
        pub const UART_HALT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Halt TX This register is used to halt transmissions for testing, so that the
            /// transmit FIFO can be filled by the master when FIFOs are implemented and
            /// enabled. 0 : Halt TX disabled 1 : Halt TX enabled
            HALT_TX: u1,
            /// This is an enable bit for the user to change LCR register configuration and baud
            /// rate register (UART_DLH and UART_DLL) when the UART is busy.
            /// 1: Enable change when busy
            CHCFG_AT_BUSY: u1,
            /// After the user uses UART_HALT[1] to change the baud rate or LCR configuration,
            /// write 1 to update the configuration and wait this bit to self-clear to 0 to
            /// finish update process. Writing 0 to this bit has no effect.
            /// 1: Update trigger, self-clear to 0 when finish update.
            CHANGE_UPDATE: u1,
            reserved0: u1,
            /// SIR TX Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            SIR_TX_INVERT: u1,
            /// SIR RX Pulse Polarity Invert
            /// 0: Not invert receiver signal
            /// 1: Invert receiver signal
            SIR_RX_INVERT: u1,
            /// The Transmission of RX_DRQ In DMA1 mode, when RFL is more than or equal to the
            /// trigger value, or a receive timeout has occurred, the controller sends DRQ. In
            /// DMA0 mode, when DMA_PTE_RX = 1 and FIFO is on, if RFL is more than or equal to
            /// trig, the controller sends DRQ, else DRQ is cleared. In other cases, once the
            /// received data is valid, the controller sends DRQ.
            DMA_PTE_RX: u1,
            /// The sending of TX_REQ In DMA1 mode (FIFO on), if the PTE is set to 1 when the
            /// TFL in UART_TFL is less than or equal to the trigger value, the controller sends
            /// the DMA request. If the PTE is set to 0, when FIFO is empty, the controller
            /// sends the DMA request. The DMA request will stop when FIFO is full. In DMA0
            /// mode, if the PTE is set to 1 and FIFO is on, when the TFL in UART_TFL is less
            /// than or equal to the trigger value, the controller sends DMA request. If the PTE
            /// is set to 1 and FIFO off, when the THR in UART_THR is empty, the controller
            /// sends DMA request. If the PTE is set to 0, when FIFO(FIFO Enable) or THR(FIFO
            /// Enable) is empty, the controller sends DMA request. Otherwise, the DMA request
            /// is cleared.
            PTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x2500488
        /// UART DMA Handshake Configuration Register
        pub const UART_HSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake configuration
            /// 0xA5: DMA wait cycle mode
            /// 0xE5: DMA handshake mode
            HANDSHAKE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x2500404
        /// UART Interrupt Enable Register
        pub const UART_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Received Data Available Interrupt This is used to enable/disable the
            /// generation of Received Data Available Interrupt and the Character Timeout
            /// Interrupt (if in FIFO mode and FIFOs enabled). These are the second-highest
            /// priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ERBFI: u1,
            /// Enable Transmit Holding Register Empty Interrupt This is used to enable/disable
            /// the generation of Transmitter Holding Register Empty Interrupt. This is the
            /// third-highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ETBEI: u1,
            /// Enable Receiver Line Status Interrupt This is used to enable/disable the
            /// generation of Receiver Line Status Interrupt. This is the highest priority
            /// interrupt.
            /// 0: Disable
            /// 1: Enable
            ELSI: u1,
            /// Enable Modem Status Interrupt This is used to enable/disable the generation of
            /// Modem Status Interrupt. This is the fourth highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            EDSSI: u1,
            /// RS485 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RS485_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Programmable THRE Interrupt Mode Enable This is used to enable/disable the
            /// generation of THRE Interrupt.
            /// 0: Disable
            /// 1: Enable
            PTIME: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500408
        /// UART Interrupt Identity Register
        pub const UART_IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID This indicates the highest priority pending interrupt which can be
            /// one of the following types.
            /// 0000: modem status
            /// 0001: no interrupt pending
            /// 0010: THR empty
            /// 0011: RS485 Interrupt
            /// 0100: received data available
            /// 0110: receiver line status
            /// 0111: busy detect
            /// 1100: character timeout The bit 3 indicates an interrupt can only occur when the
            /// FIFOs are enabled and used to distinguish a Character Timeout condition
            /// interrupt.
            IID: u4,
            reserved0: u1,
            reserved1: u1,
            /// FIFOs Enable Flag This is used to indicate whether the FIFOs are enabled or
            /// disabled.
            /// 00: Disable
            /// 11: Enable
            FEFLAG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x250040c
        /// UART Line Control Register
        pub const UART_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Length Select It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the count of bits in a transmitted
            /// or received frame.
            /// 00: 5 bits
            /// 01: 6 bits
            /// 10: 7 bits
            /// 11: 8 bits
            DLS: u2,
            /// Number of stop bits It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the number of stop bits per
            /// character that the peripheral transmits and receives. If set to 0, one stop bit
            /// is transmitted in the serial data. If set to 1 and the data bits are set to 5
            /// (UART_LCR[1:0] is 0), one and a half stop bit is transmitted. Otherwise, two
            /// stop bits are transmitted. Note that regardless of the number of stop bits
            /// selected, the receiver checks only the first stop bit.
            /// 0: 1 stop bit
            /// 1: 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit
            STOP: u1,
            /// Parity Enable It is writable only when UART is not busy (UART_USR[0] is 0) and
            /// always readable. This bit is used to enable and disable parity generation and
            /// detection in transmitted and received serial characters respectively.
            /// 0: Parity disabled
            /// 1: Parity enabled
            PEN: u1,
            /// Even Parity Select It is writable only when UART is not busy (UART_USR[0] is 0).
            /// This is used to select the even and odd parity when the PEN is enabled (the
            /// UART_LCR[3] is set to 1). Setting the UART_LCR[5] is unset to reverse the
            /// LCR[4].
            /// 00: Odd Parity
            /// 01: Even Parity 1X: Reverse LCR[4] In RS485 mode, it is the 9th bit--address
            /// bit.
            /// 11: 9th bit = 0, indicates that this is a data byte.
            /// 10: 9th bit = 1, indicates that this is an address byte.
            EPS: u2,
            /// Break Control Bit This is used to cause a break condition to be transmitted to
            /// the receiving device. If set to 0, the serial output is forced to the spacing
            /// (logic 0) state. When not in Loopback mode, as determined by UART_MCR[4], the
            /// SOUT line is forced low until the Break bit is cleared. If SIR_MODE is enabled
            /// and active (UART_MCR[6] is set to 1), the sir_out_n line is continuously pulsed.
            /// When in Loopback mode, the break condition is internally looped back to the
            /// receiver and the sir_out_n line is forced low.
            BC: u1,
            /// Divisor Latch Access Bit It is writable only when UART is not busy (UART_USR[0]
            /// is 0) and always readable. This bit is used to enable the reading and writing of
            /// the Divisor Latch register (UART_DLL and UART_DLH) to set the baud rate of the
            /// UART. This bit must be cleared after the initial baud rate setup in order to
            /// access other registers.
            /// 0: Select RX Buffer Register (UART_RBR)/TX Holding Register (UART_THR) and
            /// Interrupt Enable Register (UART_IER)
            /// 1: Select Divisor Latch LS Register (UART_DLL) and Divisor Latch MS Register
            /// (UART_DLM)
            DLAB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2500414
        /// UART Line Status Register
        pub const UART_LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready This is used to indicate that the receiver contains at least one
            /// character in the UART_RBR or the receiver FIFO.
            /// 0: no data ready
            /// 1: data ready This bit is cleared when the UART_RBR is read in non-FIFO mode, or
            /// when the receiver FIFO is empty, in FIFO mode.
            DR: u1,
            /// Overrun Error This occurs if a new data character was received before the
            /// previous data was read. In the non-FIFO mode, the OE bit is set when a new
            /// character arrives in the receiver before the previous character was read from
            /// the UART_RBR. When this happens, the data in the UART_RBR is overwritten. In the
            /// FIFO mode, an overrun error occurs when the FIFO is full and a new character
            /// arrives at the receiver. The data in the FIFO is retained and the data in the
            /// receive shift register is lost.
            /// 0: no overrun error
            /// 1: overrun error Reading the UART_LSR clears the OE bit.
            OE: u1,
            /// Parity Error This is used to indicate the occurrence of a parity error in the
            /// receiver if the Parity Enable (PEN) bit (UART_LCR[3]) is set. In the FIFO mode,
            /// since the parity error is associated with a character received, it is revealed
            /// when the character with the parity error arrives at the top of the FIFO. It
            /// should be noted that the Parity Error (PE) bit (UART_LSR[2]) is set if a break
            /// interrupt has occurred, as indicated by Break Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no parity error
            /// 1: parity error Reading the UART_LSR clears the PE bit.
            PE: u1,
            /// Framing Error This is used to indicate the occurrence of a framing error in the
            /// receiver. A framing error occurs when the receiver does not detect a valid STOP
            /// bit in the received data. In the FIFO mode, since the framing error is
            /// associated with a character received, it is revealed when the character with the
            /// framing error is at the top of the FIFO. When a framing error occurs, the UART
            /// tries to resynchronize. It does this by assuming that the error was due to the
            /// start bit of the next character and then continues receiving the other bit i.e.
            /// data, and/or parity and stop. It should be noted that the Framing Error (FE) bit
            /// (UART_LSR[3]) is set if a break interrupt has occurred, as indicated by Break
            /// Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no framing error
            /// 1: framing error Reading the UART_LSR clears the FE bit.
            FE: u1,
            /// Break Interrupt This is used to indicate the detection of a break sequence on
            /// the serial input data. If in UART mode (SIR_MODE == Disabled), it is set when
            /// the serial input, sir_in, is held in a logic '0' state for longer than the sum
            /// of + + + . If in infrared mode (SIR_MODE == Enabled), it is set when the serial
            /// input, sir_in, is continuously pulsed to logic '0' for longer than the sum of +
            /// + + . A break condition on serial input causes one and only one character,
            /// consisting of all zeros, to be received by the UART. In the FIFO mode, the
            /// character associated with the break condition is carried through the FIFO and is
            /// revealed when the character is at the top of the FIFO. Reading the UART_LSR
            /// clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately
            /// and persists until the UART_LSR is read.
            BI: u1,
            /// TX Holding Register Empty If the FIFOs are disabled, this bit is set to "1" when
            /// the TX Holding Register (UART_THR) is empty and ready to accept new data and it
            /// is cleared when the CPU writes to the TX Holding Register. If the FIFOs are
            /// enabled, this bit is set to "1" whenever the TX FIFO is empty and it is cleared
            /// when at least one byte is written to the TX FIFO.
            THRE: u1,
            /// Transmitter Empty If the FIFOs are disabled, this bit is set to "1" whenever the
            /// TX Holding Register (UART_THR) and the TX Shift Register are empty. If the FIFOs
            /// are enabled, this bit is set whenever the TX FIFO and the TX Shift Register are
            /// empty. In both cases, this bit is cleared when a byte is written to the TX data
            /// channel.
            TEMT: u1,
            /// RX Data Error in FIFO When FIFOs are disabled, this bit is always 0. When FIFOs
            /// are enabled, this bit is set to “1” when there is at least one PE, FE, or BI
            /// in the RX FIFO. It is cleared by reading from the UART_LSR register, there are
            /// no subsequent errors in the FIFO.
            FIFOERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2500410
        /// UART Modem Control Register
        pub const UART_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Terminal Ready This is used to directly control the Data Terminal Ready
            /// (dtr_n) output. The value written to this location is inverted and driven out on
            /// dtr_n.
            /// 0: dtr_n de-asserted (logic 1)
            /// 1: dtr_n asserted (logic 0) The DTR output is used to inform the modem or data
            /// set that the UART is ready to establish communications. Note that in Loopback
            /// mode (UART_MCR[4] is set to 1), the dtr_n output is held inactive high while the
            /// value of this location is internally looped back to an input.
            DTR: u1,
            /// Request to Send This is used to directly control the Request to Send (rts_n)
            /// output. The RTS (rts_n) output is used to inform the modem or data set that the
            /// UART is ready to exchange data. When Auto RTS Flow Control is not enabled ( is
            /// set to 0), the rts_n signal is set low by programming UART_MCR[1] (RTS) to a
            /// high. In Auto Flow Control, AFCE_MODE == Enabled and active ( is set to 1) and
            /// FIFOs enable (UART_FCR[0] is set to 1), the rts_n output is controlled in the
            /// same way, but is also gated with the receiver FIFO threshold trigger (rts_n is
            /// inactive high when above the threshold). The rts_n signal is de-asserted when
            /// UART_MCR[1] is set low.
            /// 0: rts_n de-asserted (logic 1)
            /// 1: rts_n asserted (logic 0) Note that in Loopback mode (UART_MCR[4] is set to
            /// 1), the rts_n output is held inactive high while the value of this location is
            /// internally looped back to an input.
            RTS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Loop Back Mode
            /// 0: Normal Mode
            /// 1: Loop Back Mode This is used to put the UART into a diagnostic mode for test
            /// purposes. If operating in UART mode (SIR_MODE != Enabled or not active,
            /// UART_MCR[6] is set to 0), the data on the SOUT line is held high, while serial
            /// data output is looped back to the sin line, internally. In this mode, all the
            /// interrupts are fully functional. Also, in loopback mode, the modem control
            /// inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control
            /// outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs,
            /// internally. If operating in infrared mode (SIR_MODE == Enabled AND active,
            /// UART_MCR[6] is set to 1), the data on the sir_out_n line is held low, while
            /// serial data output is inverted and looped back to the sir_in line.
            LOOP: u1,
            /// Auto Flow Control Enable When FIFOs are enabled and the AFCE bit is set, the
            /// AutoFlow Control is enabled.
            /// 0: Auto Flow Control mode disabled
            /// 1: Auto Flow Control mode enabled
            AFCE: u1,
            /// Select IrDA or RS485
            /// 00: UART Mode
            /// 01: IrDA SIR Mode
            /// 10: RS485 Mode
            /// 11: Reserved
            UART_FUNCTION: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2500418
        /// UART Modem Status Register
        pub const UART_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta Clear to Send This is used to indicate that the modem control line cts_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on ctsdsr_n since the last read of UART_MSR
            /// 1: change on ctsdsr_n since the last read of UART_MSR Reading the UART_MSR
            /// clears the DCTS bit. In Loopback Mode (UART_MCR[4] = 1), the DCTS reflects
            /// changes on the RTS (UART_MCR[1]).
            DCTS: u1,
            /// Delta Data Set Ready This is used to indicate that the modem control line dsr_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on dsr_n since the last read of UART_MSR
            /// 1: change on dsr_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDSR bit. In Loopback Mode (UART_MCR[4] = 1), the DDSR reflects changes on
            /// the DTR (UART_MCR[0] .
            DDSR: u1,
            /// Trailing Edge Ring Indicator This is used to indicate that a change in the input
            /// ri_n (from an active-low to an inactive-high state) has occurred since the last
            /// time the UART_MSR was read.
            /// 0: no change on ri_n since the last read of UART_MSR
            /// 1: change on ri_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the TERI bit.
            TERI: u1,
            /// Delta Data Carrier Detect This is used to indicate that the modem control line
            /// dcd_n has changed since the last time the UART_MSR was read.
            /// 0: no change on dcd_n since the last read of UART_MSR
            /// 1: change on dcd_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDCD bit.
            DDCD: u1,
            /// Line State of Clear To Send This is used to indicate the current state of the
            /// modem control line cts_n. This bit is the complement of cts_n. When the Clear to
            /// Send input (cts_n) is asserted, it is an indication that the modem or data set
            /// is ready to exchange data with UART.
            /// 0: cts_n input is de-asserted (logic 1)
            /// 1: cts_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] = 1), the CTS
            /// is the same as the RTS (UART_MCR[1]).
            CTS: u1,
            /// Line State of Data Set Ready This is used to indicate the current state of the
            /// modem control line dsr_n. This bit is the complement of the dsr_n. When the Data
            /// Set Ready input (dsr_n) is asserted, it is an indication that the modem or data
            /// set is ready to establish communication with UART.
            /// 0: dsr_n input is de-asserted (logic 1)
            /// 1: dsr_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] is set to 1),
            /// the DSR is the same as the DTR (UART_MCR[0]).
            DSR: u1,
            /// Line State of Ring Indicator This is used to indicate the current state of the
            /// modem control line ri_n. This bit is the complement of ri_n. When the Ring
            /// Indicator input (ri_n) is asserted it is an indication that a telephone ringing
            /// signal has been received by setting the modem or data.
            /// 0: ri_n input is de-asserted (logic 1)
            /// 1: ri_n input is asserted (logic 0)
            RI: u1,
            /// Line State of Data Carrier Detect This is used to indicate the current state of
            /// the modem control line dcd_n. This bit is the complement of dcd_n. When the Data
            /// Carrier Detect input (dcd_n) is asserted it is an indication that the carrier
            /// has been detected by the modem or data set.
            /// 0: dcd_n input is de-asserted (logic 1)
            /// 1: dcd_n input is asserted (logic 0)
            DCD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2500400
        /// UART Receive Buffer Register
        pub const UART_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Buffer Register Data byte received on the serial input port (sin) in
            /// UART mode, or the serial infrared input (sir_in) in infrared mode. The data in
            /// this register is valid only if the Data Ready (DR) bit in is set. If in FIFO
            /// mode and FIFOs are enabled (The [0] is set to 1), this register accesses the
            /// head of the receive FIFO. If the receive FIFO is full and this register can not
            /// read before the next data character arrives, then the data already in the FIFO
            /// are preserved, but any incoming data are lost and an overrun error occurs.
            RBR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2500484
        /// UART Receive FIFO Level Register
        pub const UART_RFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Level The bit indicates the number of data entries in the RX FIFO.
            /// UART_RXDMA_CTRL
            RFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x84);

        /// address: 0x2500518
        /// UART_RXDMA_BL
        pub const UART_RXDMA_BL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Length Unit is byte Note that this field is only configurable while RXDMA
            /// Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x2500500
        /// UART_RXDMA_CTRL
        pub const UART_RXDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            /// 0: RXDMA Disable
            /// 1: RXDMA Enable Note that if the software turns off this bit, the RXDMA will
            /// stop after the current block transfer completes, then the software should do a
            /// reset to the RX FIFO before re-enable.
            RXDMA: u1,
            /// Mode
            /// 0: Continous
            /// 1: Limited When data transferred reaches the limited count set in RXDMA LIMIT,
            /// the DMA stops and the RXDMA Start bit is cleared automatically. Note that this
            /// field is only configurable while RXDMA Busy is 0.
            RXDMA: u1,
            /// BLK SIZE Every time when data entries in RX FIFO reach BLK_SIZE, start a DMA
            /// block transfer. It is recommended that the block size no more than RX FIFO
            /// Depth.
            /// 00: 8 bytes
            /// 01: 16 bytes
            /// 10: 32 bytes
            /// 11: 64 bytes Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// AHB Burst Mode Set for AHB port burst supported INCR8 is recommended, while
            /// INCR16 may be unsupported due to the system bus.
            /// 00: SIGNLE
            /// 01: INCR4
            /// 10: INCR8
            /// 11: INCR16 Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// Timeout Enable Once enable, the DMA starts a transfer even the data entries in
            /// RX FIFO do not reach BLK_SIZE. Note that this field is only configurable when
            /// RXDMA Busy is 0.
            RXDMA: u1,
            reserved0: u1,
            /// Timeout Threshold Unit is 1 UART bit time Note that this field is only
            /// configurable when RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x2500538
        /// UART_RXDMA_DCNT
        pub const UART_RXDMA_DCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Count Only valid while RXDMA Mode is set to 1, it is used for counting the
            /// data transferred by RXDMA, and is cleared when reaches RXDMA Limit Size. Its
            /// unit is byte.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x2500520
        /// UART_RXDMA_IE
        pub const UART_RXDMA_IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done RXDMA Limit Done Interrupt Enable
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done RXDMA BLK Done Interrupt Enable
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done RXDMA Timeout Done Interrupt Enable
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun RXDMA Buffer Overrun Interrupt Enable
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x2500524
        /// UART_RXDMA_IS
        pub const UART_RXDMA_IS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done Asserted when data transferred reaches limit size in RXDMA
            /// Limit Mode.
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done Asserted when a DMA block transfer is done.
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done Asserted when a DMA transfer caused by timeout is done.
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun Asserted when the RXDMA buffer is overflow.
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x250050c
        /// UART_RXDMA_LMT
        pub const UART_RXDMA_LMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit Size Only valid when RXDMA Mode is set to 1, and the unit is byte. Note
            /// that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x2500534
        /// UART_RXDMA_RADDRH
        pub const UART_RXDMA_RADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[33:32] Software should update this register after reading
            /// data in RXDMA Buffer in time. It is byte address. The software should not update
            /// Buffer Read Address Register until until UART_RXDMA_STA[1] is 0. The software
            /// should update Read Address High Register first and then Read Address Low
            /// Register , even there is no change on Read Address High Register.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x2500530
        /// UART_RXDMA_RADDRL
        pub const UART_RXDMA_RADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[31:0] Software should update this register after reading
            /// data in RXDMA Buffer in time It is byte address. The software should not update
            /// Buffer Read Address Register until UART_RXDMA_STA[1] is 0. The software should
            /// update Read Address High Register first, and then Read Address Low Register,
            /// even there is no change on Read Address High Register.
            RXDMA: u32,
        }), base_address + 0x130);

        /// address: 0x2500514
        /// UART_RXDMA_SADDRH
        pub const UART_RXDMA_SADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [33:32] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x114);

        /// address: 0x2500510
        /// UART_RXDMA_SADDRL
        pub const UART_RXDMA_SADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [31:0] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u32,
        }), base_address + 0x110);

        /// address: 0x2500508
        /// UART_RXDMA_STA
        pub const UART_RXDMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// BUSY
            /// 0: RXDMA is idle
            /// 1: RXDMA is busy
            RXDMA: u1,
            /// Buffer Read Address Updating
            /// 0: Buffer Read Address Register is ready for updating
            /// 1: Buffer Read Address Register is busy for updating The software should not
            /// update Buffer Read Address Register until this bit is 0.
            BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x108);

        /// address: 0x2500504
        /// UART_RXDMA_STR
        pub const UART_RXDMA_STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Only valid when RXDMA mode is set to 1, it is auto cleared when data
            /// transferred reaches the RXDMA Limit Size.
            RXDMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x250052c
        /// UART_RXDMA_WADDRH
        pub const UART_RXDMA_WADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[33:32] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x12c);

        /// address: 0x2500528
        /// UART_RXDMA_WADDRL
        pub const UART_RXDMA_WADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[31:0] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u32,
        }), base_address + 0x128);

        /// address: 0x250041c
        /// UART Scratch Register
        pub const UART_SCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scratch Register This register is for programmers to use as a temporary storage
            /// space. It has no defined purpose in the UART.
            SCRATCH_REG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x2500480
        /// UART Transmit FIFO Level Register
        pub const UART_TFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Level The bit indicates the number of data entries in the TX FIFO.
            TFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x80);

        /// address: 0x2500400
        /// UART Transmit Holding Register
        pub const UART_THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Holding Register Data is transmitted on the serial output port (SOUT)
            /// in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data
            /// should only be written to the when the THRE bit ( ) is set. If in FIFO mode and
            /// FIFOs are enabled ( = 1) and THRE is set, the 16 number of characters data may
            /// be written to the before the FIFO is full. When the FIFO is full, any written
            /// data results in the written data being lost.
            THR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250047c
        /// UART Status Register
        pub const UART_USR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART Busy Bit
            /// 0: Idle or inactive
            /// 1: Busy
            BUSY: u1,
            /// TX FIFO Not Full This is used to indicate that the TX FIFO is not full.
            /// 0: TX FIFO is full
            /// 1: TX FIFO is not full This bit is cleared when the TX FIFO is full.
            TFNF: u1,
            /// TX FIFO Empty This is used to indicate that the TX FIFO is completely empty.
            /// 0: TX FIFO is not empty
            /// 1: TX FIFO is empty This bit is cleared when the TX FIFO is no longer empty.
            TFE: u1,
            /// RX FIFO Not Empty This is used to indicate that the RX FIFO contains one or more
            /// entries.
            /// 0: RX FIFO is empty
            /// 1: RX FIFO is not empty This bit is cleared when the RX FIFO is empty.
            RFNE: u1,
            /// RX FIFO Full This is used to indicate that the RX FIFO is completely full.
            /// 0: RX FIFO not full
            /// 1: RX FIFO Full This bit is cleared when the RX FIFO is no longer full.
            RFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);
    };

    /// UART2
    pub const UART2 = struct {
        pub const base_address = 0x2500800;

        /// address: 0x25008b4
        /// UART Debug DLH Register
        pub const UART_DBG_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLH
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x25008b0
        /// UART Debug DLL Register
        pub const UART_DBG_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLL
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x2500804
        /// UART Divisor Latch High Register
        pub const UART_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch High Upper 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( [7]) is set and the UART is not busy ( [0] is 0). The output
            /// baud rate is equal to the serial clock (SCLK) frequency divided by sixteen times
            /// the value of the baud rate divisor, as follows: . Note that when the Divisor
            /// Latch Registers ( and ) is set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLH is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500800
        /// UART Divisor Latch Low Register
        pub const UART_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch Low Lower 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( ) is set and the UART is not busy ( is 0). The output baud
            /// rate is equal to the serial clock (SCLK) frequency divided by sixteen times the
            /// value of the baud rate divisor, as follows: . Note that when the Divisor Latch
            /// Registers ( and ) are set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLL is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250088c
        /// UART DMA Request Enable Register
        pub const UART_DMA_REQ_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA RX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_RX_REQ_ENABLE: u1,
            /// DMA TX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TX_REQ_ENABLE: u1,
            /// DMA Timeout Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TIMEOUT_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8c);

        /// address: 0x25008f0
        /// UART_FCC
        pub const UART_FCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            RX: u1,
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            TX: u1,
            /// Clock Mode
            /// 0: Sync mode, writing/reading clocks use apb clock
            /// 1: Sync mode, writing clock uses apb clock, reading clock uses ahb clock
            RXFIFO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Depth Indicates the depth of TX/RX FIFO
            FIFO: u24,
        }), base_address + 0xf0);

        /// address: 0x2500808
        /// UART FIFO Control Register
        pub const UART_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable FIFOs The bit enables/disables the transmitting (XMIT) and receiving
            /// (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR
            /// controller part of FIFOs is reset.
            FIFOE: u1,
            /// RCVR FIFO Reset The bit resets the control part of the receive FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA RX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            RFIFOR: u1,
            /// XMIT FIFO Reset The bit resets the control part of the transfer FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA TX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            XFIFOR: u1,
            /// DMA Mode
            /// 0: Mode 0 In this mode, when the PTE in UART_HALT is high and TX FIFO is
            /// enabled, the TX DMA request will be set when the TFL in UART_TFL is less than or
            /// equal to FIFO Trigger Level (otherwise it will be cleared). When the PTE is high
            /// and TX FIFO is disabled, the TX DMA request will be set only if the THR in
            /// UART_THR is empty. If the PTE is low, the TX DMA request will be set only if the
            /// TX FIFO (TX FIFO enabled) or THR (TX FIFO disabled) is empty. When the
            /// DMA_PTE_RX in UART_HALT is high and RX FIFO is enabled, the RX DRQ will be set
            /// only if the RFL in UART_RFL is equal to or more than FIFO Trigger Level,
            /// otherwise, it will be cleared.
            /// 1: Mode 1 In this mode, TX FIFO should be enabled. If the PTE in is high, the TX
            /// DMA request will be set when the TFL in is less than or equal to FIFO Trigger
            /// Level; If the PTE is low, the TX DMA request will be set when TX FIFO is empty.
            /// Once the request is set, it is cleared only when TX FIFO is full. If the RFL in
            /// UART_RFL is equal to or more than FIFO Trigger Level or there is a character
            /// timeout, the RX DRQ will be set; Once the RX DRQ is set, it is cleared only when
            /// RX FIFO (RX FIFO enabled) or RBR (RX FIFO disabled) is empty.
            DMAM: u1,
            /// TX Empty Trigger This is used to select the empty threshold level when the THRE
            /// Interrupts are generated and the mode is active. It also determines when the
            /// dma_tx_req_n signal is asserted in certain modes of operation.
            /// 00: FIFO empty
            /// 01: 2 characters in the FIFO
            /// 10: FIFO ¼ full
            /// 11: FIFO ½ full
            TFT: u2,
            /// RCVR Trigger This is used to select the trigger level in the receiver FIFO when
            /// the Received Data Available Interrupt is generated. In the autoflow control
            /// mode, it is used to determine when the rts_n signal is de-asserted. It also
            /// determines when the dma_rx_req_n signal is asserted in certain modes of
            /// operation.
            /// 00: 1 character in the FIFO
            /// 01: FIFO ¼ full
            /// 10: FIFO ½ full
            /// 11: FIFO-2 less than full
            RT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x25008a4
        /// UART Halt TX Register
        pub const UART_HALT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Halt TX This register is used to halt transmissions for testing, so that the
            /// transmit FIFO can be filled by the master when FIFOs are implemented and
            /// enabled. 0 : Halt TX disabled 1 : Halt TX enabled
            HALT_TX: u1,
            /// This is an enable bit for the user to change LCR register configuration and baud
            /// rate register (UART_DLH and UART_DLL) when the UART is busy.
            /// 1: Enable change when busy
            CHCFG_AT_BUSY: u1,
            /// After the user uses UART_HALT[1] to change the baud rate or LCR configuration,
            /// write 1 to update the configuration and wait this bit to self-clear to 0 to
            /// finish update process. Writing 0 to this bit has no effect.
            /// 1: Update trigger, self-clear to 0 when finish update.
            CHANGE_UPDATE: u1,
            reserved0: u1,
            /// SIR TX Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            SIR_TX_INVERT: u1,
            /// SIR RX Pulse Polarity Invert
            /// 0: Not invert receiver signal
            /// 1: Invert receiver signal
            SIR_RX_INVERT: u1,
            /// The Transmission of RX_DRQ In DMA1 mode, when RFL is more than or equal to the
            /// trigger value, or a receive timeout has occurred, the controller sends DRQ. In
            /// DMA0 mode, when DMA_PTE_RX = 1 and FIFO is on, if RFL is more than or equal to
            /// trig, the controller sends DRQ, else DRQ is cleared. In other cases, once the
            /// received data is valid, the controller sends DRQ.
            DMA_PTE_RX: u1,
            /// The sending of TX_REQ In DMA1 mode (FIFO on), if the PTE is set to 1 when the
            /// TFL in UART_TFL is less than or equal to the trigger value, the controller sends
            /// the DMA request. If the PTE is set to 0, when FIFO is empty, the controller
            /// sends the DMA request. The DMA request will stop when FIFO is full. In DMA0
            /// mode, if the PTE is set to 1 and FIFO is on, when the TFL in UART_TFL is less
            /// than or equal to the trigger value, the controller sends DMA request. If the PTE
            /// is set to 1 and FIFO off, when the THR in UART_THR is empty, the controller
            /// sends DMA request. If the PTE is set to 0, when FIFO(FIFO Enable) or THR(FIFO
            /// Enable) is empty, the controller sends DMA request. Otherwise, the DMA request
            /// is cleared.
            PTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x2500888
        /// UART DMA Handshake Configuration Register
        pub const UART_HSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake configuration
            /// 0xA5: DMA wait cycle mode
            /// 0xE5: DMA handshake mode
            HANDSHAKE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x2500804
        /// UART Interrupt Enable Register
        pub const UART_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Received Data Available Interrupt This is used to enable/disable the
            /// generation of Received Data Available Interrupt and the Character Timeout
            /// Interrupt (if in FIFO mode and FIFOs enabled). These are the second-highest
            /// priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ERBFI: u1,
            /// Enable Transmit Holding Register Empty Interrupt This is used to enable/disable
            /// the generation of Transmitter Holding Register Empty Interrupt. This is the
            /// third-highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ETBEI: u1,
            /// Enable Receiver Line Status Interrupt This is used to enable/disable the
            /// generation of Receiver Line Status Interrupt. This is the highest priority
            /// interrupt.
            /// 0: Disable
            /// 1: Enable
            ELSI: u1,
            /// Enable Modem Status Interrupt This is used to enable/disable the generation of
            /// Modem Status Interrupt. This is the fourth highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            EDSSI: u1,
            /// RS485 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RS485_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Programmable THRE Interrupt Mode Enable This is used to enable/disable the
            /// generation of THRE Interrupt.
            /// 0: Disable
            /// 1: Enable
            PTIME: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500808
        /// UART Interrupt Identity Register
        pub const UART_IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID This indicates the highest priority pending interrupt which can be
            /// one of the following types.
            /// 0000: modem status
            /// 0001: no interrupt pending
            /// 0010: THR empty
            /// 0011: RS485 Interrupt
            /// 0100: received data available
            /// 0110: receiver line status
            /// 0111: busy detect
            /// 1100: character timeout The bit 3 indicates an interrupt can only occur when the
            /// FIFOs are enabled and used to distinguish a Character Timeout condition
            /// interrupt.
            IID: u4,
            reserved0: u1,
            reserved1: u1,
            /// FIFOs Enable Flag This is used to indicate whether the FIFOs are enabled or
            /// disabled.
            /// 00: Disable
            /// 11: Enable
            FEFLAG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x250080c
        /// UART Line Control Register
        pub const UART_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Length Select It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the count of bits in a transmitted
            /// or received frame.
            /// 00: 5 bits
            /// 01: 6 bits
            /// 10: 7 bits
            /// 11: 8 bits
            DLS: u2,
            /// Number of stop bits It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the number of stop bits per
            /// character that the peripheral transmits and receives. If set to 0, one stop bit
            /// is transmitted in the serial data. If set to 1 and the data bits are set to 5
            /// (UART_LCR[1:0] is 0), one and a half stop bit is transmitted. Otherwise, two
            /// stop bits are transmitted. Note that regardless of the number of stop bits
            /// selected, the receiver checks only the first stop bit.
            /// 0: 1 stop bit
            /// 1: 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit
            STOP: u1,
            /// Parity Enable It is writable only when UART is not busy (UART_USR[0] is 0) and
            /// always readable. This bit is used to enable and disable parity generation and
            /// detection in transmitted and received serial characters respectively.
            /// 0: Parity disabled
            /// 1: Parity enabled
            PEN: u1,
            /// Even Parity Select It is writable only when UART is not busy (UART_USR[0] is 0).
            /// This is used to select the even and odd parity when the PEN is enabled (the
            /// UART_LCR[3] is set to 1). Setting the UART_LCR[5] is unset to reverse the
            /// LCR[4].
            /// 00: Odd Parity
            /// 01: Even Parity 1X: Reverse LCR[4] In RS485 mode, it is the 9th bit--address
            /// bit.
            /// 11: 9th bit = 0, indicates that this is a data byte.
            /// 10: 9th bit = 1, indicates that this is an address byte.
            EPS: u2,
            /// Break Control Bit This is used to cause a break condition to be transmitted to
            /// the receiving device. If set to 0, the serial output is forced to the spacing
            /// (logic 0) state. When not in Loopback mode, as determined by UART_MCR[4], the
            /// SOUT line is forced low until the Break bit is cleared. If SIR_MODE is enabled
            /// and active (UART_MCR[6] is set to 1), the sir_out_n line is continuously pulsed.
            /// When in Loopback mode, the break condition is internally looped back to the
            /// receiver and the sir_out_n line is forced low.
            BC: u1,
            /// Divisor Latch Access Bit It is writable only when UART is not busy (UART_USR[0]
            /// is 0) and always readable. This bit is used to enable the reading and writing of
            /// the Divisor Latch register (UART_DLL and UART_DLH) to set the baud rate of the
            /// UART. This bit must be cleared after the initial baud rate setup in order to
            /// access other registers.
            /// 0: Select RX Buffer Register (UART_RBR)/TX Holding Register (UART_THR) and
            /// Interrupt Enable Register (UART_IER)
            /// 1: Select Divisor Latch LS Register (UART_DLL) and Divisor Latch MS Register
            /// (UART_DLM)
            DLAB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2500814
        /// UART Line Status Register
        pub const UART_LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready This is used to indicate that the receiver contains at least one
            /// character in the UART_RBR or the receiver FIFO.
            /// 0: no data ready
            /// 1: data ready This bit is cleared when the UART_RBR is read in non-FIFO mode, or
            /// when the receiver FIFO is empty, in FIFO mode.
            DR: u1,
            /// Overrun Error This occurs if a new data character was received before the
            /// previous data was read. In the non-FIFO mode, the OE bit is set when a new
            /// character arrives in the receiver before the previous character was read from
            /// the UART_RBR. When this happens, the data in the UART_RBR is overwritten. In the
            /// FIFO mode, an overrun error occurs when the FIFO is full and a new character
            /// arrives at the receiver. The data in the FIFO is retained and the data in the
            /// receive shift register is lost.
            /// 0: no overrun error
            /// 1: overrun error Reading the UART_LSR clears the OE bit.
            OE: u1,
            /// Parity Error This is used to indicate the occurrence of a parity error in the
            /// receiver if the Parity Enable (PEN) bit (UART_LCR[3]) is set. In the FIFO mode,
            /// since the parity error is associated with a character received, it is revealed
            /// when the character with the parity error arrives at the top of the FIFO. It
            /// should be noted that the Parity Error (PE) bit (UART_LSR[2]) is set if a break
            /// interrupt has occurred, as indicated by Break Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no parity error
            /// 1: parity error Reading the UART_LSR clears the PE bit.
            PE: u1,
            /// Framing Error This is used to indicate the occurrence of a framing error in the
            /// receiver. A framing error occurs when the receiver does not detect a valid STOP
            /// bit in the received data. In the FIFO mode, since the framing error is
            /// associated with a character received, it is revealed when the character with the
            /// framing error is at the top of the FIFO. When a framing error occurs, the UART
            /// tries to resynchronize. It does this by assuming that the error was due to the
            /// start bit of the next character and then continues receiving the other bit i.e.
            /// data, and/or parity and stop. It should be noted that the Framing Error (FE) bit
            /// (UART_LSR[3]) is set if a break interrupt has occurred, as indicated by Break
            /// Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no framing error
            /// 1: framing error Reading the UART_LSR clears the FE bit.
            FE: u1,
            /// Break Interrupt This is used to indicate the detection of a break sequence on
            /// the serial input data. If in UART mode (SIR_MODE == Disabled), it is set when
            /// the serial input, sir_in, is held in a logic '0' state for longer than the sum
            /// of + + + . If in infrared mode (SIR_MODE == Enabled), it is set when the serial
            /// input, sir_in, is continuously pulsed to logic '0' for longer than the sum of +
            /// + + . A break condition on serial input causes one and only one character,
            /// consisting of all zeros, to be received by the UART. In the FIFO mode, the
            /// character associated with the break condition is carried through the FIFO and is
            /// revealed when the character is at the top of the FIFO. Reading the UART_LSR
            /// clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately
            /// and persists until the UART_LSR is read.
            BI: u1,
            /// TX Holding Register Empty If the FIFOs are disabled, this bit is set to "1" when
            /// the TX Holding Register (UART_THR) is empty and ready to accept new data and it
            /// is cleared when the CPU writes to the TX Holding Register. If the FIFOs are
            /// enabled, this bit is set to "1" whenever the TX FIFO is empty and it is cleared
            /// when at least one byte is written to the TX FIFO.
            THRE: u1,
            /// Transmitter Empty If the FIFOs are disabled, this bit is set to "1" whenever the
            /// TX Holding Register (UART_THR) and the TX Shift Register are empty. If the FIFOs
            /// are enabled, this bit is set whenever the TX FIFO and the TX Shift Register are
            /// empty. In both cases, this bit is cleared when a byte is written to the TX data
            /// channel.
            TEMT: u1,
            /// RX Data Error in FIFO When FIFOs are disabled, this bit is always 0. When FIFOs
            /// are enabled, this bit is set to “1” when there is at least one PE, FE, or BI
            /// in the RX FIFO. It is cleared by reading from the UART_LSR register, there are
            /// no subsequent errors in the FIFO.
            FIFOERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2500810
        /// UART Modem Control Register
        pub const UART_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Terminal Ready This is used to directly control the Data Terminal Ready
            /// (dtr_n) output. The value written to this location is inverted and driven out on
            /// dtr_n.
            /// 0: dtr_n de-asserted (logic 1)
            /// 1: dtr_n asserted (logic 0) The DTR output is used to inform the modem or data
            /// set that the UART is ready to establish communications. Note that in Loopback
            /// mode (UART_MCR[4] is set to 1), the dtr_n output is held inactive high while the
            /// value of this location is internally looped back to an input.
            DTR: u1,
            /// Request to Send This is used to directly control the Request to Send (rts_n)
            /// output. The RTS (rts_n) output is used to inform the modem or data set that the
            /// UART is ready to exchange data. When Auto RTS Flow Control is not enabled ( is
            /// set to 0), the rts_n signal is set low by programming UART_MCR[1] (RTS) to a
            /// high. In Auto Flow Control, AFCE_MODE == Enabled and active ( is set to 1) and
            /// FIFOs enable (UART_FCR[0] is set to 1), the rts_n output is controlled in the
            /// same way, but is also gated with the receiver FIFO threshold trigger (rts_n is
            /// inactive high when above the threshold). The rts_n signal is de-asserted when
            /// UART_MCR[1] is set low.
            /// 0: rts_n de-asserted (logic 1)
            /// 1: rts_n asserted (logic 0) Note that in Loopback mode (UART_MCR[4] is set to
            /// 1), the rts_n output is held inactive high while the value of this location is
            /// internally looped back to an input.
            RTS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Loop Back Mode
            /// 0: Normal Mode
            /// 1: Loop Back Mode This is used to put the UART into a diagnostic mode for test
            /// purposes. If operating in UART mode (SIR_MODE != Enabled or not active,
            /// UART_MCR[6] is set to 0), the data on the SOUT line is held high, while serial
            /// data output is looped back to the sin line, internally. In this mode, all the
            /// interrupts are fully functional. Also, in loopback mode, the modem control
            /// inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control
            /// outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs,
            /// internally. If operating in infrared mode (SIR_MODE == Enabled AND active,
            /// UART_MCR[6] is set to 1), the data on the sir_out_n line is held low, while
            /// serial data output is inverted and looped back to the sir_in line.
            LOOP: u1,
            /// Auto Flow Control Enable When FIFOs are enabled and the AFCE bit is set, the
            /// AutoFlow Control is enabled.
            /// 0: Auto Flow Control mode disabled
            /// 1: Auto Flow Control mode enabled
            AFCE: u1,
            /// Select IrDA or RS485
            /// 00: UART Mode
            /// 01: IrDA SIR Mode
            /// 10: RS485 Mode
            /// 11: Reserved
            UART_FUNCTION: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2500818
        /// UART Modem Status Register
        pub const UART_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta Clear to Send This is used to indicate that the modem control line cts_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on ctsdsr_n since the last read of UART_MSR
            /// 1: change on ctsdsr_n since the last read of UART_MSR Reading the UART_MSR
            /// clears the DCTS bit. In Loopback Mode (UART_MCR[4] = 1), the DCTS reflects
            /// changes on the RTS (UART_MCR[1]).
            DCTS: u1,
            /// Delta Data Set Ready This is used to indicate that the modem control line dsr_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on dsr_n since the last read of UART_MSR
            /// 1: change on dsr_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDSR bit. In Loopback Mode (UART_MCR[4] = 1), the DDSR reflects changes on
            /// the DTR (UART_MCR[0] .
            DDSR: u1,
            /// Trailing Edge Ring Indicator This is used to indicate that a change in the input
            /// ri_n (from an active-low to an inactive-high state) has occurred since the last
            /// time the UART_MSR was read.
            /// 0: no change on ri_n since the last read of UART_MSR
            /// 1: change on ri_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the TERI bit.
            TERI: u1,
            /// Delta Data Carrier Detect This is used to indicate that the modem control line
            /// dcd_n has changed since the last time the UART_MSR was read.
            /// 0: no change on dcd_n since the last read of UART_MSR
            /// 1: change on dcd_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDCD bit.
            DDCD: u1,
            /// Line State of Clear To Send This is used to indicate the current state of the
            /// modem control line cts_n. This bit is the complement of cts_n. When the Clear to
            /// Send input (cts_n) is asserted, it is an indication that the modem or data set
            /// is ready to exchange data with UART.
            /// 0: cts_n input is de-asserted (logic 1)
            /// 1: cts_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] = 1), the CTS
            /// is the same as the RTS (UART_MCR[1]).
            CTS: u1,
            /// Line State of Data Set Ready This is used to indicate the current state of the
            /// modem control line dsr_n. This bit is the complement of the dsr_n. When the Data
            /// Set Ready input (dsr_n) is asserted, it is an indication that the modem or data
            /// set is ready to establish communication with UART.
            /// 0: dsr_n input is de-asserted (logic 1)
            /// 1: dsr_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] is set to 1),
            /// the DSR is the same as the DTR (UART_MCR[0]).
            DSR: u1,
            /// Line State of Ring Indicator This is used to indicate the current state of the
            /// modem control line ri_n. This bit is the complement of ri_n. When the Ring
            /// Indicator input (ri_n) is asserted it is an indication that a telephone ringing
            /// signal has been received by setting the modem or data.
            /// 0: ri_n input is de-asserted (logic 1)
            /// 1: ri_n input is asserted (logic 0)
            RI: u1,
            /// Line State of Data Carrier Detect This is used to indicate the current state of
            /// the modem control line dcd_n. This bit is the complement of dcd_n. When the Data
            /// Carrier Detect input (dcd_n) is asserted it is an indication that the carrier
            /// has been detected by the modem or data set.
            /// 0: dcd_n input is de-asserted (logic 1)
            /// 1: dcd_n input is asserted (logic 0)
            DCD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2500800
        /// UART Receive Buffer Register
        pub const UART_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Buffer Register Data byte received on the serial input port (sin) in
            /// UART mode, or the serial infrared input (sir_in) in infrared mode. The data in
            /// this register is valid only if the Data Ready (DR) bit in is set. If in FIFO
            /// mode and FIFOs are enabled (The [0] is set to 1), this register accesses the
            /// head of the receive FIFO. If the receive FIFO is full and this register can not
            /// read before the next data character arrives, then the data already in the FIFO
            /// are preserved, but any incoming data are lost and an overrun error occurs.
            RBR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2500884
        /// UART Receive FIFO Level Register
        pub const UART_RFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Level The bit indicates the number of data entries in the RX FIFO.
            /// UART_RXDMA_CTRL
            RFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x84);

        /// address: 0x2500918
        /// UART_RXDMA_BL
        pub const UART_RXDMA_BL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Length Unit is byte Note that this field is only configurable while RXDMA
            /// Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x2500900
        /// UART_RXDMA_CTRL
        pub const UART_RXDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            /// 0: RXDMA Disable
            /// 1: RXDMA Enable Note that if the software turns off this bit, the RXDMA will
            /// stop after the current block transfer completes, then the software should do a
            /// reset to the RX FIFO before re-enable.
            RXDMA: u1,
            /// Mode
            /// 0: Continous
            /// 1: Limited When data transferred reaches the limited count set in RXDMA LIMIT,
            /// the DMA stops and the RXDMA Start bit is cleared automatically. Note that this
            /// field is only configurable while RXDMA Busy is 0.
            RXDMA: u1,
            /// BLK SIZE Every time when data entries in RX FIFO reach BLK_SIZE, start a DMA
            /// block transfer. It is recommended that the block size no more than RX FIFO
            /// Depth.
            /// 00: 8 bytes
            /// 01: 16 bytes
            /// 10: 32 bytes
            /// 11: 64 bytes Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// AHB Burst Mode Set for AHB port burst supported INCR8 is recommended, while
            /// INCR16 may be unsupported due to the system bus.
            /// 00: SIGNLE
            /// 01: INCR4
            /// 10: INCR8
            /// 11: INCR16 Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// Timeout Enable Once enable, the DMA starts a transfer even the data entries in
            /// RX FIFO do not reach BLK_SIZE. Note that this field is only configurable when
            /// RXDMA Busy is 0.
            RXDMA: u1,
            reserved0: u1,
            /// Timeout Threshold Unit is 1 UART bit time Note that this field is only
            /// configurable when RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x2500938
        /// UART_RXDMA_DCNT
        pub const UART_RXDMA_DCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Count Only valid while RXDMA Mode is set to 1, it is used for counting the
            /// data transferred by RXDMA, and is cleared when reaches RXDMA Limit Size. Its
            /// unit is byte.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x2500920
        /// UART_RXDMA_IE
        pub const UART_RXDMA_IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done RXDMA Limit Done Interrupt Enable
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done RXDMA BLK Done Interrupt Enable
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done RXDMA Timeout Done Interrupt Enable
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun RXDMA Buffer Overrun Interrupt Enable
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x2500924
        /// UART_RXDMA_IS
        pub const UART_RXDMA_IS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done Asserted when data transferred reaches limit size in RXDMA
            /// Limit Mode.
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done Asserted when a DMA block transfer is done.
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done Asserted when a DMA transfer caused by timeout is done.
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun Asserted when the RXDMA buffer is overflow.
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x250090c
        /// UART_RXDMA_LMT
        pub const UART_RXDMA_LMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit Size Only valid when RXDMA Mode is set to 1, and the unit is byte. Note
            /// that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x2500934
        /// UART_RXDMA_RADDRH
        pub const UART_RXDMA_RADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[33:32] Software should update this register after reading
            /// data in RXDMA Buffer in time. It is byte address. The software should not update
            /// Buffer Read Address Register until until UART_RXDMA_STA[1] is 0. The software
            /// should update Read Address High Register first and then Read Address Low
            /// Register , even there is no change on Read Address High Register.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x2500930
        /// UART_RXDMA_RADDRL
        pub const UART_RXDMA_RADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[31:0] Software should update this register after reading
            /// data in RXDMA Buffer in time It is byte address. The software should not update
            /// Buffer Read Address Register until UART_RXDMA_STA[1] is 0. The software should
            /// update Read Address High Register first, and then Read Address Low Register,
            /// even there is no change on Read Address High Register.
            RXDMA: u32,
        }), base_address + 0x130);

        /// address: 0x2500914
        /// UART_RXDMA_SADDRH
        pub const UART_RXDMA_SADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [33:32] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x114);

        /// address: 0x2500910
        /// UART_RXDMA_SADDRL
        pub const UART_RXDMA_SADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [31:0] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u32,
        }), base_address + 0x110);

        /// address: 0x2500908
        /// UART_RXDMA_STA
        pub const UART_RXDMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// BUSY
            /// 0: RXDMA is idle
            /// 1: RXDMA is busy
            RXDMA: u1,
            /// Buffer Read Address Updating
            /// 0: Buffer Read Address Register is ready for updating
            /// 1: Buffer Read Address Register is busy for updating The software should not
            /// update Buffer Read Address Register until this bit is 0.
            BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x108);

        /// address: 0x2500904
        /// UART_RXDMA_STR
        pub const UART_RXDMA_STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Only valid when RXDMA mode is set to 1, it is auto cleared when data
            /// transferred reaches the RXDMA Limit Size.
            RXDMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x250092c
        /// UART_RXDMA_WADDRH
        pub const UART_RXDMA_WADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[33:32] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x12c);

        /// address: 0x2500928
        /// UART_RXDMA_WADDRL
        pub const UART_RXDMA_WADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[31:0] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u32,
        }), base_address + 0x128);

        /// address: 0x250081c
        /// UART Scratch Register
        pub const UART_SCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scratch Register This register is for programmers to use as a temporary storage
            /// space. It has no defined purpose in the UART.
            SCRATCH_REG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x2500880
        /// UART Transmit FIFO Level Register
        pub const UART_TFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Level The bit indicates the number of data entries in the TX FIFO.
            TFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x80);

        /// address: 0x2500800
        /// UART Transmit Holding Register
        pub const UART_THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Holding Register Data is transmitted on the serial output port (SOUT)
            /// in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data
            /// should only be written to the when the THRE bit ( ) is set. If in FIFO mode and
            /// FIFOs are enabled ( = 1) and THRE is set, the 16 number of characters data may
            /// be written to the before the FIFO is full. When the FIFO is full, any written
            /// data results in the written data being lost.
            THR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250087c
        /// UART Status Register
        pub const UART_USR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART Busy Bit
            /// 0: Idle or inactive
            /// 1: Busy
            BUSY: u1,
            /// TX FIFO Not Full This is used to indicate that the TX FIFO is not full.
            /// 0: TX FIFO is full
            /// 1: TX FIFO is not full This bit is cleared when the TX FIFO is full.
            TFNF: u1,
            /// TX FIFO Empty This is used to indicate that the TX FIFO is completely empty.
            /// 0: TX FIFO is not empty
            /// 1: TX FIFO is empty This bit is cleared when the TX FIFO is no longer empty.
            TFE: u1,
            /// RX FIFO Not Empty This is used to indicate that the RX FIFO contains one or more
            /// entries.
            /// 0: RX FIFO is empty
            /// 1: RX FIFO is not empty This bit is cleared when the RX FIFO is empty.
            RFNE: u1,
            /// RX FIFO Full This is used to indicate that the RX FIFO is completely full.
            /// 0: RX FIFO not full
            /// 1: RX FIFO Full This bit is cleared when the RX FIFO is no longer full.
            RFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);
    };

    /// UART3
    pub const UART3 = struct {
        pub const base_address = 0x2500c00;

        /// address: 0x2500cb4
        /// UART Debug DLH Register
        pub const UART_DBG_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLH
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x2500cb0
        /// UART Debug DLL Register
        pub const UART_DBG_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLL
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x2500c04
        /// UART Divisor Latch High Register
        pub const UART_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch High Upper 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( [7]) is set and the UART is not busy ( [0] is 0). The output
            /// baud rate is equal to the serial clock (SCLK) frequency divided by sixteen times
            /// the value of the baud rate divisor, as follows: . Note that when the Divisor
            /// Latch Registers ( and ) is set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLH is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500c00
        /// UART Divisor Latch Low Register
        pub const UART_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch Low Lower 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( ) is set and the UART is not busy ( is 0). The output baud
            /// rate is equal to the serial clock (SCLK) frequency divided by sixteen times the
            /// value of the baud rate divisor, as follows: . Note that when the Divisor Latch
            /// Registers ( and ) are set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLL is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2500c8c
        /// UART DMA Request Enable Register
        pub const UART_DMA_REQ_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA RX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_RX_REQ_ENABLE: u1,
            /// DMA TX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TX_REQ_ENABLE: u1,
            /// DMA Timeout Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TIMEOUT_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8c);

        /// address: 0x2500cf0
        /// UART_FCC
        pub const UART_FCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            RX: u1,
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            TX: u1,
            /// Clock Mode
            /// 0: Sync mode, writing/reading clocks use apb clock
            /// 1: Sync mode, writing clock uses apb clock, reading clock uses ahb clock
            RXFIFO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Depth Indicates the depth of TX/RX FIFO
            FIFO: u24,
        }), base_address + 0xf0);

        /// address: 0x2500c08
        /// UART FIFO Control Register
        pub const UART_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable FIFOs The bit enables/disables the transmitting (XMIT) and receiving
            /// (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR
            /// controller part of FIFOs is reset.
            FIFOE: u1,
            /// RCVR FIFO Reset The bit resets the control part of the receive FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA RX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            RFIFOR: u1,
            /// XMIT FIFO Reset The bit resets the control part of the transfer FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA TX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            XFIFOR: u1,
            /// DMA Mode
            /// 0: Mode 0 In this mode, when the PTE in UART_HALT is high and TX FIFO is
            /// enabled, the TX DMA request will be set when the TFL in UART_TFL is less than or
            /// equal to FIFO Trigger Level (otherwise it will be cleared). When the PTE is high
            /// and TX FIFO is disabled, the TX DMA request will be set only if the THR in
            /// UART_THR is empty. If the PTE is low, the TX DMA request will be set only if the
            /// TX FIFO (TX FIFO enabled) or THR (TX FIFO disabled) is empty. When the
            /// DMA_PTE_RX in UART_HALT is high and RX FIFO is enabled, the RX DRQ will be set
            /// only if the RFL in UART_RFL is equal to or more than FIFO Trigger Level,
            /// otherwise, it will be cleared.
            /// 1: Mode 1 In this mode, TX FIFO should be enabled. If the PTE in is high, the TX
            /// DMA request will be set when the TFL in is less than or equal to FIFO Trigger
            /// Level; If the PTE is low, the TX DMA request will be set when TX FIFO is empty.
            /// Once the request is set, it is cleared only when TX FIFO is full. If the RFL in
            /// UART_RFL is equal to or more than FIFO Trigger Level or there is a character
            /// timeout, the RX DRQ will be set; Once the RX DRQ is set, it is cleared only when
            /// RX FIFO (RX FIFO enabled) or RBR (RX FIFO disabled) is empty.
            DMAM: u1,
            /// TX Empty Trigger This is used to select the empty threshold level when the THRE
            /// Interrupts are generated and the mode is active. It also determines when the
            /// dma_tx_req_n signal is asserted in certain modes of operation.
            /// 00: FIFO empty
            /// 01: 2 characters in the FIFO
            /// 10: FIFO ¼ full
            /// 11: FIFO ½ full
            TFT: u2,
            /// RCVR Trigger This is used to select the trigger level in the receiver FIFO when
            /// the Received Data Available Interrupt is generated. In the autoflow control
            /// mode, it is used to determine when the rts_n signal is de-asserted. It also
            /// determines when the dma_rx_req_n signal is asserted in certain modes of
            /// operation.
            /// 00: 1 character in the FIFO
            /// 01: FIFO ¼ full
            /// 10: FIFO ½ full
            /// 11: FIFO-2 less than full
            RT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x2500ca4
        /// UART Halt TX Register
        pub const UART_HALT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Halt TX This register is used to halt transmissions for testing, so that the
            /// transmit FIFO can be filled by the master when FIFOs are implemented and
            /// enabled. 0 : Halt TX disabled 1 : Halt TX enabled
            HALT_TX: u1,
            /// This is an enable bit for the user to change LCR register configuration and baud
            /// rate register (UART_DLH and UART_DLL) when the UART is busy.
            /// 1: Enable change when busy
            CHCFG_AT_BUSY: u1,
            /// After the user uses UART_HALT[1] to change the baud rate or LCR configuration,
            /// write 1 to update the configuration and wait this bit to self-clear to 0 to
            /// finish update process. Writing 0 to this bit has no effect.
            /// 1: Update trigger, self-clear to 0 when finish update.
            CHANGE_UPDATE: u1,
            reserved0: u1,
            /// SIR TX Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            SIR_TX_INVERT: u1,
            /// SIR RX Pulse Polarity Invert
            /// 0: Not invert receiver signal
            /// 1: Invert receiver signal
            SIR_RX_INVERT: u1,
            /// The Transmission of RX_DRQ In DMA1 mode, when RFL is more than or equal to the
            /// trigger value, or a receive timeout has occurred, the controller sends DRQ. In
            /// DMA0 mode, when DMA_PTE_RX = 1 and FIFO is on, if RFL is more than or equal to
            /// trig, the controller sends DRQ, else DRQ is cleared. In other cases, once the
            /// received data is valid, the controller sends DRQ.
            DMA_PTE_RX: u1,
            /// The sending of TX_REQ In DMA1 mode (FIFO on), if the PTE is set to 1 when the
            /// TFL in UART_TFL is less than or equal to the trigger value, the controller sends
            /// the DMA request. If the PTE is set to 0, when FIFO is empty, the controller
            /// sends the DMA request. The DMA request will stop when FIFO is full. In DMA0
            /// mode, if the PTE is set to 1 and FIFO is on, when the TFL in UART_TFL is less
            /// than or equal to the trigger value, the controller sends DMA request. If the PTE
            /// is set to 1 and FIFO off, when the THR in UART_THR is empty, the controller
            /// sends DMA request. If the PTE is set to 0, when FIFO(FIFO Enable) or THR(FIFO
            /// Enable) is empty, the controller sends DMA request. Otherwise, the DMA request
            /// is cleared.
            PTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x2500c88
        /// UART DMA Handshake Configuration Register
        pub const UART_HSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake configuration
            /// 0xA5: DMA wait cycle mode
            /// 0xE5: DMA handshake mode
            HANDSHAKE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x2500c04
        /// UART Interrupt Enable Register
        pub const UART_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Received Data Available Interrupt This is used to enable/disable the
            /// generation of Received Data Available Interrupt and the Character Timeout
            /// Interrupt (if in FIFO mode and FIFOs enabled). These are the second-highest
            /// priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ERBFI: u1,
            /// Enable Transmit Holding Register Empty Interrupt This is used to enable/disable
            /// the generation of Transmitter Holding Register Empty Interrupt. This is the
            /// third-highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ETBEI: u1,
            /// Enable Receiver Line Status Interrupt This is used to enable/disable the
            /// generation of Receiver Line Status Interrupt. This is the highest priority
            /// interrupt.
            /// 0: Disable
            /// 1: Enable
            ELSI: u1,
            /// Enable Modem Status Interrupt This is used to enable/disable the generation of
            /// Modem Status Interrupt. This is the fourth highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            EDSSI: u1,
            /// RS485 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RS485_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Programmable THRE Interrupt Mode Enable This is used to enable/disable the
            /// generation of THRE Interrupt.
            /// 0: Disable
            /// 1: Enable
            PTIME: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2500c08
        /// UART Interrupt Identity Register
        pub const UART_IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID This indicates the highest priority pending interrupt which can be
            /// one of the following types.
            /// 0000: modem status
            /// 0001: no interrupt pending
            /// 0010: THR empty
            /// 0011: RS485 Interrupt
            /// 0100: received data available
            /// 0110: receiver line status
            /// 0111: busy detect
            /// 1100: character timeout The bit 3 indicates an interrupt can only occur when the
            /// FIFOs are enabled and used to distinguish a Character Timeout condition
            /// interrupt.
            IID: u4,
            reserved0: u1,
            reserved1: u1,
            /// FIFOs Enable Flag This is used to indicate whether the FIFOs are enabled or
            /// disabled.
            /// 00: Disable
            /// 11: Enable
            FEFLAG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x2500c0c
        /// UART Line Control Register
        pub const UART_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Length Select It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the count of bits in a transmitted
            /// or received frame.
            /// 00: 5 bits
            /// 01: 6 bits
            /// 10: 7 bits
            /// 11: 8 bits
            DLS: u2,
            /// Number of stop bits It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the number of stop bits per
            /// character that the peripheral transmits and receives. If set to 0, one stop bit
            /// is transmitted in the serial data. If set to 1 and the data bits are set to 5
            /// (UART_LCR[1:0] is 0), one and a half stop bit is transmitted. Otherwise, two
            /// stop bits are transmitted. Note that regardless of the number of stop bits
            /// selected, the receiver checks only the first stop bit.
            /// 0: 1 stop bit
            /// 1: 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit
            STOP: u1,
            /// Parity Enable It is writable only when UART is not busy (UART_USR[0] is 0) and
            /// always readable. This bit is used to enable and disable parity generation and
            /// detection in transmitted and received serial characters respectively.
            /// 0: Parity disabled
            /// 1: Parity enabled
            PEN: u1,
            /// Even Parity Select It is writable only when UART is not busy (UART_USR[0] is 0).
            /// This is used to select the even and odd parity when the PEN is enabled (the
            /// UART_LCR[3] is set to 1). Setting the UART_LCR[5] is unset to reverse the
            /// LCR[4].
            /// 00: Odd Parity
            /// 01: Even Parity 1X: Reverse LCR[4] In RS485 mode, it is the 9th bit--address
            /// bit.
            /// 11: 9th bit = 0, indicates that this is a data byte.
            /// 10: 9th bit = 1, indicates that this is an address byte.
            EPS: u2,
            /// Break Control Bit This is used to cause a break condition to be transmitted to
            /// the receiving device. If set to 0, the serial output is forced to the spacing
            /// (logic 0) state. When not in Loopback mode, as determined by UART_MCR[4], the
            /// SOUT line is forced low until the Break bit is cleared. If SIR_MODE is enabled
            /// and active (UART_MCR[6] is set to 1), the sir_out_n line is continuously pulsed.
            /// When in Loopback mode, the break condition is internally looped back to the
            /// receiver and the sir_out_n line is forced low.
            BC: u1,
            /// Divisor Latch Access Bit It is writable only when UART is not busy (UART_USR[0]
            /// is 0) and always readable. This bit is used to enable the reading and writing of
            /// the Divisor Latch register (UART_DLL and UART_DLH) to set the baud rate of the
            /// UART. This bit must be cleared after the initial baud rate setup in order to
            /// access other registers.
            /// 0: Select RX Buffer Register (UART_RBR)/TX Holding Register (UART_THR) and
            /// Interrupt Enable Register (UART_IER)
            /// 1: Select Divisor Latch LS Register (UART_DLL) and Divisor Latch MS Register
            /// (UART_DLM)
            DLAB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2500c14
        /// UART Line Status Register
        pub const UART_LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready This is used to indicate that the receiver contains at least one
            /// character in the UART_RBR or the receiver FIFO.
            /// 0: no data ready
            /// 1: data ready This bit is cleared when the UART_RBR is read in non-FIFO mode, or
            /// when the receiver FIFO is empty, in FIFO mode.
            DR: u1,
            /// Overrun Error This occurs if a new data character was received before the
            /// previous data was read. In the non-FIFO mode, the OE bit is set when a new
            /// character arrives in the receiver before the previous character was read from
            /// the UART_RBR. When this happens, the data in the UART_RBR is overwritten. In the
            /// FIFO mode, an overrun error occurs when the FIFO is full and a new character
            /// arrives at the receiver. The data in the FIFO is retained and the data in the
            /// receive shift register is lost.
            /// 0: no overrun error
            /// 1: overrun error Reading the UART_LSR clears the OE bit.
            OE: u1,
            /// Parity Error This is used to indicate the occurrence of a parity error in the
            /// receiver if the Parity Enable (PEN) bit (UART_LCR[3]) is set. In the FIFO mode,
            /// since the parity error is associated with a character received, it is revealed
            /// when the character with the parity error arrives at the top of the FIFO. It
            /// should be noted that the Parity Error (PE) bit (UART_LSR[2]) is set if a break
            /// interrupt has occurred, as indicated by Break Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no parity error
            /// 1: parity error Reading the UART_LSR clears the PE bit.
            PE: u1,
            /// Framing Error This is used to indicate the occurrence of a framing error in the
            /// receiver. A framing error occurs when the receiver does not detect a valid STOP
            /// bit in the received data. In the FIFO mode, since the framing error is
            /// associated with a character received, it is revealed when the character with the
            /// framing error is at the top of the FIFO. When a framing error occurs, the UART
            /// tries to resynchronize. It does this by assuming that the error was due to the
            /// start bit of the next character and then continues receiving the other bit i.e.
            /// data, and/or parity and stop. It should be noted that the Framing Error (FE) bit
            /// (UART_LSR[3]) is set if a break interrupt has occurred, as indicated by Break
            /// Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no framing error
            /// 1: framing error Reading the UART_LSR clears the FE bit.
            FE: u1,
            /// Break Interrupt This is used to indicate the detection of a break sequence on
            /// the serial input data. If in UART mode (SIR_MODE == Disabled), it is set when
            /// the serial input, sir_in, is held in a logic '0' state for longer than the sum
            /// of + + + . If in infrared mode (SIR_MODE == Enabled), it is set when the serial
            /// input, sir_in, is continuously pulsed to logic '0' for longer than the sum of +
            /// + + . A break condition on serial input causes one and only one character,
            /// consisting of all zeros, to be received by the UART. In the FIFO mode, the
            /// character associated with the break condition is carried through the FIFO and is
            /// revealed when the character is at the top of the FIFO. Reading the UART_LSR
            /// clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately
            /// and persists until the UART_LSR is read.
            BI: u1,
            /// TX Holding Register Empty If the FIFOs are disabled, this bit is set to "1" when
            /// the TX Holding Register (UART_THR) is empty and ready to accept new data and it
            /// is cleared when the CPU writes to the TX Holding Register. If the FIFOs are
            /// enabled, this bit is set to "1" whenever the TX FIFO is empty and it is cleared
            /// when at least one byte is written to the TX FIFO.
            THRE: u1,
            /// Transmitter Empty If the FIFOs are disabled, this bit is set to "1" whenever the
            /// TX Holding Register (UART_THR) and the TX Shift Register are empty. If the FIFOs
            /// are enabled, this bit is set whenever the TX FIFO and the TX Shift Register are
            /// empty. In both cases, this bit is cleared when a byte is written to the TX data
            /// channel.
            TEMT: u1,
            /// RX Data Error in FIFO When FIFOs are disabled, this bit is always 0. When FIFOs
            /// are enabled, this bit is set to “1” when there is at least one PE, FE, or BI
            /// in the RX FIFO. It is cleared by reading from the UART_LSR register, there are
            /// no subsequent errors in the FIFO.
            FIFOERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2500c10
        /// UART Modem Control Register
        pub const UART_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Terminal Ready This is used to directly control the Data Terminal Ready
            /// (dtr_n) output. The value written to this location is inverted and driven out on
            /// dtr_n.
            /// 0: dtr_n de-asserted (logic 1)
            /// 1: dtr_n asserted (logic 0) The DTR output is used to inform the modem or data
            /// set that the UART is ready to establish communications. Note that in Loopback
            /// mode (UART_MCR[4] is set to 1), the dtr_n output is held inactive high while the
            /// value of this location is internally looped back to an input.
            DTR: u1,
            /// Request to Send This is used to directly control the Request to Send (rts_n)
            /// output. The RTS (rts_n) output is used to inform the modem or data set that the
            /// UART is ready to exchange data. When Auto RTS Flow Control is not enabled ( is
            /// set to 0), the rts_n signal is set low by programming UART_MCR[1] (RTS) to a
            /// high. In Auto Flow Control, AFCE_MODE == Enabled and active ( is set to 1) and
            /// FIFOs enable (UART_FCR[0] is set to 1), the rts_n output is controlled in the
            /// same way, but is also gated with the receiver FIFO threshold trigger (rts_n is
            /// inactive high when above the threshold). The rts_n signal is de-asserted when
            /// UART_MCR[1] is set low.
            /// 0: rts_n de-asserted (logic 1)
            /// 1: rts_n asserted (logic 0) Note that in Loopback mode (UART_MCR[4] is set to
            /// 1), the rts_n output is held inactive high while the value of this location is
            /// internally looped back to an input.
            RTS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Loop Back Mode
            /// 0: Normal Mode
            /// 1: Loop Back Mode This is used to put the UART into a diagnostic mode for test
            /// purposes. If operating in UART mode (SIR_MODE != Enabled or not active,
            /// UART_MCR[6] is set to 0), the data on the SOUT line is held high, while serial
            /// data output is looped back to the sin line, internally. In this mode, all the
            /// interrupts are fully functional. Also, in loopback mode, the modem control
            /// inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control
            /// outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs,
            /// internally. If operating in infrared mode (SIR_MODE == Enabled AND active,
            /// UART_MCR[6] is set to 1), the data on the sir_out_n line is held low, while
            /// serial data output is inverted and looped back to the sir_in line.
            LOOP: u1,
            /// Auto Flow Control Enable When FIFOs are enabled and the AFCE bit is set, the
            /// AutoFlow Control is enabled.
            /// 0: Auto Flow Control mode disabled
            /// 1: Auto Flow Control mode enabled
            AFCE: u1,
            /// Select IrDA or RS485
            /// 00: UART Mode
            /// 01: IrDA SIR Mode
            /// 10: RS485 Mode
            /// 11: Reserved
            UART_FUNCTION: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2500c18
        /// UART Modem Status Register
        pub const UART_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta Clear to Send This is used to indicate that the modem control line cts_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on ctsdsr_n since the last read of UART_MSR
            /// 1: change on ctsdsr_n since the last read of UART_MSR Reading the UART_MSR
            /// clears the DCTS bit. In Loopback Mode (UART_MCR[4] = 1), the DCTS reflects
            /// changes on the RTS (UART_MCR[1]).
            DCTS: u1,
            /// Delta Data Set Ready This is used to indicate that the modem control line dsr_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on dsr_n since the last read of UART_MSR
            /// 1: change on dsr_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDSR bit. In Loopback Mode (UART_MCR[4] = 1), the DDSR reflects changes on
            /// the DTR (UART_MCR[0] .
            DDSR: u1,
            /// Trailing Edge Ring Indicator This is used to indicate that a change in the input
            /// ri_n (from an active-low to an inactive-high state) has occurred since the last
            /// time the UART_MSR was read.
            /// 0: no change on ri_n since the last read of UART_MSR
            /// 1: change on ri_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the TERI bit.
            TERI: u1,
            /// Delta Data Carrier Detect This is used to indicate that the modem control line
            /// dcd_n has changed since the last time the UART_MSR was read.
            /// 0: no change on dcd_n since the last read of UART_MSR
            /// 1: change on dcd_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDCD bit.
            DDCD: u1,
            /// Line State of Clear To Send This is used to indicate the current state of the
            /// modem control line cts_n. This bit is the complement of cts_n. When the Clear to
            /// Send input (cts_n) is asserted, it is an indication that the modem or data set
            /// is ready to exchange data with UART.
            /// 0: cts_n input is de-asserted (logic 1)
            /// 1: cts_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] = 1), the CTS
            /// is the same as the RTS (UART_MCR[1]).
            CTS: u1,
            /// Line State of Data Set Ready This is used to indicate the current state of the
            /// modem control line dsr_n. This bit is the complement of the dsr_n. When the Data
            /// Set Ready input (dsr_n) is asserted, it is an indication that the modem or data
            /// set is ready to establish communication with UART.
            /// 0: dsr_n input is de-asserted (logic 1)
            /// 1: dsr_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] is set to 1),
            /// the DSR is the same as the DTR (UART_MCR[0]).
            DSR: u1,
            /// Line State of Ring Indicator This is used to indicate the current state of the
            /// modem control line ri_n. This bit is the complement of ri_n. When the Ring
            /// Indicator input (ri_n) is asserted it is an indication that a telephone ringing
            /// signal has been received by setting the modem or data.
            /// 0: ri_n input is de-asserted (logic 1)
            /// 1: ri_n input is asserted (logic 0)
            RI: u1,
            /// Line State of Data Carrier Detect This is used to indicate the current state of
            /// the modem control line dcd_n. This bit is the complement of dcd_n. When the Data
            /// Carrier Detect input (dcd_n) is asserted it is an indication that the carrier
            /// has been detected by the modem or data set.
            /// 0: dcd_n input is de-asserted (logic 1)
            /// 1: dcd_n input is asserted (logic 0)
            DCD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2500c00
        /// UART Receive Buffer Register
        pub const UART_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Buffer Register Data byte received on the serial input port (sin) in
            /// UART mode, or the serial infrared input (sir_in) in infrared mode. The data in
            /// this register is valid only if the Data Ready (DR) bit in is set. If in FIFO
            /// mode and FIFOs are enabled (The [0] is set to 1), this register accesses the
            /// head of the receive FIFO. If the receive FIFO is full and this register can not
            /// read before the next data character arrives, then the data already in the FIFO
            /// are preserved, but any incoming data are lost and an overrun error occurs.
            RBR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2500c84
        /// UART Receive FIFO Level Register
        pub const UART_RFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Level The bit indicates the number of data entries in the RX FIFO.
            /// UART_RXDMA_CTRL
            RFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x84);

        /// address: 0x2500d18
        /// UART_RXDMA_BL
        pub const UART_RXDMA_BL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Length Unit is byte Note that this field is only configurable while RXDMA
            /// Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x2500d00
        /// UART_RXDMA_CTRL
        pub const UART_RXDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            /// 0: RXDMA Disable
            /// 1: RXDMA Enable Note that if the software turns off this bit, the RXDMA will
            /// stop after the current block transfer completes, then the software should do a
            /// reset to the RX FIFO before re-enable.
            RXDMA: u1,
            /// Mode
            /// 0: Continous
            /// 1: Limited When data transferred reaches the limited count set in RXDMA LIMIT,
            /// the DMA stops and the RXDMA Start bit is cleared automatically. Note that this
            /// field is only configurable while RXDMA Busy is 0.
            RXDMA: u1,
            /// BLK SIZE Every time when data entries in RX FIFO reach BLK_SIZE, start a DMA
            /// block transfer. It is recommended that the block size no more than RX FIFO
            /// Depth.
            /// 00: 8 bytes
            /// 01: 16 bytes
            /// 10: 32 bytes
            /// 11: 64 bytes Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// AHB Burst Mode Set for AHB port burst supported INCR8 is recommended, while
            /// INCR16 may be unsupported due to the system bus.
            /// 00: SIGNLE
            /// 01: INCR4
            /// 10: INCR8
            /// 11: INCR16 Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// Timeout Enable Once enable, the DMA starts a transfer even the data entries in
            /// RX FIFO do not reach BLK_SIZE. Note that this field is only configurable when
            /// RXDMA Busy is 0.
            RXDMA: u1,
            reserved0: u1,
            /// Timeout Threshold Unit is 1 UART bit time Note that this field is only
            /// configurable when RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x2500d38
        /// UART_RXDMA_DCNT
        pub const UART_RXDMA_DCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Count Only valid while RXDMA Mode is set to 1, it is used for counting the
            /// data transferred by RXDMA, and is cleared when reaches RXDMA Limit Size. Its
            /// unit is byte.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x2500d20
        /// UART_RXDMA_IE
        pub const UART_RXDMA_IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done RXDMA Limit Done Interrupt Enable
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done RXDMA BLK Done Interrupt Enable
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done RXDMA Timeout Done Interrupt Enable
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun RXDMA Buffer Overrun Interrupt Enable
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x2500d24
        /// UART_RXDMA_IS
        pub const UART_RXDMA_IS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done Asserted when data transferred reaches limit size in RXDMA
            /// Limit Mode.
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done Asserted when a DMA block transfer is done.
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done Asserted when a DMA transfer caused by timeout is done.
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun Asserted when the RXDMA buffer is overflow.
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x2500d0c
        /// UART_RXDMA_LMT
        pub const UART_RXDMA_LMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit Size Only valid when RXDMA Mode is set to 1, and the unit is byte. Note
            /// that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x2500d34
        /// UART_RXDMA_RADDRH
        pub const UART_RXDMA_RADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[33:32] Software should update this register after reading
            /// data in RXDMA Buffer in time. It is byte address. The software should not update
            /// Buffer Read Address Register until until UART_RXDMA_STA[1] is 0. The software
            /// should update Read Address High Register first and then Read Address Low
            /// Register , even there is no change on Read Address High Register.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x2500d30
        /// UART_RXDMA_RADDRL
        pub const UART_RXDMA_RADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[31:0] Software should update this register after reading
            /// data in RXDMA Buffer in time It is byte address. The software should not update
            /// Buffer Read Address Register until UART_RXDMA_STA[1] is 0. The software should
            /// update Read Address High Register first, and then Read Address Low Register,
            /// even there is no change on Read Address High Register.
            RXDMA: u32,
        }), base_address + 0x130);

        /// address: 0x2500d14
        /// UART_RXDMA_SADDRH
        pub const UART_RXDMA_SADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [33:32] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x114);

        /// address: 0x2500d10
        /// UART_RXDMA_SADDRL
        pub const UART_RXDMA_SADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [31:0] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u32,
        }), base_address + 0x110);

        /// address: 0x2500d08
        /// UART_RXDMA_STA
        pub const UART_RXDMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// BUSY
            /// 0: RXDMA is idle
            /// 1: RXDMA is busy
            RXDMA: u1,
            /// Buffer Read Address Updating
            /// 0: Buffer Read Address Register is ready for updating
            /// 1: Buffer Read Address Register is busy for updating The software should not
            /// update Buffer Read Address Register until this bit is 0.
            BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x108);

        /// address: 0x2500d04
        /// UART_RXDMA_STR
        pub const UART_RXDMA_STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Only valid when RXDMA mode is set to 1, it is auto cleared when data
            /// transferred reaches the RXDMA Limit Size.
            RXDMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x2500d2c
        /// UART_RXDMA_WADDRH
        pub const UART_RXDMA_WADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[33:32] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x12c);

        /// address: 0x2500d28
        /// UART_RXDMA_WADDRL
        pub const UART_RXDMA_WADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[31:0] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u32,
        }), base_address + 0x128);

        /// address: 0x2500c1c
        /// UART Scratch Register
        pub const UART_SCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scratch Register This register is for programmers to use as a temporary storage
            /// space. It has no defined purpose in the UART.
            SCRATCH_REG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x2500c80
        /// UART Transmit FIFO Level Register
        pub const UART_TFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Level The bit indicates the number of data entries in the TX FIFO.
            TFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x80);

        /// address: 0x2500c00
        /// UART Transmit Holding Register
        pub const UART_THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Holding Register Data is transmitted on the serial output port (SOUT)
            /// in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data
            /// should only be written to the when the THRE bit ( ) is set. If in FIFO mode and
            /// FIFOs are enabled ( = 1) and THRE is set, the 16 number of characters data may
            /// be written to the before the FIFO is full. When the FIFO is full, any written
            /// data results in the written data being lost.
            THR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2500c7c
        /// UART Status Register
        pub const UART_USR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART Busy Bit
            /// 0: Idle or inactive
            /// 1: Busy
            BUSY: u1,
            /// TX FIFO Not Full This is used to indicate that the TX FIFO is not full.
            /// 0: TX FIFO is full
            /// 1: TX FIFO is not full This bit is cleared when the TX FIFO is full.
            TFNF: u1,
            /// TX FIFO Empty This is used to indicate that the TX FIFO is completely empty.
            /// 0: TX FIFO is not empty
            /// 1: TX FIFO is empty This bit is cleared when the TX FIFO is no longer empty.
            TFE: u1,
            /// RX FIFO Not Empty This is used to indicate that the RX FIFO contains one or more
            /// entries.
            /// 0: RX FIFO is empty
            /// 1: RX FIFO is not empty This bit is cleared when the RX FIFO is empty.
            RFNE: u1,
            /// RX FIFO Full This is used to indicate that the RX FIFO is completely full.
            /// 0: RX FIFO not full
            /// 1: RX FIFO Full This bit is cleared when the RX FIFO is no longer full.
            RFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);
    };

    /// UART4
    pub const UART4 = struct {
        pub const base_address = 0x2501000;

        /// address: 0x25010b4
        /// UART Debug DLH Register
        pub const UART_DBG_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLH
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x25010b0
        /// UART Debug DLL Register
        pub const UART_DBG_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLL
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x2501004
        /// UART Divisor Latch High Register
        pub const UART_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch High Upper 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( [7]) is set and the UART is not busy ( [0] is 0). The output
            /// baud rate is equal to the serial clock (SCLK) frequency divided by sixteen times
            /// the value of the baud rate divisor, as follows: . Note that when the Divisor
            /// Latch Registers ( and ) is set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLH is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2501000
        /// UART Divisor Latch Low Register
        pub const UART_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch Low Lower 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( ) is set and the UART is not busy ( is 0). The output baud
            /// rate is equal to the serial clock (SCLK) frequency divided by sixteen times the
            /// value of the baud rate divisor, as follows: . Note that when the Divisor Latch
            /// Registers ( and ) are set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLL is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250108c
        /// UART DMA Request Enable Register
        pub const UART_DMA_REQ_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA RX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_RX_REQ_ENABLE: u1,
            /// DMA TX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TX_REQ_ENABLE: u1,
            /// DMA Timeout Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TIMEOUT_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8c);

        /// address: 0x25010f0
        /// UART_FCC
        pub const UART_FCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            RX: u1,
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            TX: u1,
            /// Clock Mode
            /// 0: Sync mode, writing/reading clocks use apb clock
            /// 1: Sync mode, writing clock uses apb clock, reading clock uses ahb clock
            RXFIFO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Depth Indicates the depth of TX/RX FIFO
            FIFO: u24,
        }), base_address + 0xf0);

        /// address: 0x2501008
        /// UART FIFO Control Register
        pub const UART_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable FIFOs The bit enables/disables the transmitting (XMIT) and receiving
            /// (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR
            /// controller part of FIFOs is reset.
            FIFOE: u1,
            /// RCVR FIFO Reset The bit resets the control part of the receive FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA RX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            RFIFOR: u1,
            /// XMIT FIFO Reset The bit resets the control part of the transfer FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA TX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            XFIFOR: u1,
            /// DMA Mode
            /// 0: Mode 0 In this mode, when the PTE in UART_HALT is high and TX FIFO is
            /// enabled, the TX DMA request will be set when the TFL in UART_TFL is less than or
            /// equal to FIFO Trigger Level (otherwise it will be cleared). When the PTE is high
            /// and TX FIFO is disabled, the TX DMA request will be set only if the THR in
            /// UART_THR is empty. If the PTE is low, the TX DMA request will be set only if the
            /// TX FIFO (TX FIFO enabled) or THR (TX FIFO disabled) is empty. When the
            /// DMA_PTE_RX in UART_HALT is high and RX FIFO is enabled, the RX DRQ will be set
            /// only if the RFL in UART_RFL is equal to or more than FIFO Trigger Level,
            /// otherwise, it will be cleared.
            /// 1: Mode 1 In this mode, TX FIFO should be enabled. If the PTE in is high, the TX
            /// DMA request will be set when the TFL in is less than or equal to FIFO Trigger
            /// Level; If the PTE is low, the TX DMA request will be set when TX FIFO is empty.
            /// Once the request is set, it is cleared only when TX FIFO is full. If the RFL in
            /// UART_RFL is equal to or more than FIFO Trigger Level or there is a character
            /// timeout, the RX DRQ will be set; Once the RX DRQ is set, it is cleared only when
            /// RX FIFO (RX FIFO enabled) or RBR (RX FIFO disabled) is empty.
            DMAM: u1,
            /// TX Empty Trigger This is used to select the empty threshold level when the THRE
            /// Interrupts are generated and the mode is active. It also determines when the
            /// dma_tx_req_n signal is asserted in certain modes of operation.
            /// 00: FIFO empty
            /// 01: 2 characters in the FIFO
            /// 10: FIFO ¼ full
            /// 11: FIFO ½ full
            TFT: u2,
            /// RCVR Trigger This is used to select the trigger level in the receiver FIFO when
            /// the Received Data Available Interrupt is generated. In the autoflow control
            /// mode, it is used to determine when the rts_n signal is de-asserted. It also
            /// determines when the dma_rx_req_n signal is asserted in certain modes of
            /// operation.
            /// 00: 1 character in the FIFO
            /// 01: FIFO ¼ full
            /// 10: FIFO ½ full
            /// 11: FIFO-2 less than full
            RT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x25010a4
        /// UART Halt TX Register
        pub const UART_HALT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Halt TX This register is used to halt transmissions for testing, so that the
            /// transmit FIFO can be filled by the master when FIFOs are implemented and
            /// enabled. 0 : Halt TX disabled 1 : Halt TX enabled
            HALT_TX: u1,
            /// This is an enable bit for the user to change LCR register configuration and baud
            /// rate register (UART_DLH and UART_DLL) when the UART is busy.
            /// 1: Enable change when busy
            CHCFG_AT_BUSY: u1,
            /// After the user uses UART_HALT[1] to change the baud rate or LCR configuration,
            /// write 1 to update the configuration and wait this bit to self-clear to 0 to
            /// finish update process. Writing 0 to this bit has no effect.
            /// 1: Update trigger, self-clear to 0 when finish update.
            CHANGE_UPDATE: u1,
            reserved0: u1,
            /// SIR TX Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            SIR_TX_INVERT: u1,
            /// SIR RX Pulse Polarity Invert
            /// 0: Not invert receiver signal
            /// 1: Invert receiver signal
            SIR_RX_INVERT: u1,
            /// The Transmission of RX_DRQ In DMA1 mode, when RFL is more than or equal to the
            /// trigger value, or a receive timeout has occurred, the controller sends DRQ. In
            /// DMA0 mode, when DMA_PTE_RX = 1 and FIFO is on, if RFL is more than or equal to
            /// trig, the controller sends DRQ, else DRQ is cleared. In other cases, once the
            /// received data is valid, the controller sends DRQ.
            DMA_PTE_RX: u1,
            /// The sending of TX_REQ In DMA1 mode (FIFO on), if the PTE is set to 1 when the
            /// TFL in UART_TFL is less than or equal to the trigger value, the controller sends
            /// the DMA request. If the PTE is set to 0, when FIFO is empty, the controller
            /// sends the DMA request. The DMA request will stop when FIFO is full. In DMA0
            /// mode, if the PTE is set to 1 and FIFO is on, when the TFL in UART_TFL is less
            /// than or equal to the trigger value, the controller sends DMA request. If the PTE
            /// is set to 1 and FIFO off, when the THR in UART_THR is empty, the controller
            /// sends DMA request. If the PTE is set to 0, when FIFO(FIFO Enable) or THR(FIFO
            /// Enable) is empty, the controller sends DMA request. Otherwise, the DMA request
            /// is cleared.
            PTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x2501088
        /// UART DMA Handshake Configuration Register
        pub const UART_HSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake configuration
            /// 0xA5: DMA wait cycle mode
            /// 0xE5: DMA handshake mode
            HANDSHAKE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x2501004
        /// UART Interrupt Enable Register
        pub const UART_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Received Data Available Interrupt This is used to enable/disable the
            /// generation of Received Data Available Interrupt and the Character Timeout
            /// Interrupt (if in FIFO mode and FIFOs enabled). These are the second-highest
            /// priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ERBFI: u1,
            /// Enable Transmit Holding Register Empty Interrupt This is used to enable/disable
            /// the generation of Transmitter Holding Register Empty Interrupt. This is the
            /// third-highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ETBEI: u1,
            /// Enable Receiver Line Status Interrupt This is used to enable/disable the
            /// generation of Receiver Line Status Interrupt. This is the highest priority
            /// interrupt.
            /// 0: Disable
            /// 1: Enable
            ELSI: u1,
            /// Enable Modem Status Interrupt This is used to enable/disable the generation of
            /// Modem Status Interrupt. This is the fourth highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            EDSSI: u1,
            /// RS485 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RS485_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Programmable THRE Interrupt Mode Enable This is used to enable/disable the
            /// generation of THRE Interrupt.
            /// 0: Disable
            /// 1: Enable
            PTIME: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2501008
        /// UART Interrupt Identity Register
        pub const UART_IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID This indicates the highest priority pending interrupt which can be
            /// one of the following types.
            /// 0000: modem status
            /// 0001: no interrupt pending
            /// 0010: THR empty
            /// 0011: RS485 Interrupt
            /// 0100: received data available
            /// 0110: receiver line status
            /// 0111: busy detect
            /// 1100: character timeout The bit 3 indicates an interrupt can only occur when the
            /// FIFOs are enabled and used to distinguish a Character Timeout condition
            /// interrupt.
            IID: u4,
            reserved0: u1,
            reserved1: u1,
            /// FIFOs Enable Flag This is used to indicate whether the FIFOs are enabled or
            /// disabled.
            /// 00: Disable
            /// 11: Enable
            FEFLAG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x250100c
        /// UART Line Control Register
        pub const UART_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Length Select It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the count of bits in a transmitted
            /// or received frame.
            /// 00: 5 bits
            /// 01: 6 bits
            /// 10: 7 bits
            /// 11: 8 bits
            DLS: u2,
            /// Number of stop bits It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the number of stop bits per
            /// character that the peripheral transmits and receives. If set to 0, one stop bit
            /// is transmitted in the serial data. If set to 1 and the data bits are set to 5
            /// (UART_LCR[1:0] is 0), one and a half stop bit is transmitted. Otherwise, two
            /// stop bits are transmitted. Note that regardless of the number of stop bits
            /// selected, the receiver checks only the first stop bit.
            /// 0: 1 stop bit
            /// 1: 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit
            STOP: u1,
            /// Parity Enable It is writable only when UART is not busy (UART_USR[0] is 0) and
            /// always readable. This bit is used to enable and disable parity generation and
            /// detection in transmitted and received serial characters respectively.
            /// 0: Parity disabled
            /// 1: Parity enabled
            PEN: u1,
            /// Even Parity Select It is writable only when UART is not busy (UART_USR[0] is 0).
            /// This is used to select the even and odd parity when the PEN is enabled (the
            /// UART_LCR[3] is set to 1). Setting the UART_LCR[5] is unset to reverse the
            /// LCR[4].
            /// 00: Odd Parity
            /// 01: Even Parity 1X: Reverse LCR[4] In RS485 mode, it is the 9th bit--address
            /// bit.
            /// 11: 9th bit = 0, indicates that this is a data byte.
            /// 10: 9th bit = 1, indicates that this is an address byte.
            EPS: u2,
            /// Break Control Bit This is used to cause a break condition to be transmitted to
            /// the receiving device. If set to 0, the serial output is forced to the spacing
            /// (logic 0) state. When not in Loopback mode, as determined by UART_MCR[4], the
            /// SOUT line is forced low until the Break bit is cleared. If SIR_MODE is enabled
            /// and active (UART_MCR[6] is set to 1), the sir_out_n line is continuously pulsed.
            /// When in Loopback mode, the break condition is internally looped back to the
            /// receiver and the sir_out_n line is forced low.
            BC: u1,
            /// Divisor Latch Access Bit It is writable only when UART is not busy (UART_USR[0]
            /// is 0) and always readable. This bit is used to enable the reading and writing of
            /// the Divisor Latch register (UART_DLL and UART_DLH) to set the baud rate of the
            /// UART. This bit must be cleared after the initial baud rate setup in order to
            /// access other registers.
            /// 0: Select RX Buffer Register (UART_RBR)/TX Holding Register (UART_THR) and
            /// Interrupt Enable Register (UART_IER)
            /// 1: Select Divisor Latch LS Register (UART_DLL) and Divisor Latch MS Register
            /// (UART_DLM)
            DLAB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2501014
        /// UART Line Status Register
        pub const UART_LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready This is used to indicate that the receiver contains at least one
            /// character in the UART_RBR or the receiver FIFO.
            /// 0: no data ready
            /// 1: data ready This bit is cleared when the UART_RBR is read in non-FIFO mode, or
            /// when the receiver FIFO is empty, in FIFO mode.
            DR: u1,
            /// Overrun Error This occurs if a new data character was received before the
            /// previous data was read. In the non-FIFO mode, the OE bit is set when a new
            /// character arrives in the receiver before the previous character was read from
            /// the UART_RBR. When this happens, the data in the UART_RBR is overwritten. In the
            /// FIFO mode, an overrun error occurs when the FIFO is full and a new character
            /// arrives at the receiver. The data in the FIFO is retained and the data in the
            /// receive shift register is lost.
            /// 0: no overrun error
            /// 1: overrun error Reading the UART_LSR clears the OE bit.
            OE: u1,
            /// Parity Error This is used to indicate the occurrence of a parity error in the
            /// receiver if the Parity Enable (PEN) bit (UART_LCR[3]) is set. In the FIFO mode,
            /// since the parity error is associated with a character received, it is revealed
            /// when the character with the parity error arrives at the top of the FIFO. It
            /// should be noted that the Parity Error (PE) bit (UART_LSR[2]) is set if a break
            /// interrupt has occurred, as indicated by Break Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no parity error
            /// 1: parity error Reading the UART_LSR clears the PE bit.
            PE: u1,
            /// Framing Error This is used to indicate the occurrence of a framing error in the
            /// receiver. A framing error occurs when the receiver does not detect a valid STOP
            /// bit in the received data. In the FIFO mode, since the framing error is
            /// associated with a character received, it is revealed when the character with the
            /// framing error is at the top of the FIFO. When a framing error occurs, the UART
            /// tries to resynchronize. It does this by assuming that the error was due to the
            /// start bit of the next character and then continues receiving the other bit i.e.
            /// data, and/or parity and stop. It should be noted that the Framing Error (FE) bit
            /// (UART_LSR[3]) is set if a break interrupt has occurred, as indicated by Break
            /// Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no framing error
            /// 1: framing error Reading the UART_LSR clears the FE bit.
            FE: u1,
            /// Break Interrupt This is used to indicate the detection of a break sequence on
            /// the serial input data. If in UART mode (SIR_MODE == Disabled), it is set when
            /// the serial input, sir_in, is held in a logic '0' state for longer than the sum
            /// of + + + . If in infrared mode (SIR_MODE == Enabled), it is set when the serial
            /// input, sir_in, is continuously pulsed to logic '0' for longer than the sum of +
            /// + + . A break condition on serial input causes one and only one character,
            /// consisting of all zeros, to be received by the UART. In the FIFO mode, the
            /// character associated with the break condition is carried through the FIFO and is
            /// revealed when the character is at the top of the FIFO. Reading the UART_LSR
            /// clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately
            /// and persists until the UART_LSR is read.
            BI: u1,
            /// TX Holding Register Empty If the FIFOs are disabled, this bit is set to "1" when
            /// the TX Holding Register (UART_THR) is empty and ready to accept new data and it
            /// is cleared when the CPU writes to the TX Holding Register. If the FIFOs are
            /// enabled, this bit is set to "1" whenever the TX FIFO is empty and it is cleared
            /// when at least one byte is written to the TX FIFO.
            THRE: u1,
            /// Transmitter Empty If the FIFOs are disabled, this bit is set to "1" whenever the
            /// TX Holding Register (UART_THR) and the TX Shift Register are empty. If the FIFOs
            /// are enabled, this bit is set whenever the TX FIFO and the TX Shift Register are
            /// empty. In both cases, this bit is cleared when a byte is written to the TX data
            /// channel.
            TEMT: u1,
            /// RX Data Error in FIFO When FIFOs are disabled, this bit is always 0. When FIFOs
            /// are enabled, this bit is set to “1” when there is at least one PE, FE, or BI
            /// in the RX FIFO. It is cleared by reading from the UART_LSR register, there are
            /// no subsequent errors in the FIFO.
            FIFOERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2501010
        /// UART Modem Control Register
        pub const UART_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Terminal Ready This is used to directly control the Data Terminal Ready
            /// (dtr_n) output. The value written to this location is inverted and driven out on
            /// dtr_n.
            /// 0: dtr_n de-asserted (logic 1)
            /// 1: dtr_n asserted (logic 0) The DTR output is used to inform the modem or data
            /// set that the UART is ready to establish communications. Note that in Loopback
            /// mode (UART_MCR[4] is set to 1), the dtr_n output is held inactive high while the
            /// value of this location is internally looped back to an input.
            DTR: u1,
            /// Request to Send This is used to directly control the Request to Send (rts_n)
            /// output. The RTS (rts_n) output is used to inform the modem or data set that the
            /// UART is ready to exchange data. When Auto RTS Flow Control is not enabled ( is
            /// set to 0), the rts_n signal is set low by programming UART_MCR[1] (RTS) to a
            /// high. In Auto Flow Control, AFCE_MODE == Enabled and active ( is set to 1) and
            /// FIFOs enable (UART_FCR[0] is set to 1), the rts_n output is controlled in the
            /// same way, but is also gated with the receiver FIFO threshold trigger (rts_n is
            /// inactive high when above the threshold). The rts_n signal is de-asserted when
            /// UART_MCR[1] is set low.
            /// 0: rts_n de-asserted (logic 1)
            /// 1: rts_n asserted (logic 0) Note that in Loopback mode (UART_MCR[4] is set to
            /// 1), the rts_n output is held inactive high while the value of this location is
            /// internally looped back to an input.
            RTS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Loop Back Mode
            /// 0: Normal Mode
            /// 1: Loop Back Mode This is used to put the UART into a diagnostic mode for test
            /// purposes. If operating in UART mode (SIR_MODE != Enabled or not active,
            /// UART_MCR[6] is set to 0), the data on the SOUT line is held high, while serial
            /// data output is looped back to the sin line, internally. In this mode, all the
            /// interrupts are fully functional. Also, in loopback mode, the modem control
            /// inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control
            /// outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs,
            /// internally. If operating in infrared mode (SIR_MODE == Enabled AND active,
            /// UART_MCR[6] is set to 1), the data on the sir_out_n line is held low, while
            /// serial data output is inverted and looped back to the sir_in line.
            LOOP: u1,
            /// Auto Flow Control Enable When FIFOs are enabled and the AFCE bit is set, the
            /// AutoFlow Control is enabled.
            /// 0: Auto Flow Control mode disabled
            /// 1: Auto Flow Control mode enabled
            AFCE: u1,
            /// Select IrDA or RS485
            /// 00: UART Mode
            /// 01: IrDA SIR Mode
            /// 10: RS485 Mode
            /// 11: Reserved
            UART_FUNCTION: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2501018
        /// UART Modem Status Register
        pub const UART_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta Clear to Send This is used to indicate that the modem control line cts_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on ctsdsr_n since the last read of UART_MSR
            /// 1: change on ctsdsr_n since the last read of UART_MSR Reading the UART_MSR
            /// clears the DCTS bit. In Loopback Mode (UART_MCR[4] = 1), the DCTS reflects
            /// changes on the RTS (UART_MCR[1]).
            DCTS: u1,
            /// Delta Data Set Ready This is used to indicate that the modem control line dsr_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on dsr_n since the last read of UART_MSR
            /// 1: change on dsr_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDSR bit. In Loopback Mode (UART_MCR[4] = 1), the DDSR reflects changes on
            /// the DTR (UART_MCR[0] .
            DDSR: u1,
            /// Trailing Edge Ring Indicator This is used to indicate that a change in the input
            /// ri_n (from an active-low to an inactive-high state) has occurred since the last
            /// time the UART_MSR was read.
            /// 0: no change on ri_n since the last read of UART_MSR
            /// 1: change on ri_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the TERI bit.
            TERI: u1,
            /// Delta Data Carrier Detect This is used to indicate that the modem control line
            /// dcd_n has changed since the last time the UART_MSR was read.
            /// 0: no change on dcd_n since the last read of UART_MSR
            /// 1: change on dcd_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDCD bit.
            DDCD: u1,
            /// Line State of Clear To Send This is used to indicate the current state of the
            /// modem control line cts_n. This bit is the complement of cts_n. When the Clear to
            /// Send input (cts_n) is asserted, it is an indication that the modem or data set
            /// is ready to exchange data with UART.
            /// 0: cts_n input is de-asserted (logic 1)
            /// 1: cts_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] = 1), the CTS
            /// is the same as the RTS (UART_MCR[1]).
            CTS: u1,
            /// Line State of Data Set Ready This is used to indicate the current state of the
            /// modem control line dsr_n. This bit is the complement of the dsr_n. When the Data
            /// Set Ready input (dsr_n) is asserted, it is an indication that the modem or data
            /// set is ready to establish communication with UART.
            /// 0: dsr_n input is de-asserted (logic 1)
            /// 1: dsr_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] is set to 1),
            /// the DSR is the same as the DTR (UART_MCR[0]).
            DSR: u1,
            /// Line State of Ring Indicator This is used to indicate the current state of the
            /// modem control line ri_n. This bit is the complement of ri_n. When the Ring
            /// Indicator input (ri_n) is asserted it is an indication that a telephone ringing
            /// signal has been received by setting the modem or data.
            /// 0: ri_n input is de-asserted (logic 1)
            /// 1: ri_n input is asserted (logic 0)
            RI: u1,
            /// Line State of Data Carrier Detect This is used to indicate the current state of
            /// the modem control line dcd_n. This bit is the complement of dcd_n. When the Data
            /// Carrier Detect input (dcd_n) is asserted it is an indication that the carrier
            /// has been detected by the modem or data set.
            /// 0: dcd_n input is de-asserted (logic 1)
            /// 1: dcd_n input is asserted (logic 0)
            DCD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2501000
        /// UART Receive Buffer Register
        pub const UART_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Buffer Register Data byte received on the serial input port (sin) in
            /// UART mode, or the serial infrared input (sir_in) in infrared mode. The data in
            /// this register is valid only if the Data Ready (DR) bit in is set. If in FIFO
            /// mode and FIFOs are enabled (The [0] is set to 1), this register accesses the
            /// head of the receive FIFO. If the receive FIFO is full and this register can not
            /// read before the next data character arrives, then the data already in the FIFO
            /// are preserved, but any incoming data are lost and an overrun error occurs.
            RBR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2501084
        /// UART Receive FIFO Level Register
        pub const UART_RFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Level The bit indicates the number of data entries in the RX FIFO.
            /// UART_RXDMA_CTRL
            RFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x84);

        /// address: 0x2501118
        /// UART_RXDMA_BL
        pub const UART_RXDMA_BL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Length Unit is byte Note that this field is only configurable while RXDMA
            /// Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x2501100
        /// UART_RXDMA_CTRL
        pub const UART_RXDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            /// 0: RXDMA Disable
            /// 1: RXDMA Enable Note that if the software turns off this bit, the RXDMA will
            /// stop after the current block transfer completes, then the software should do a
            /// reset to the RX FIFO before re-enable.
            RXDMA: u1,
            /// Mode
            /// 0: Continous
            /// 1: Limited When data transferred reaches the limited count set in RXDMA LIMIT,
            /// the DMA stops and the RXDMA Start bit is cleared automatically. Note that this
            /// field is only configurable while RXDMA Busy is 0.
            RXDMA: u1,
            /// BLK SIZE Every time when data entries in RX FIFO reach BLK_SIZE, start a DMA
            /// block transfer. It is recommended that the block size no more than RX FIFO
            /// Depth.
            /// 00: 8 bytes
            /// 01: 16 bytes
            /// 10: 32 bytes
            /// 11: 64 bytes Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// AHB Burst Mode Set for AHB port burst supported INCR8 is recommended, while
            /// INCR16 may be unsupported due to the system bus.
            /// 00: SIGNLE
            /// 01: INCR4
            /// 10: INCR8
            /// 11: INCR16 Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// Timeout Enable Once enable, the DMA starts a transfer even the data entries in
            /// RX FIFO do not reach BLK_SIZE. Note that this field is only configurable when
            /// RXDMA Busy is 0.
            RXDMA: u1,
            reserved0: u1,
            /// Timeout Threshold Unit is 1 UART bit time Note that this field is only
            /// configurable when RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x2501138
        /// UART_RXDMA_DCNT
        pub const UART_RXDMA_DCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Count Only valid while RXDMA Mode is set to 1, it is used for counting the
            /// data transferred by RXDMA, and is cleared when reaches RXDMA Limit Size. Its
            /// unit is byte.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x2501120
        /// UART_RXDMA_IE
        pub const UART_RXDMA_IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done RXDMA Limit Done Interrupt Enable
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done RXDMA BLK Done Interrupt Enable
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done RXDMA Timeout Done Interrupt Enable
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun RXDMA Buffer Overrun Interrupt Enable
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x2501124
        /// UART_RXDMA_IS
        pub const UART_RXDMA_IS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done Asserted when data transferred reaches limit size in RXDMA
            /// Limit Mode.
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done Asserted when a DMA block transfer is done.
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done Asserted when a DMA transfer caused by timeout is done.
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun Asserted when the RXDMA buffer is overflow.
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x250110c
        /// UART_RXDMA_LMT
        pub const UART_RXDMA_LMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit Size Only valid when RXDMA Mode is set to 1, and the unit is byte. Note
            /// that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x2501134
        /// UART_RXDMA_RADDRH
        pub const UART_RXDMA_RADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[33:32] Software should update this register after reading
            /// data in RXDMA Buffer in time. It is byte address. The software should not update
            /// Buffer Read Address Register until until UART_RXDMA_STA[1] is 0. The software
            /// should update Read Address High Register first and then Read Address Low
            /// Register , even there is no change on Read Address High Register.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x2501130
        /// UART_RXDMA_RADDRL
        pub const UART_RXDMA_RADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[31:0] Software should update this register after reading
            /// data in RXDMA Buffer in time It is byte address. The software should not update
            /// Buffer Read Address Register until UART_RXDMA_STA[1] is 0. The software should
            /// update Read Address High Register first, and then Read Address Low Register,
            /// even there is no change on Read Address High Register.
            RXDMA: u32,
        }), base_address + 0x130);

        /// address: 0x2501114
        /// UART_RXDMA_SADDRH
        pub const UART_RXDMA_SADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [33:32] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x114);

        /// address: 0x2501110
        /// UART_RXDMA_SADDRL
        pub const UART_RXDMA_SADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [31:0] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u32,
        }), base_address + 0x110);

        /// address: 0x2501108
        /// UART_RXDMA_STA
        pub const UART_RXDMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// BUSY
            /// 0: RXDMA is idle
            /// 1: RXDMA is busy
            RXDMA: u1,
            /// Buffer Read Address Updating
            /// 0: Buffer Read Address Register is ready for updating
            /// 1: Buffer Read Address Register is busy for updating The software should not
            /// update Buffer Read Address Register until this bit is 0.
            BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x108);

        /// address: 0x2501104
        /// UART_RXDMA_STR
        pub const UART_RXDMA_STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Only valid when RXDMA mode is set to 1, it is auto cleared when data
            /// transferred reaches the RXDMA Limit Size.
            RXDMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x250112c
        /// UART_RXDMA_WADDRH
        pub const UART_RXDMA_WADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[33:32] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x12c);

        /// address: 0x2501128
        /// UART_RXDMA_WADDRL
        pub const UART_RXDMA_WADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[31:0] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u32,
        }), base_address + 0x128);

        /// address: 0x250101c
        /// UART Scratch Register
        pub const UART_SCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scratch Register This register is for programmers to use as a temporary storage
            /// space. It has no defined purpose in the UART.
            SCRATCH_REG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x2501080
        /// UART Transmit FIFO Level Register
        pub const UART_TFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Level The bit indicates the number of data entries in the TX FIFO.
            TFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x80);

        /// address: 0x2501000
        /// UART Transmit Holding Register
        pub const UART_THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Holding Register Data is transmitted on the serial output port (SOUT)
            /// in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data
            /// should only be written to the when the THRE bit ( ) is set. If in FIFO mode and
            /// FIFOs are enabled ( = 1) and THRE is set, the 16 number of characters data may
            /// be written to the before the FIFO is full. When the FIFO is full, any written
            /// data results in the written data being lost.
            THR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250107c
        /// UART Status Register
        pub const UART_USR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART Busy Bit
            /// 0: Idle or inactive
            /// 1: Busy
            BUSY: u1,
            /// TX FIFO Not Full This is used to indicate that the TX FIFO is not full.
            /// 0: TX FIFO is full
            /// 1: TX FIFO is not full This bit is cleared when the TX FIFO is full.
            TFNF: u1,
            /// TX FIFO Empty This is used to indicate that the TX FIFO is completely empty.
            /// 0: TX FIFO is not empty
            /// 1: TX FIFO is empty This bit is cleared when the TX FIFO is no longer empty.
            TFE: u1,
            /// RX FIFO Not Empty This is used to indicate that the RX FIFO contains one or more
            /// entries.
            /// 0: RX FIFO is empty
            /// 1: RX FIFO is not empty This bit is cleared when the RX FIFO is empty.
            RFNE: u1,
            /// RX FIFO Full This is used to indicate that the RX FIFO is completely full.
            /// 0: RX FIFO not full
            /// 1: RX FIFO Full This bit is cleared when the RX FIFO is no longer full.
            RFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);
    };

    /// UART5
    pub const UART5 = struct {
        pub const base_address = 0x2501400;

        /// address: 0x25014b4
        /// UART Debug DLH Register
        pub const UART_DBG_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLH
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb4);

        /// address: 0x25014b0
        /// UART Debug DLL Register
        pub const UART_DBG_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLL
            DEBUG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x2501404
        /// UART Divisor Latch High Register
        pub const UART_DLH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch High Upper 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( [7]) is set and the UART is not busy ( [0] is 0). The output
            /// baud rate is equal to the serial clock (SCLK) frequency divided by sixteen times
            /// the value of the baud rate divisor, as follows: . Note that when the Divisor
            /// Latch Registers ( and ) is set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLH is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2501400
        /// UART Divisor Latch Low Register
        pub const UART_DLL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Divisor Latch Low Lower 8 bits of 16 bits, read/write, Divisor Latch Register
            /// contains the baud rate divisor for the UART. This register may only be accessed
            /// when the DLAB bit ( ) is set and the UART is not busy ( is 0). The output baud
            /// rate is equal to the serial clock (SCLK) frequency divided by sixteen times the
            /// value of the baud rate divisor, as follows: . Note that when the Divisor Latch
            /// Registers ( and ) are set to 0, the baud clock is disabled and no serial
            /// communications occur. Also, once the DLL is set, at least 8 clock cycles of the
            /// slowest UART clock should be allowed to pass before transmitting or receiving
            /// data.
            DLL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250148c
        /// UART DMA Request Enable Register
        pub const UART_DMA_REQ_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA RX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_RX_REQ_ENABLE: u1,
            /// DMA TX REQ Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TX_REQ_ENABLE: u1,
            /// DMA Timeout Enable
            /// 0: Disable
            /// 1: Enable
            DMA_TIMEOUT_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8c);

        /// address: 0x25014f0
        /// UART_FCC
        pub const UART_FCC = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            RX: u1,
            /// FIFO Clock Enable
            /// 0: Clock disable
            /// 1: Clock enable
            TX: u1,
            /// Clock Mode
            /// 0: Sync mode, writing/reading clocks use apb clock
            /// 1: Sync mode, writing clock uses apb clock, reading clock uses ahb clock
            RXFIFO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Depth Indicates the depth of TX/RX FIFO
            FIFO: u24,
        }), base_address + 0xf0);

        /// address: 0x2501408
        /// UART FIFO Control Register
        pub const UART_FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable FIFOs The bit enables/disables the transmitting (XMIT) and receiving
            /// (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR
            /// controller part of FIFOs is reset.
            FIFOE: u1,
            /// RCVR FIFO Reset The bit resets the control part of the receive FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA RX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            RFIFOR: u1,
            /// XMIT FIFO Reset The bit resets the control part of the transfer FIFO and treats
            /// the FIFO as empty. This also de-asserts the DMA TX request. It is
            /// 'self-cleared'. It is not necessary to clear this bit.
            XFIFOR: u1,
            /// DMA Mode
            /// 0: Mode 0 In this mode, when the PTE in UART_HALT is high and TX FIFO is
            /// enabled, the TX DMA request will be set when the TFL in UART_TFL is less than or
            /// equal to FIFO Trigger Level (otherwise it will be cleared). When the PTE is high
            /// and TX FIFO is disabled, the TX DMA request will be set only if the THR in
            /// UART_THR is empty. If the PTE is low, the TX DMA request will be set only if the
            /// TX FIFO (TX FIFO enabled) or THR (TX FIFO disabled) is empty. When the
            /// DMA_PTE_RX in UART_HALT is high and RX FIFO is enabled, the RX DRQ will be set
            /// only if the RFL in UART_RFL is equal to or more than FIFO Trigger Level,
            /// otherwise, it will be cleared.
            /// 1: Mode 1 In this mode, TX FIFO should be enabled. If the PTE in is high, the TX
            /// DMA request will be set when the TFL in is less than or equal to FIFO Trigger
            /// Level; If the PTE is low, the TX DMA request will be set when TX FIFO is empty.
            /// Once the request is set, it is cleared only when TX FIFO is full. If the RFL in
            /// UART_RFL is equal to or more than FIFO Trigger Level or there is a character
            /// timeout, the RX DRQ will be set; Once the RX DRQ is set, it is cleared only when
            /// RX FIFO (RX FIFO enabled) or RBR (RX FIFO disabled) is empty.
            DMAM: u1,
            /// TX Empty Trigger This is used to select the empty threshold level when the THRE
            /// Interrupts are generated and the mode is active. It also determines when the
            /// dma_tx_req_n signal is asserted in certain modes of operation.
            /// 00: FIFO empty
            /// 01: 2 characters in the FIFO
            /// 10: FIFO ¼ full
            /// 11: FIFO ½ full
            TFT: u2,
            /// RCVR Trigger This is used to select the trigger level in the receiver FIFO when
            /// the Received Data Available Interrupt is generated. In the autoflow control
            /// mode, it is used to determine when the rts_n signal is de-asserted. It also
            /// determines when the dma_rx_req_n signal is asserted in certain modes of
            /// operation.
            /// 00: 1 character in the FIFO
            /// 01: FIFO ¼ full
            /// 10: FIFO ½ full
            /// 11: FIFO-2 less than full
            RT: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x25014a4
        /// UART Halt TX Register
        pub const UART_HALT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Halt TX This register is used to halt transmissions for testing, so that the
            /// transmit FIFO can be filled by the master when FIFOs are implemented and
            /// enabled. 0 : Halt TX disabled 1 : Halt TX enabled
            HALT_TX: u1,
            /// This is an enable bit for the user to change LCR register configuration and baud
            /// rate register (UART_DLH and UART_DLL) when the UART is busy.
            /// 1: Enable change when busy
            CHCFG_AT_BUSY: u1,
            /// After the user uses UART_HALT[1] to change the baud rate or LCR configuration,
            /// write 1 to update the configuration and wait this bit to self-clear to 0 to
            /// finish update process. Writing 0 to this bit has no effect.
            /// 1: Update trigger, self-clear to 0 when finish update.
            CHANGE_UPDATE: u1,
            reserved0: u1,
            /// SIR TX Pulse Polarity Invert
            /// 0: Not invert transmit pulse
            /// 1: Invert transmit pulse
            SIR_TX_INVERT: u1,
            /// SIR RX Pulse Polarity Invert
            /// 0: Not invert receiver signal
            /// 1: Invert receiver signal
            SIR_RX_INVERT: u1,
            /// The Transmission of RX_DRQ In DMA1 mode, when RFL is more than or equal to the
            /// trigger value, or a receive timeout has occurred, the controller sends DRQ. In
            /// DMA0 mode, when DMA_PTE_RX = 1 and FIFO is on, if RFL is more than or equal to
            /// trig, the controller sends DRQ, else DRQ is cleared. In other cases, once the
            /// received data is valid, the controller sends DRQ.
            DMA_PTE_RX: u1,
            /// The sending of TX_REQ In DMA1 mode (FIFO on), if the PTE is set to 1 when the
            /// TFL in UART_TFL is less than or equal to the trigger value, the controller sends
            /// the DMA request. If the PTE is set to 0, when FIFO is empty, the controller
            /// sends the DMA request. The DMA request will stop when FIFO is full. In DMA0
            /// mode, if the PTE is set to 1 and FIFO is on, when the TFL in UART_TFL is less
            /// than or equal to the trigger value, the controller sends DMA request. If the PTE
            /// is set to 1 and FIFO off, when the THR in UART_THR is empty, the controller
            /// sends DMA request. If the PTE is set to 0, when FIFO(FIFO Enable) or THR(FIFO
            /// Enable) is empty, the controller sends DMA request. Otherwise, the DMA request
            /// is cleared.
            PTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x2501488
        /// UART DMA Handshake Configuration Register
        pub const UART_HSK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Handshake configuration
            /// 0xA5: DMA wait cycle mode
            /// 0xE5: DMA handshake mode
            HANDSHAKE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x88);

        /// address: 0x2501404
        /// UART Interrupt Enable Register
        pub const UART_IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Received Data Available Interrupt This is used to enable/disable the
            /// generation of Received Data Available Interrupt and the Character Timeout
            /// Interrupt (if in FIFO mode and FIFOs enabled). These are the second-highest
            /// priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ERBFI: u1,
            /// Enable Transmit Holding Register Empty Interrupt This is used to enable/disable
            /// the generation of Transmitter Holding Register Empty Interrupt. This is the
            /// third-highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            ETBEI: u1,
            /// Enable Receiver Line Status Interrupt This is used to enable/disable the
            /// generation of Receiver Line Status Interrupt. This is the highest priority
            /// interrupt.
            /// 0: Disable
            /// 1: Enable
            ELSI: u1,
            /// Enable Modem Status Interrupt This is used to enable/disable the generation of
            /// Modem Status Interrupt. This is the fourth highest priority interrupt.
            /// 0: Disable
            /// 1: Enable
            EDSSI: u1,
            /// RS485 Interrupt Enable
            /// 0: Disable
            /// 1: Enable
            RS485_INT_EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Programmable THRE Interrupt Mode Enable This is used to enable/disable the
            /// generation of THRE Interrupt.
            /// 0: Disable
            /// 1: Enable
            PTIME: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x2501408
        /// UART Interrupt Identity Register
        pub const UART_IIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt ID This indicates the highest priority pending interrupt which can be
            /// one of the following types.
            /// 0000: modem status
            /// 0001: no interrupt pending
            /// 0010: THR empty
            /// 0011: RS485 Interrupt
            /// 0100: received data available
            /// 0110: receiver line status
            /// 0111: busy detect
            /// 1100: character timeout The bit 3 indicates an interrupt can only occur when the
            /// FIFOs are enabled and used to distinguish a Character Timeout condition
            /// interrupt.
            IID: u4,
            reserved0: u1,
            reserved1: u1,
            /// FIFOs Enable Flag This is used to indicate whether the FIFOs are enabled or
            /// disabled.
            /// 00: Disable
            /// 11: Enable
            FEFLAG: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x250140c
        /// UART Line Control Register
        pub const UART_LCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Length Select It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the count of bits in a transmitted
            /// or received frame.
            /// 00: 5 bits
            /// 01: 6 bits
            /// 10: 7 bits
            /// 11: 8 bits
            DLS: u2,
            /// Number of stop bits It is writable only when UART is not busy (UART_USR[0] is 0)
            /// and always readable. This is used to select the number of stop bits per
            /// character that the peripheral transmits and receives. If set to 0, one stop bit
            /// is transmitted in the serial data. If set to 1 and the data bits are set to 5
            /// (UART_LCR[1:0] is 0), one and a half stop bit is transmitted. Otherwise, two
            /// stop bits are transmitted. Note that regardless of the number of stop bits
            /// selected, the receiver checks only the first stop bit.
            /// 0: 1 stop bit
            /// 1: 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit
            STOP: u1,
            /// Parity Enable It is writable only when UART is not busy (UART_USR[0] is 0) and
            /// always readable. This bit is used to enable and disable parity generation and
            /// detection in transmitted and received serial characters respectively.
            /// 0: Parity disabled
            /// 1: Parity enabled
            PEN: u1,
            /// Even Parity Select It is writable only when UART is not busy (UART_USR[0] is 0).
            /// This is used to select the even and odd parity when the PEN is enabled (the
            /// UART_LCR[3] is set to 1). Setting the UART_LCR[5] is unset to reverse the
            /// LCR[4].
            /// 00: Odd Parity
            /// 01: Even Parity 1X: Reverse LCR[4] In RS485 mode, it is the 9th bit--address
            /// bit.
            /// 11: 9th bit = 0, indicates that this is a data byte.
            /// 10: 9th bit = 1, indicates that this is an address byte.
            EPS: u2,
            /// Break Control Bit This is used to cause a break condition to be transmitted to
            /// the receiving device. If set to 0, the serial output is forced to the spacing
            /// (logic 0) state. When not in Loopback mode, as determined by UART_MCR[4], the
            /// SOUT line is forced low until the Break bit is cleared. If SIR_MODE is enabled
            /// and active (UART_MCR[6] is set to 1), the sir_out_n line is continuously pulsed.
            /// When in Loopback mode, the break condition is internally looped back to the
            /// receiver and the sir_out_n line is forced low.
            BC: u1,
            /// Divisor Latch Access Bit It is writable only when UART is not busy (UART_USR[0]
            /// is 0) and always readable. This bit is used to enable the reading and writing of
            /// the Divisor Latch register (UART_DLL and UART_DLH) to set the baud rate of the
            /// UART. This bit must be cleared after the initial baud rate setup in order to
            /// access other registers.
            /// 0: Select RX Buffer Register (UART_RBR)/TX Holding Register (UART_THR) and
            /// Interrupt Enable Register (UART_IER)
            /// 1: Select Divisor Latch LS Register (UART_DLL) and Divisor Latch MS Register
            /// (UART_DLM)
            DLAB: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x2501414
        /// UART Line Status Register
        pub const UART_LSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Ready This is used to indicate that the receiver contains at least one
            /// character in the UART_RBR or the receiver FIFO.
            /// 0: no data ready
            /// 1: data ready This bit is cleared when the UART_RBR is read in non-FIFO mode, or
            /// when the receiver FIFO is empty, in FIFO mode.
            DR: u1,
            /// Overrun Error This occurs if a new data character was received before the
            /// previous data was read. In the non-FIFO mode, the OE bit is set when a new
            /// character arrives in the receiver before the previous character was read from
            /// the UART_RBR. When this happens, the data in the UART_RBR is overwritten. In the
            /// FIFO mode, an overrun error occurs when the FIFO is full and a new character
            /// arrives at the receiver. The data in the FIFO is retained and the data in the
            /// receive shift register is lost.
            /// 0: no overrun error
            /// 1: overrun error Reading the UART_LSR clears the OE bit.
            OE: u1,
            /// Parity Error This is used to indicate the occurrence of a parity error in the
            /// receiver if the Parity Enable (PEN) bit (UART_LCR[3]) is set. In the FIFO mode,
            /// since the parity error is associated with a character received, it is revealed
            /// when the character with the parity error arrives at the top of the FIFO. It
            /// should be noted that the Parity Error (PE) bit (UART_LSR[2]) is set if a break
            /// interrupt has occurred, as indicated by Break Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no parity error
            /// 1: parity error Reading the UART_LSR clears the PE bit.
            PE: u1,
            /// Framing Error This is used to indicate the occurrence of a framing error in the
            /// receiver. A framing error occurs when the receiver does not detect a valid STOP
            /// bit in the received data. In the FIFO mode, since the framing error is
            /// associated with a character received, it is revealed when the character with the
            /// framing error is at the top of the FIFO. When a framing error occurs, the UART
            /// tries to resynchronize. It does this by assuming that the error was due to the
            /// start bit of the next character and then continues receiving the other bit i.e.
            /// data, and/or parity and stop. It should be noted that the Framing Error (FE) bit
            /// (UART_LSR[3]) is set if a break interrupt has occurred, as indicated by Break
            /// Interrupt (BI) bit (UART_LSR[4]).
            /// 0: no framing error
            /// 1: framing error Reading the UART_LSR clears the FE bit.
            FE: u1,
            /// Break Interrupt This is used to indicate the detection of a break sequence on
            /// the serial input data. If in UART mode (SIR_MODE == Disabled), it is set when
            /// the serial input, sir_in, is held in a logic '0' state for longer than the sum
            /// of + + + . If in infrared mode (SIR_MODE == Enabled), it is set when the serial
            /// input, sir_in, is continuously pulsed to logic '0' for longer than the sum of +
            /// + + . A break condition on serial input causes one and only one character,
            /// consisting of all zeros, to be received by the UART. In the FIFO mode, the
            /// character associated with the break condition is carried through the FIFO and is
            /// revealed when the character is at the top of the FIFO. Reading the UART_LSR
            /// clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately
            /// and persists until the UART_LSR is read.
            BI: u1,
            /// TX Holding Register Empty If the FIFOs are disabled, this bit is set to "1" when
            /// the TX Holding Register (UART_THR) is empty and ready to accept new data and it
            /// is cleared when the CPU writes to the TX Holding Register. If the FIFOs are
            /// enabled, this bit is set to "1" whenever the TX FIFO is empty and it is cleared
            /// when at least one byte is written to the TX FIFO.
            THRE: u1,
            /// Transmitter Empty If the FIFOs are disabled, this bit is set to "1" whenever the
            /// TX Holding Register (UART_THR) and the TX Shift Register are empty. If the FIFOs
            /// are enabled, this bit is set whenever the TX FIFO and the TX Shift Register are
            /// empty. In both cases, this bit is cleared when a byte is written to the TX data
            /// channel.
            TEMT: u1,
            /// RX Data Error in FIFO When FIFOs are disabled, this bit is always 0. When FIFOs
            /// are enabled, this bit is set to “1” when there is at least one PE, FE, or BI
            /// in the RX FIFO. It is cleared by reading from the UART_LSR register, there are
            /// no subsequent errors in the FIFO.
            FIFOERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x2501410
        /// UART Modem Control Register
        pub const UART_MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Terminal Ready This is used to directly control the Data Terminal Ready
            /// (dtr_n) output. The value written to this location is inverted and driven out on
            /// dtr_n.
            /// 0: dtr_n de-asserted (logic 1)
            /// 1: dtr_n asserted (logic 0) The DTR output is used to inform the modem or data
            /// set that the UART is ready to establish communications. Note that in Loopback
            /// mode (UART_MCR[4] is set to 1), the dtr_n output is held inactive high while the
            /// value of this location is internally looped back to an input.
            DTR: u1,
            /// Request to Send This is used to directly control the Request to Send (rts_n)
            /// output. The RTS (rts_n) output is used to inform the modem or data set that the
            /// UART is ready to exchange data. When Auto RTS Flow Control is not enabled ( is
            /// set to 0), the rts_n signal is set low by programming UART_MCR[1] (RTS) to a
            /// high. In Auto Flow Control, AFCE_MODE == Enabled and active ( is set to 1) and
            /// FIFOs enable (UART_FCR[0] is set to 1), the rts_n output is controlled in the
            /// same way, but is also gated with the receiver FIFO threshold trigger (rts_n is
            /// inactive high when above the threshold). The rts_n signal is de-asserted when
            /// UART_MCR[1] is set low.
            /// 0: rts_n de-asserted (logic 1)
            /// 1: rts_n asserted (logic 0) Note that in Loopback mode (UART_MCR[4] is set to
            /// 1), the rts_n output is held inactive high while the value of this location is
            /// internally looped back to an input.
            RTS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Loop Back Mode
            /// 0: Normal Mode
            /// 1: Loop Back Mode This is used to put the UART into a diagnostic mode for test
            /// purposes. If operating in UART mode (SIR_MODE != Enabled or not active,
            /// UART_MCR[6] is set to 0), the data on the SOUT line is held high, while serial
            /// data output is looped back to the sin line, internally. In this mode, all the
            /// interrupts are fully functional. Also, in loopback mode, the modem control
            /// inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control
            /// outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs,
            /// internally. If operating in infrared mode (SIR_MODE == Enabled AND active,
            /// UART_MCR[6] is set to 1), the data on the sir_out_n line is held low, while
            /// serial data output is inverted and looped back to the sir_in line.
            LOOP: u1,
            /// Auto Flow Control Enable When FIFOs are enabled and the AFCE bit is set, the
            /// AutoFlow Control is enabled.
            /// 0: Auto Flow Control mode disabled
            /// 1: Auto Flow Control mode enabled
            AFCE: u1,
            /// Select IrDA or RS485
            /// 00: UART Mode
            /// 01: IrDA SIR Mode
            /// 10: RS485 Mode
            /// 11: Reserved
            UART_FUNCTION: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x2501418
        /// UART Modem Status Register
        pub const UART_MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Delta Clear to Send This is used to indicate that the modem control line cts_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on ctsdsr_n since the last read of UART_MSR
            /// 1: change on ctsdsr_n since the last read of UART_MSR Reading the UART_MSR
            /// clears the DCTS bit. In Loopback Mode (UART_MCR[4] = 1), the DCTS reflects
            /// changes on the RTS (UART_MCR[1]).
            DCTS: u1,
            /// Delta Data Set Ready This is used to indicate that the modem control line dsr_n
            /// has changed since the last time the UART_MSR was read.
            /// 0: no change on dsr_n since the last read of UART_MSR
            /// 1: change on dsr_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDSR bit. In Loopback Mode (UART_MCR[4] = 1), the DDSR reflects changes on
            /// the DTR (UART_MCR[0] .
            DDSR: u1,
            /// Trailing Edge Ring Indicator This is used to indicate that a change in the input
            /// ri_n (from an active-low to an inactive-high state) has occurred since the last
            /// time the UART_MSR was read.
            /// 0: no change on ri_n since the last read of UART_MSR
            /// 1: change on ri_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the TERI bit.
            TERI: u1,
            /// Delta Data Carrier Detect This is used to indicate that the modem control line
            /// dcd_n has changed since the last time the UART_MSR was read.
            /// 0: no change on dcd_n since the last read of UART_MSR
            /// 1: change on dcd_n since the last read of UART_MSR Reading the UART_MSR clears
            /// the DDCD bit.
            DDCD: u1,
            /// Line State of Clear To Send This is used to indicate the current state of the
            /// modem control line cts_n. This bit is the complement of cts_n. When the Clear to
            /// Send input (cts_n) is asserted, it is an indication that the modem or data set
            /// is ready to exchange data with UART.
            /// 0: cts_n input is de-asserted (logic 1)
            /// 1: cts_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] = 1), the CTS
            /// is the same as the RTS (UART_MCR[1]).
            CTS: u1,
            /// Line State of Data Set Ready This is used to indicate the current state of the
            /// modem control line dsr_n. This bit is the complement of the dsr_n. When the Data
            /// Set Ready input (dsr_n) is asserted, it is an indication that the modem or data
            /// set is ready to establish communication with UART.
            /// 0: dsr_n input is de-asserted (logic 1)
            /// 1: dsr_n input is asserted (logic 0) In Loopback Mode (UART_MCR[4] is set to 1),
            /// the DSR is the same as the DTR (UART_MCR[0]).
            DSR: u1,
            /// Line State of Ring Indicator This is used to indicate the current state of the
            /// modem control line ri_n. This bit is the complement of ri_n. When the Ring
            /// Indicator input (ri_n) is asserted it is an indication that a telephone ringing
            /// signal has been received by setting the modem or data.
            /// 0: ri_n input is de-asserted (logic 1)
            /// 1: ri_n input is asserted (logic 0)
            RI: u1,
            /// Line State of Data Carrier Detect This is used to indicate the current state of
            /// the modem control line dcd_n. This bit is the complement of dcd_n. When the Data
            /// Carrier Detect input (dcd_n) is asserted it is an indication that the carrier
            /// has been detected by the modem or data set.
            /// 0: dcd_n input is de-asserted (logic 1)
            /// 1: dcd_n input is asserted (logic 0)
            DCD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x2501400
        /// UART Receive Buffer Register
        pub const UART_RBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver Buffer Register Data byte received on the serial input port (sin) in
            /// UART mode, or the serial infrared input (sir_in) in infrared mode. The data in
            /// this register is valid only if the Data Ready (DR) bit in is set. If in FIFO
            /// mode and FIFOs are enabled (The [0] is set to 1), this register accesses the
            /// head of the receive FIFO. If the receive FIFO is full and this register can not
            /// read before the next data character arrives, then the data already in the FIFO
            /// are preserved, but any incoming data are lost and an overrun error occurs.
            RBR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x2501484
        /// UART Receive FIFO Level Register
        pub const UART_RFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// RX FIFO Level The bit indicates the number of data entries in the RX FIFO.
            /// UART_RXDMA_CTRL
            RFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x84);

        /// address: 0x2501518
        /// UART_RXDMA_BL
        pub const UART_RXDMA_BL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Length Unit is byte Note that this field is only configurable while RXDMA
            /// Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x118);

        /// address: 0x2501500
        /// UART_RXDMA_CTRL
        pub const UART_RXDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            /// 0: RXDMA Disable
            /// 1: RXDMA Enable Note that if the software turns off this bit, the RXDMA will
            /// stop after the current block transfer completes, then the software should do a
            /// reset to the RX FIFO before re-enable.
            RXDMA: u1,
            /// Mode
            /// 0: Continous
            /// 1: Limited When data transferred reaches the limited count set in RXDMA LIMIT,
            /// the DMA stops and the RXDMA Start bit is cleared automatically. Note that this
            /// field is only configurable while RXDMA Busy is 0.
            RXDMA: u1,
            /// BLK SIZE Every time when data entries in RX FIFO reach BLK_SIZE, start a DMA
            /// block transfer. It is recommended that the block size no more than RX FIFO
            /// Depth.
            /// 00: 8 bytes
            /// 01: 16 bytes
            /// 10: 32 bytes
            /// 11: 64 bytes Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// AHB Burst Mode Set for AHB port burst supported INCR8 is recommended, while
            /// INCR16 may be unsupported due to the system bus.
            /// 00: SIGNLE
            /// 01: INCR4
            /// 10: INCR8
            /// 11: INCR16 Note that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u2,
            /// Timeout Enable Once enable, the DMA starts a transfer even the data entries in
            /// RX FIFO do not reach BLK_SIZE. Note that this field is only configurable when
            /// RXDMA Busy is 0.
            RXDMA: u1,
            reserved0: u1,
            /// Timeout Threshold Unit is 1 UART bit time Note that this field is only
            /// configurable when RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x2501538
        /// UART_RXDMA_DCNT
        pub const UART_RXDMA_DCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Count Only valid while RXDMA Mode is set to 1, it is used for counting the
            /// data transferred by RXDMA, and is cleared when reaches RXDMA Limit Size. Its
            /// unit is byte.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x138);

        /// address: 0x2501520
        /// UART_RXDMA_IE
        pub const UART_RXDMA_IE = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done RXDMA Limit Done Interrupt Enable
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done RXDMA BLK Done Interrupt Enable
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done RXDMA Timeout Done Interrupt Enable
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun RXDMA Buffer Overrun Interrupt Enable
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x2501524
        /// UART_RXDMA_IS
        pub const UART_RXDMA_IS = @intToPtr(*volatile Mmio(32, packed struct {
            /// RXDMA Limit Done Asserted when data transferred reaches limit size in RXDMA
            /// Limit Mode.
            RXDMA_LIMIT: u1,
            /// RXDMA BLK Done Asserted when a DMA block transfer is done.
            RXDMA_BLK: u1,
            /// RXDMA Timeout Done Asserted when a DMA transfer caused by timeout is done.
            RXDMA_TIMEOUT: u1,
            /// RXDMA Buffer Overrun Asserted when the RXDMA buffer is overflow.
            RXDMA_BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x250150c
        /// UART_RXDMA_LMT
        pub const UART_RXDMA_LMT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Limit Size Only valid when RXDMA Mode is set to 1, and the unit is byte. Note
            /// that this field is only configurable while RXDMA Busy is 0.
            RXDMA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10c);

        /// address: 0x2501534
        /// UART_RXDMA_RADDRH
        pub const UART_RXDMA_RADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[33:32] Software should update this register after reading
            /// data in RXDMA Buffer in time. It is byte address. The software should not update
            /// Buffer Read Address Register until until UART_RXDMA_STA[1] is 0. The software
            /// should update Read Address High Register first and then Read Address Low
            /// Register , even there is no change on Read Address High Register.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x2501530
        /// UART_RXDMA_RADDRL
        pub const UART_RXDMA_RADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Read Address[31:0] Software should update this register after reading
            /// data in RXDMA Buffer in time It is byte address. The software should not update
            /// Buffer Read Address Register until UART_RXDMA_STA[1] is 0. The software should
            /// update Read Address High Register first, and then Read Address Low Register,
            /// even there is no change on Read Address High Register.
            RXDMA: u32,
        }), base_address + 0x130);

        /// address: 0x2501514
        /// UART_RXDMA_SADDRH
        pub const UART_RXDMA_SADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [33:32] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x114);

        /// address: 0x2501510
        /// UART_RXDMA_SADDRL
        pub const UART_RXDMA_SADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Buffer Start Address [31:0] Byte address Note that this field is only
            /// configurable while RXDMA Busy is 0.
            RXDMA: u32,
        }), base_address + 0x110);

        /// address: 0x2501508
        /// UART_RXDMA_STA
        pub const UART_RXDMA_STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// BUSY
            /// 0: RXDMA is idle
            /// 1: RXDMA is busy
            RXDMA: u1,
            /// Buffer Read Address Updating
            /// 0: Buffer Read Address Register is ready for updating
            /// 1: Buffer Read Address Register is busy for updating The software should not
            /// update Buffer Read Address Register until this bit is 0.
            BUFFER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x108);

        /// address: 0x2501504
        /// UART_RXDMA_STR
        pub const UART_RXDMA_STR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start Only valid when RXDMA mode is set to 1, it is auto cleared when data
            /// transferred reaches the RXDMA Limit Size.
            RXDMA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x250152c
        /// UART_RXDMA_WADDRH
        pub const UART_RXDMA_WADDRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[33:32] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x12c);

        /// address: 0x2501528
        /// UART_RXDMA_WADDRL
        pub const UART_RXDMA_WADDRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current Write Address[31:0] Updated when every DMA transfer is done It is byte
            /// address.
            RXDMA: u32,
        }), base_address + 0x128);

        /// address: 0x250141c
        /// UART Scratch Register
        pub const UART_SCH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Scratch Register This register is for programmers to use as a temporary storage
            /// space. It has no defined purpose in the UART.
            SCRATCH_REG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x2501480
        /// UART Transmit FIFO Level Register
        pub const UART_TFL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TX FIFO Level The bit indicates the number of data entries in the TX FIFO.
            TFL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x80);

        /// address: 0x2501400
        /// UART Transmit Holding Register
        pub const UART_THR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit Holding Register Data is transmitted on the serial output port (SOUT)
            /// in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data
            /// should only be written to the when the THRE bit ( ) is set. If in FIFO mode and
            /// FIFOs are enabled ( = 1) and THRE is set, the 16 number of characters data may
            /// be written to the before the FIFO is full. When the FIFO is full, any written
            /// data results in the written data being lost.
            THR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x250147c
        /// UART Status Register
        pub const UART_USR = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART Busy Bit
            /// 0: Idle or inactive
            /// 1: Busy
            BUSY: u1,
            /// TX FIFO Not Full This is used to indicate that the TX FIFO is not full.
            /// 0: TX FIFO is full
            /// 1: TX FIFO is not full This bit is cleared when the TX FIFO is full.
            TFNF: u1,
            /// TX FIFO Empty This is used to indicate that the TX FIFO is completely empty.
            /// 0: TX FIFO is not empty
            /// 1: TX FIFO is empty This bit is cleared when the TX FIFO is no longer empty.
            TFE: u1,
            /// RX FIFO Not Empty This is used to indicate that the RX FIFO contains one or more
            /// entries.
            /// 0: RX FIFO is empty
            /// 1: RX FIFO is not empty This bit is cleared when the RX FIFO is empty.
            RFNE: u1,
            /// RX FIFO Full This is used to indicate that the RX FIFO is completely full.
            /// 0: RX FIFO not full
            /// 1: RX FIFO Full This bit is cleared when the RX FIFO is no longer full.
            RFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};